{"/docs/":{"data":{"":"","-welcome#üëã Welcome!":"Supported OSes Supported architectures Presented at Socials","an-actively-used-tool#An actively used tool":"RF Swift was born from real-world operational needs at Penthertz that no existing distribution could fully address.\nDuring security engagements, we often work on multiple projects within the same week‚Äîsometimes even the same day. This creates several challenges that traditional distributions struggle to handle:\nIsolation between engagements: Each project needs to remain completely separate to preserve integrity and avoid cross-contamination of traces and artifacts Reproducible environments: The ability to spin up known-working configurations instantly, without worrying about dependency conflicts or broken toolchains Experimentation without risk: Installing experimental tools or libraries for one engagement shouldn‚Äôt break the setup relied on for another Scalability and time saving: Consultants spend around 1‚Äì2 days setting up their computers with all the necessary tools‚Äîsometimes more when newly hired No conflict with company environments, especially on Linux: Not everyone has the luxury of a second laptop for dedicated security work. This solution lets you keep your internal corporate environment intact Maintain own images: People can maintain their own image and fit them on their needs","comprehensive-container-orchestration#Comprehensive Container Orchestration":"RF Swift provides a complete orchestration solution that goes beyond traditional containers. Unlike standard Docker, RF Swift simplifies the entire workflow with a straightforward learning curve:\ngraph TD A[rfswift] --\u003e B[Host manager] B --\u003e C[Host] B --\u003e D[USB] B --\u003e F[Sound] B --\u003e G[Images Container manager] H[Dockerfiles] --\u003e G G --\u003e I[Pull] G --\u003e J[List] G --\u003e K[Save] G --\u003e L[Tag] G --\u003e M[Run] G --\u003e N[Exec] style A fill:#f9f,stroke:#333,stroke-width:4px style B fill:#bbf,stroke:#333,stroke-width:2px style H fill:#afa,stroke:#333,stroke-width:2px style G fill:#bbf,stroke:#333,stroke-width:2px RF Swift handles everything from container creation and execution to pulling images, committing changes, and re-tagging. What sets it apart is the seamless integration of USB, video, and audio forwarding in a user-friendly interface‚Äîtasks that typically require significant expertise in standard Docker environments.","key-benefits-of-rf-swift#Key Benefits of RF Swift":"Flexibility: Use RF tools without disrupting your daily work environment Efficiency: Deploy only the tools you need, when you need them Security: Manage isolation between containers preventing cross-contamination Portability: Works across multiple architectures with consistent experience Resource Management: Optimized resource usage compared to full VMs","key-components#Key Components":"Go binary (rfswift)\nInstruments containers and hosts to simplify the use of tools that may require: Internet connectivity Display Sounds USB accesses This rfswift is the main program you will interact with to:\nRun clean containers Execute inside running or paused containers Perform many magic actions that will make things work without a headache Docker images - Pre-built Docker container images are available in RF Swift‚Äôs repository. In case you want to bake your own environment, preserve some space, and have a special set-up, you will also find some Docker files you can edit to fit your expectations.","next-steps#Next Steps":"Dive right into the following section to get started:\nRequirements \u0026 supportsRequirements \u0026 supported platforms Comparisons with dedicated distributionsCompare RF Swift with dedicated distributions Getting StartedSetup your environment Quick StartQuickly run RF Swift and start a container Compile RF Swift binaryCompile RF Swift and develop around the framework","questions-or-feedback#Questions or Feedback?":"‚ùì RF Swift is still in active development. Have a question or feedback? Feel free to open an issue!","what-is-rf-swift#What is RF Swift?":"RF Swift is a toolbox for creating a laboratory environment for your RF assessments, easily adaptable to your requirements:\nWorking tools for specific engagements available in seconds Reproducible setups for each context Custom recipes for your precise needs Freedom from bloated distributions where only 30% of the tools are used and half of what you need is missing No conflicts with your environment or security requirements, unlike dedicated distributions So this toolbox is probably the best solution to deploy a generic, as well as a special environment securely, skipping the headache and waste of time when installing and using RF tools on same host.\nEven if the project could work on macOS with some manual workaround, we do not advertise it for the moment, but this system will be fully supported in the near future."},"title":"Documentation"},"/docs/air-gapped-installation/":{"data":{"1-install-docker#1. Install Docker":"# Extract Docker binaries (uses wildcard to match any version) sudo tar xzf docker-*.tgz -C /opt/docker --strip-components=1 # Link to system path sudo ln -sf /opt/docker/* /usr/local/bin/ # Create Docker systemd service sudo tee /etc/systemd/system/docker.service \u003e /dev/null \u003c\u003c 'EOF' [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target docker.socket Wants=network-online.target [Service] Type=notify ExecStart=/usr/local/bin/dockerd ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=1048576 LimitNPROC=infinity LimitCORE=infinity TasksMax=infinity Delegate=yes KillMode=process Restart=on-failure [Install] WantedBy=multi-user.target EOF # Start Docker sudo systemctl daemon-reload sudo systemctl enable docker sudo systemctl start docker # Verify docker --version","1-set-disconnected-mode-by-default#1. Set Disconnected Mode by Default":"# Create alias echo 'alias rfswift=\"rfswift -q\"' \u003e\u003e ~/.bashrc source ~/.bashrc # Or create wrapper script sudo tee /usr/local/bin/rfswift-airgap \u003e /dev/null \u003c\u003c 'EOF' #!/bin/bash /usr/local/bin/rfswift -q \"$@\" EOF sudo chmod +x /usr/local/bin/rfswift-airgap","2-configure-x11-for-gui#2. Configure X11 for GUI":"# Allow local connections xhost +local: # Make persistent echo 'xhost +local:' \u003e\u003e ~/.xinitrc # Or for specific user xhost +SI:localuser:$(whoami)","2-install-rf-swift#2. Install RF Swift":"# Install binary sudo cp rfswift /usr/local/bin/ sudo chmod +x /usr/local/bin/rfswift # Verify rfswift --version","3-install-x11-utilities#3. Install X11 Utilities":"# For Debian/Ubuntu sudo dpkg -i airgap-debs/*.deb # Or manually install individual packages sudo dpkg -i xhost*.deb x11-xserver-utils*.deb # Verify which xhost","3-verify-installation#3. Verify Installation":"# Test disconnected mode rfswift -q last # List available images rfswift -q images local # Create test container rfswift -q run -i penthertz/rfswift_noble:sdr_full -n airgap_test # Test GUI (if X11 configured) rfswift -q exec -c airgap_test -e \"xclock\" # Cleanup test rfswift -q remove -c airgap_test","4-load-docker-images#4. Load Docker Images":"Method 1: Using rfswift import (for images downloaded with custom names)\n# Import images with custom filenames from download command rfswift import image -i rfswift_sdr_full.tar.gz rfswift import image -i rfswift_telecom.tar.gz rfswift import image -i rfswift_wifi.tar.gz rfswift import image -i rfswift_automotive.tar.gz # Verify rfswift -q images local Method 3: Import exported containers\nrfswift import container -i work_env.tar.gz -n restored_work:tag","air-gapped-installation-guide#Air-Gapped Installation Guide":"Air-Gapped Installation GuideComplete guide for installing and running RF Swift in air-gapped, offline, or isolated environments where internet access is restricted or prohibited.\nSecurity Note: Air-gapped installations are common in secure facilities, classified networks, and critical infrastructure environments. This guide ensures RF Swift works completely offline after initial setup.","automated-installation#Automated Installation":"On the air-gapped system:\n# Extract transfer package cd /path/to/rfswift-airgap-package # Run installation script sudo ./install-airgap.sh","configure-for-air-gapped-operation#Configure for Air-Gapped Operation":"","docker-wont-start#Docker Won\u0026rsquo;t Start":"Problem: Docker daemon fails to start\nSolutions:\n# Check Docker daemon logs sudo journalctl -u docker -n 50 # Verify kernel support uname -r # Should be 3.10+ # Check for missing kernel modules lsmod | grep overlay lsmod | grep bridge # Manually load if needed sudo modprobe overlay sudo modprobe br_netfilter # Restart Docker sudo systemctl restart docker","gui-applications-dont-work#GUI Applications Don\u0026rsquo;t Work":"Problem: X11 applications fail to start\nSolutions:\n# Verify X11 is running echo $DISPLAY # Check xhost permissions xhost # Allow Docker containers xhost +local:docker # Verify X11 socket exists ls -la /tmp/.X11-unix/ # Test X11 in container rfswift -q exec -c test -e \"echo \\$DISPLAY\" # Check X11 forwarding rfswift -q exec -c test -e \"xdpyinfo\" | head -5","images-wont-load#Images Won\u0026rsquo;t Load":"Problem: Cannot import Docker images\nSolutions:\n# Verify file integrity sha256sum image.tar.gz # Check file format file image.tar.gz # Try different import method gunzip image.tar.gz docker load -i image.tar # Check Docker storage docker system df df -h /var/lib/docker # Clean up space if needed rfswift -q cleanup --all","manual-installation#Manual Installation":"If you prefer manual installation:","network-checks-hanging#Network Checks Hanging":"Problem: Commands hang waiting for network\nSolutions:\n# Always use -q flag rfswift -q [command] # Set permanent alias alias rfswift='rfswift -q' # Check if accidentally using network strace rfswift last 2\u003e\u00261 | grep connect # Disable Docker DNS sudo tee /etc/docker/daemon.json \u003e /dev/null \u003c\u003c EOF { \"dns\": [\"127.0.0.1\"] } EOF sudo systemctl restart docker","option-a-official-images-using-download-feature#Option A: Official Images (Using download feature)":"# Install Docker and RF Swift temporarily on the online system # (or use existing installation) # Download RF Swift images with custom output names rfswift download -i penthertz/rfswift_noble:sdr_full -o rfswift_sdr_full.tar.gz rfswift download -i penthertz/rfswift_noble:telecom -o rfswift_telecom.tar.gz rfswift download -i penthertz/rfswift_noble:wifi -o rfswift_wifi.tar.gz rfswift download -i penthertz/rfswift_noble:automotive -o rfswift_automotive.tar.gz # Images are saved with custom names as specified with -o flag ls -lh *.tar.gz","option-b-custom-images-using-export#Option B: Custom Images (Using export)":"Exporting with RF Swift:\n# Export container as tarball rfswift export container -c my_work_container -o work_env.tar.gz # Export image rfswift export image my_custom:latest -o custom_image.tar.gz","overview#Overview":"Air-gapped installation requires downloading all components while online, then transferring them to the isolated system. RF Swift fully supports offline operation using the -q (disconnected mode) flag.","permission-denied#Permission Denied":"Problem: Cannot access devices or files\nSolutions:\n# Add user to docker group sudo usermod -aG docker $USER newgrp docker # Fix device permissions sudo chmod 666 /dev/ttyUSB0 # Use bindings for device access rfswift -q bindings add -c container -d -t /dev/ttyUSB0 # Add necessary capabilities rfswift -q capabilities add -c container -a NET_ADMIN rfswift -q capabilities add -c container -a SYS_ADMIN","phase-1-online-preparation#Phase 1: Online Preparation":"","phase-2-transfer-to-air-gapped-system#Phase 2: Transfer to Air-Gapped System":"Transfer the package using approved methods:\nUSB Drive: Copy to USB Secure File Transfer: Use transfer system Approved Network Transfer: If limited connectivity allowed # Example: USB transfer cp -r ~/rfswift-airgap-package /media/usb/ # Verify checksums on destination cd /media/usb/rfswift-airgap-package sha256sum -c SHA256SUMS","phase-3-air-gapped-installation#Phase 3: Air-Gapped Installation":"","phase-4-configuration--usage#Phase 4: Configuration \u0026amp; Usage":"","related-documentation#Related Documentation":"Requirements \u0026 Supported Platforms Quick Start Command Reference Security Guidelines üîí Security First: Always verify checksums of downloaded components. Use the -q flag to ensure no network calls in classified environments. Plan Ahead: Download more images than you think you‚Äôll need. Returning for additional components requires another approval cycle in secure facilities. Stay Updated: While air-gapped systems can‚Äôt auto-update, plan regular update cycles where new packages are brought in through approved channels.","step-1-download-docker#Step 1: Download Docker":"Download Docker static binaries from the official repository:\n# On a system with internet access cd ~/airgap-prep # For x86_64 systems wget https://download.docker.com/linux/static/stable/x86_64/docker-29.1.4.tgz # For ARM64 systems (if needed) wget https://download.docker.com/linux/static/stable/aarch64/docker-29.1.4.tgz # Verify download ls -lh docker-*.tgz Look for latest binaries directly on the official website: https://download.docker.com/linux/static/stable.","step-2-download-rf-swift-binary#Step 2: Download RF Swift Binary":"Download the latest RF Swift static binary from GitHub releases:\n# Download latest release for x86_64 wget https://github.com/PentHertz/RF-Swift/releases/download/v0.6.5-rc4/rfswift_Linux_x86_64.tar.gz tar -zvxf rfswift_Linux_x86_64.tar.gz # Make executable chmod +x rfswift # Verify ./rfswift --version For ARM64 systems:\nwget https://github.com/PentHertz/RF-Swift/releases/download/v0.6.5-rc4/rfswift_Linux_arm64.tar.gz tar -zvxf rfswift_Linux_arm64.tar.gz chmod +x rfswift For RISCV64 systems:\nwget https://github.com/PentHertz/RF-Swift/releases/download/v0.6.5-rc4/rfswift_Linux_riscv64.tar.gz tar -zvxf rfswift_Linux_riscv64.tar.gz chmod +x rfswift","step-3-download-x11-utilities-for-gui#Step 3: Download X11 Utilities (for GUI)":"For systems that need GUI applications (GQRX, SDR++, URH, etc.):\nDebian/Ubuntu:\n# Download xhost and dependencies apt-get download xhost x11-xserver-utils libx11-6 libxau6 libxdmcp6 libxcb1 # Or create a local repository mkdir -p airgap-debs cd airgap-debs apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances xhost x11-xserver-utils | grep \"^\\w\" | sort -u) RHEL/CentOS:\nyumdownloader --resolve xorg-x11-server-utils libX11 Alpine:\napk fetch --recursive xhost xauth","step-4-prepare-docker-images#Step 4: Prepare Docker Images":"You have two options for Docker images:","step-5-create-transfer-package#Step 5: Create Transfer Package":"Organize everything for transfer:\n# Create transfer directory mkdir -p ~/rfswift-airgap-package cd ~/rfswift-airgap-package # Copy all components cp ~/airgap-prep/docker-*.tgz . cp ~/airgap-prep/rfswift . cp ~/airgap-prep/*.tar.gz . cp -r ~/airgap-prep/airgap-debs . # Create installation script cat \u003e install-airgap.sh \u003c\u003c 'EOF' #!/bin/bash # RF Swift Air-Gapped Installation Script set -e INSTALL_DIR=\"/usr/local/bin\" DOCKER_DIR=\"/opt/docker\" echo \"=== RF Swift Air-Gapped Installation ===\" echo \"\" # Check if running as root if [ \"$EUID\" -ne 0 ]; then echo \"Please run as root or with sudo\" exit 1 fi # Install Docker echo \"[1/5] Installing Docker...\" mkdir -p $DOCKER_DIR tar xzf docker-*.tgz -C $DOCKER_DIR --strip-components=1 # Link Docker binaries for binary in $DOCKER_DIR/*; do ln -sf \"$binary\" \"$INSTALL_DIR/$(basename $binary)\" done # Create systemd service for Docker cat \u003e /etc/systemd/system/docker.service \u003c\u003c 'DOCKERSERVICE' [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target docker.socket Wants=network-online.target [Service] Type=notify ExecStart=/usr/local/bin/dockerd ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=1048576 LimitNPROC=infinity LimitCORE=infinity TasksMax=infinity Delegate=yes KillMode=process Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.target DOCKERSERVICE systemctl daemon-reload systemctl enable docker systemctl start docker sleep 3 echo \"‚úì Docker installed\" # Install RF Swift echo \"[2/5] Installing RF Swift...\" cp rfswift $INSTALL_DIR/ chmod +x $INSTALL_DIR/rfswift echo \"‚úì RF Swift installed\" # Install X11 utilities (if available) echo \"[3/5] Installing X11 utilities...\" if [ -d \"airgap-debs\" ]; then dpkg -i airgap-debs/*.deb 2\u003e/dev/null || true echo \"‚úì X11 utilities installed\" else echo \"‚ö† X11 utilities not found (GUI apps may not work)\" fi # Load Docker images echo \"[4/5] Loading Docker images...\" for image in *.tar.gz; do if [[ \"$image\" != \"docker-\"* ]] \u0026\u0026 [[ \"$image\" != \"rfswift_\"* ]]; then echo \" Loading: $image\" rfswift import -t image -i \"$image\" fi done # Load RF Swift images (custom names) for image in rfswift_*.tar.gz; do if [ -f \"$image\" ]; then echo \" Loading: $image\" rfswift import -t image -i \"$image\" fi done echo \"‚úì Images loaded\" # Verify installation echo \"[5/5] Verifying installation...\" docker --version rfswift --version rfswift -q images local echo \"\" echo \"=== Installation Complete ===\" echo \"\" echo \"Run: rfswift -q run -i penthertz/rfswift_noble:sdr_full -n test\" echo \"(Use -q flag for disconnected mode)\" EOF chmod +x install-airgap.sh # Create README cat \u003e README.txt \u003c\u003c 'EOF' RF Swift Air-Gapped Installation Package ========================================= This package contains everything needed to install RF Swift in an air-gapped environment. Contents: - docker-*.tgz : Docker static binaries - rfswift : RF Swift binary (static) - *.tar.gz : Docker images - airgap-debs/ : X11 utilities (if needed) - install-airgap.sh : Automated installation script Installation: 1. Transfer this entire directory to the air-gapped system 2. Run: sudo ./install-airgap.sh 3. Use: rfswift -q [command] Note: Always use -q flag in air-gapped environments to disable update checks. For manual installation, see: https://rfswift.io/docs/air-gapped-installation/ EOF echo \"‚úì Transfer package ready: $(pwd)\" ls -lh","step-6-calculate-transfer-size#Step 6: Calculate Transfer Size":"# Check total size du -sh ~/rfswift-airgap-package # Create checksum file cd ~/rfswift-airgap-package sha256sum * \u003e SHA256SUMS","troubleshooting#Troubleshooting":"","what-youll-need#What You\u0026rsquo;ll Need":"Downloaded while online:\nDocker static binaries RF Swift binary (static compilation) Docker images (via download or export) X11 utilities (for GUI applications) Target system requirements:\nA Linux system - Debian or Ubuntu recommended x86_64, RISCV64 or ARM64 architecture Storage for Docker images (5-20 GB depending on images)"},"title":"üìµ Air-Gapped Installation"},"/docs/commands/":{"data":{"-command-categories#üìã Command Categories":"","-container-management#üê≥ Container Management":"runCreate and start a new container execExecute commands in a running container stopStop a running container removeRemove a container renameRename a container commitSave container as new image","-dynamic-configuration#‚öôÔ∏è Dynamic Configuration":"bindingsManage device and volume bindings capabilitiesManage Linux capabilities cgroupsManage cgroup device rules portsManage container ports","-getting-help#üÜò Getting Help":"rfswift --help # All commands rfswift run --help # Specific command rfswift bindings add --help # Subcommand üí° New to RF Swift? Start with the Quick Start Guide before diving into command details.","-global-flags#üîå Global Flags":"","-image-management#üñºÔ∏è Image Management":"imagesManage RF Swift images (pull, list, search) buildBuild image from YAML recipe deleteDelete an image retagRename an image tag downloadDownload and save image to tar.gz importImport containers or images exportExport containers or images","-quick-reference#üöÄ Quick Reference":"Command Purpose rfswift run -i IMAGE -n NAME Create new container rfswift exec -c CONTAINER Enter container rfswift last List recent containers rfswift bindings add -c CONTAINER -d -t DEVICE Add device rfswift capabilities add -c CONTAINER -a CAP Add capability rfswift ports bind -c CONTAINER -p PORT Bind port rfswift images pull -i IMAGE Download image rfswift build -r RECIPE.yaml Build from recipe rfswift log replay -i FILE.cast Replay session rfswift update Update RF Swift","-session-recording#üìπ Session Recording":"logRecord and replay terminal sessions","-system-operations#üîß System Operations":"hostHost system configuration updateUpdate RF Swift binary completionGenerate shell completion scripts installInstall helper scripts","-utilities#üõ†Ô∏è Utilities":"lastShow recently used containers cleanupClean up old containers and images upgradeUpgrade container to new image","disconnected-mode#Disconnected Mode":"All RF Swift commands support the -q or --disconnect flag to disable update checks when working offline or in air-gapped environments:\n# Work without querying for updates rfswift -q run -i sdr_full -n work rfswift --disconnect last rfswift -q images local # Useful for: # - Offline/air-gapped systems # - Avoiding network delays # - Scripting/automation # - Systems behind firewalls When disconnected mode is enabled, RF Swift skips checking for new versions and runs immediately without any network queries. All functionality remains available - only the update notification system is disabled.","rf-swift-command-reference#RF Swift Command Reference":"RF Swift Command ReferenceComplete reference for all RF Swift commands. Each command has its own dedicated page with syntax, options, and examples.\nQuick Help: Use rfswift [command] --help for instant command help."},"title":"üìò Commands"},"/docs/commands/bindings/":{"data":{"binding-not-visible-in-container#Binding Not Visible in Container":"Problem: Added binding but can‚Äôt see it in container\nSolutions:\n# Check if binding was actually added docker inspect container | grep -A5 Binds # Try accessing directly rfswift exec -c container ls -la /path/to/binding exit # Remove and re-add with correct paths rfswift bindings rm -c container -s source -t target rfswift bindings add -c container -s source -t target","bindings-add#bindings add":"Add a new volume mount or device binding to a container.\nOptions:\nFlag Description Required Example -c, --container STRING Container ID or name Yes -c my_container -s, --source STRING Source path/device Optional* -s ~/captures -t, --target STRING Target path in container Yes -t /root/captures -d, --devices Manage device (not volume) No -d If source is omitted, source equals target.","bindings-rm#bindings rm":"Remove an existing volume mount or device binding from a container.\nOptions:\nFlag Description Required Example -c, --container STRING Container ID or name Yes -c my_container -s, --source STRING Source path/device Optional* -s ~/captures -t, --target STRING Target path in container Yes -t /root/captures -d, --devices Manage device (not volume) No -d If source is omitted, source equals target.","bindings-vs-initial-mount#Bindings vs Initial Mount":"","cannot-remove-binding#Cannot Remove Binding":"Problem: rm command fails\nSolutions:\n# Check exact paths used docker inspect container | grep -A10 Binds # Use same source and target as when added rfswift bindings rm -c container \\ -s /exact/source/path \\ -t /exact/target/path # If still fails, recreate container # (as last resort)","comparison#Comparison":"Feature Runtime Bindings Initial Mount (run -b) When After creation At creation Restart needed ‚ùå No N/A (during creation) Modification ‚úÖ Can add/remove ‚ùå Fixed Performance Same Same Use case Dynamic needs Known requirements","device-access-denied#Device Access Denied":"Problem: Device binding added but access denied in container\nSolutions:\n# Add device binding rfswift bindings add -d -c container -s /dev/device -t /dev/device # Add cgroup rule for device access rfswift cgroups add -c container -r \"c 189:* rwm\" # Check device major:minor numbers ls -l /dev/device # Example: crw-rw---- 1 root dialout 189, 0 # Add rule for correct major number rfswift cgroups add -c container -r \"c 189:* rwm\"","device-bindings#Device Bindings":"Add USB device:\nrfswift bindings add -d -c sdr_work \\ -s /dev/bus/usb \\ -t /dev/bus/usb or more simply if the target and source are the same:\nrfswift bindings add -d -c sdr_work \\ -t /dev/bus/usb If you know you will plug and unplug devices, just use the volume by turning of -d switch. Add USB serial device:\nrfswift bindings add -d -c analysis \\ -s /dev/ttyUSB0 \\ -t /dev/ttyUSB0","device-not-found#Device Not Found":"Problem: Device doesn‚Äôt exist at specified path\nSolutions:\n# Check device exists ls -l /dev/bus/usb # Check device name pattern ls -l /dev | grep rtl","dynamic-mounting#Dynamic Mounting":"When you add a binding to a running container:\nDocker updates container configuration Namespace modified to include new mount/device Immediate access - no restart needed Persists until removed or container deleted graph LR A[Host Directory/Device] --\u003e|Bind Mount| B[Container Namespace] B --\u003e|Access| C[Container Process] C --\u003e|Read/Write| A","examples#Examples":"","how-bindings-work#How Bindings Work":"","permission-denied-on-volume#Permission Denied on Volume":"Problem: Can‚Äôt write to mounted volume\nSolutions:\n# Check host directory permissions ls -ld ~/data # Fix permissions chmod 755 ~/data # Or run container as specific user # (requires container recreation) # Or use capabilities rfswift capabilities add -c container -p DAC_OVERRIDE","related-commands#Related Commands":"run - Create containers with initial bindings cgroups - Manage device permissions capabilities - Manage container capabilities exec - Access container after adding bindings üîå Hot-Plugging: The bindings command enables hot-plugging devices and volumes without container restart. Perfect for SDR work where devices are frequently connected/disconnected! Device Permissions: Adding device bindings (-d flag) usually requires corresponding cgroup rules. Use rfswift cgroups add to grant device access after adding the binding. Volumes vs Devices: Use bindings add without -d for directories/files (volumes), and with -d for hardware devices like SDRs, USB devices, serial ports, etc.","rfswift-bindings#rfswift bindings":"rfswift bindingsDynamically add or remove volume mounts and device bindings to running containers.","source-path-not-found#Source Path Not Found":"Error: source path does not exist\nSolutions:\n# Check source path exists ls -la /path/to/source # Create directory if needed mkdir -p ~/data # Use absolute path rfswift bindings add -c container \\ -s /home/user/data \\ -t /root/data","subcommands#Subcommands":"","synopsis#Synopsis":"# Add volume binding rfswift bindings add -c CONTAINER -s SOURCE -t TARGET # Add device binding rfswift bindings add -d -c CONTAINER -s SOURCE -t TARGET # Remove volume binding rfswift bindings rm -c CONTAINER -s SOURCE -t TARGET # Remove device binding rfswift bindings rm -d -c CONTAINER -s SOURCE -t TARGET The bindings command allows you to add or remove volume mounts and device mappings to containers without restarting them. This is part of RF Swift‚Äôs dynamic container management features.","troubleshooting#Troubleshooting":"","volume-bindings#Volume Bindings":"Add volume mount:\nrfswift bindings add -c my_container \\ -s ~/captures \\ -t /root/captures Add multiple volumes:\nrfswift bindings add -c sdr_work -s ~/data -t /root/data rfswift bindings add -c sdr_work -s ~/scripts -t /root/scripts rfswift bindings add -c sdr_work -s ~/configs -t /root/.config Add read-only volume:\nrfswift bindings add -c container \\ -s ~/reference-data \\ -t /root/reference:ro Remove volume mount:\nrfswift bindings rm -c my_container \\ -s ~/captures \\ -t /root/captures","volume-vs-device-bindings#Volume vs Device Bindings":"Volume Bindings (without -d):\nMount host directories into container Share files between host and container Two-way sync (changes visible on both sides) Use for: data, configs, scripts Can be use to share devices and resists to hot(un)plug Device Bindings (with -d):\nExpose hardware devices to container Direct device access Requires proper permissions (cgroups) Use for: SDR, serial, USB devices Not hot(un)plug resistant","when-to-use-each#When to Use Each":"Use runtime bindings when:\n‚úÖ Requirements change during work ‚úÖ Hot-plugging devices ‚úÖ Temporary data access ‚úÖ Testing different configurations ‚úÖ Adding forgotten mounts Use initial -b flag when:\n‚úÖ Requirements known upfront ‚úÖ Permanent mounts needed ‚úÖ Creating container fresh ‚úÖ Documenting standard setup Example:\n# Initial mount at creation rfswift run -i sdr_full -n work \\ -b /pathto/scripts:/root/scripts # Later add more dynamically rfswift bindings add -c work -s /pathto/captures -t /root/captures # Add device when plugged in rfswift bindings add -d -c work -s /dev/bus/usb -t /dev/bus/usb"},"title":"bindings"},"/docs/commands/build/":{"data":{"base-image-not-found#Base Image Not Found":"Error: Error: base image not found\nSolutions:\n# Pull base image first rfswift images pull penthertz/rfswift_noble:sdr_full # Check available images rfswift images local # Verify base image name in recipe grep \"^base:\" recipe.yaml","base-required#base (Required)":"Base image to build from. Usually an RF Swift image.\nbase: penthertz/rfswift_noble:sdr_full Common base images:\npenthertz/rfswift_noble:sdr_full - Complete SDR stack penthertz/rfswift_noble:sdr_light - Lightweight SDR penthertz/rfswift_noble:bluetooth - Bluetooth tools penthertz/rfswift_noble:wifi - WiFi tools penthertz/rfswift_noble:hardware - Hardware security tools","basic-structure#Basic Structure":"# Image metadata name: my_custom_image tag: my_custom:v1.0 base: penthertz/rfswift_noble:sdr_full # Package installation packages: - package1 - package2 - package3 # Environment variables environment: - VAR1=value1 - VAR2=value2 # File copies files: - src: local/file.txt dest: /container/path/ # Custom commands commands: - command1 - command2 # Cleanup scripts scripts: - cleanup_command1 - cleanup_command2 # Working directory workdir: /root/workspace","basic-usage#Basic Usage":"Build from default recipe:\nrfswift build Build from specific recipe:\nrfswift build -r custom-sdr-recipe.yaml Build with custom tag:\nrfswift build -r my-recipe.yaml -t my_image:test Build without cache:\nrfswift build -r recipe.yaml --no-cache","build-cache-issues#Build Cache Issues":"Problem: Build not reflecting changes\nSolution:\n# Force rebuild without cache rfswift build -r recipe.yaml --no-cache # Clear Docker build cache docker builder prune","commands-optional#commands (Optional)":"Commands to run during build.\ncommands: - chmod +x /usr/local/bin/script.sh - pip3 install custom-package - git clone https://github.com/user/repo /opt/repo - make -C /opt/repo install","complete-example#Complete Example":"name: advanced_sdr_setup tag: advanced_sdr:v2.0 base: penthertz/rfswift_noble:sdr_full # Install additional tools packages: - gqrx-sdr - inspectrum - urh - universal-radio-hacker - gr-gsm - gr-lte # Set environment environment: - SDR_BUFFER_SIZE=262144 - DISPLAY=:0 - PULSE_SERVER=tcp:127.0.0.1:34567 # Copy custom files files: - src: ./configs/sdr-config.conf dest: /root/.config/ - src: ./scripts/startup.sh dest: /usr/local/bin/ - src: ./tools/custom-tool dest: /opt/tools/ # Post-installation commands commands: - chmod +x /usr/local/bin/startup.sh - chmod +x /opt/tools/custom-tool - ln -s /opt/tools/custom-tool /usr/local/bin/ - mkdir -p /root/captures - mkdir -p /root/analysis # Cleanup scripts: - apt-get clean - rm -rf /var/lib/apt/lists/* - rm -rf /tmp/* - rm -rf /root/.cache/* # Set working directory workdir: /root/workspace","environment-optional#environment (Optional)":"Environment variables to set.\nenvironment: - PATH=/opt/tools:$PATH - CUSTOM_VAR=value - DEBUG=1","examples#Examples":"","file-copy-failed#File Copy Failed":"Error: COPY failed: stat /src/file: no such file or directory\nSolutions:\n# Check source file exists relative to recipe ls -l ./configs/file.txt # Use correct relative path files: - src: ./configs/file.txt # Relative to recipe location dest: /root/.config/ # Verify directory structure tree .","files-optional#files (Optional)":"Files to copy into the image.\nfiles: - src: ./local/config.txt dest: /root/.config/ - src: ./scripts/ dest: /opt/scripts/ - src: ./tool dest: /usr/local/bin/tool Paths:\nsrc: Relative to recipe file location dest: Absolute path in container","invalid-recipe-format#Invalid Recipe Format":"Error: Error parsing recipe: invalid YAML\nSolutions:\n# Validate YAML syntax yamllint recipe.yaml # Check indentation (must use spaces, not tabs) cat -A recipe.yaml | grep \"^I\" # Common issues: # - Missing colons after keys # - Incorrect indentation # - Tabs instead of spaces","name-required#name (Required)":"Image name for documentation purposes.\nname: my_custom_sdr","options#Options":"Flag Description Default Example -r, --recipe STRING Path to recipe file rfswift-recipe.yaml -r my-recipe.yaml -t, --tag STRING Override tag from recipe From recipe -t my_custom:v1 --no-cache Build without using cache false --no-cache","package-installation-failed#Package Installation Failed":"Error: E: Unable to locate package\nSolutions:\n# Update package lists in recipe packages: - apt-update # Add this first # Or add to commands section commands: - apt-get update - apt-get install -y your-package # Check package name spelling apt-cache search package-name","packages-optional#packages (Optional)":"APT packages to install.\npackages: - gqrx-sdr - inspectrum - wireshark - python3-pip","real-world-scenarios#Real-World Scenarios":"Create custom SDR environment:\n# Create recipe cat \u003e sdr-custom.yaml \u003c\u003c 'EOF' name: my_sdr_custom tag: sdr_custom:v1.0 base: penthertz/rfswift_noble:sdr_light packages: - gqrx-sdr - inspectrum - urh scripts: - apt-get clean - rm -rf /var/lib/apt/lists/* EOF # Build rfswift build -r sdr-custom.yaml","recipe-file-format#Recipe File Format":"","recipe-file-not-found#Recipe File Not Found":"Error: Error: recipe file not found\nSolutions:\n# Check file exists ls -l rfswift-recipe.yaml # Use absolute path rfswift build -r /full/path/to/recipe.yaml # Check current directory pwd","recipe-sections#Recipe Sections":"","related-commands#Related Commands":"run - Run containers from built images commit - Save modified containers as images export - Export built images images - Manage built images delete - Remove built images üî® Recipe vs Dockerfile: RF Swift recipes provide a simplified YAML format that‚Äôs easier to read and maintain than Dockerfiles. They‚Äôre perfect for building custom RF Swift variants without Dockerfile complexity! File Paths: Files referenced in the files section must exist relative to the recipe file location. Use ./ prefix for clarity and always verify files exist before building. Cache Control: Use --no-cache when you want to ensure all packages are updated and all commands run fresh. Otherwise, Docker‚Äôs layer caching speeds up repeated builds.","rfswift-build#rfswift build":"rfswift buildBuild custom Docker images from simplified YAML recipe files.","scripts-optional#scripts (Optional)":"Cleanup scripts run at the end of the build.\nscripts: - apt-get clean - rm -rf /var/lib/apt/lists/* - rm -rf /tmp/* - history -c","synopsis#Synopsis":"rfswift build [-r RECIPE_FILE] [-t TAG] [--no-cache] The build command creates Docker images using RF Swift‚Äôs simplified YAML recipe format. This provides an easier alternative to Dockerfiles for building custom RF Swift images with specific tools and configurations.","tag-required#tag (Required)":"Docker image tag (repository:tag format).\ntag: my_custom_sdr:v1.0 Can be overridden with -t flag:\nrfswift build -r recipe.yaml -t override_tag:v2","troubleshooting#Troubleshooting":"","workdir-optional#workdir (Optional)":"Default working directory for the image.\nworkdir: /root/projects"},"title":"build"},"/docs/commands/capabilities/":{"data":{"basic-usage#Basic Usage":"Add network admin capability:\nrfswift capabilities add -c sdr_work -p NET_ADMIN Add raw socket capability:\nrfswift capabilities add -c packet_craft -p NET_RAW Add ptrace capability for debugging:\nrfswift capabilities add -c debug_session -p SYS_PTRACE Remove capability:\nrfswift capabilities rm -c container -p NET_ADMIN","cannot-remove-capability#Cannot Remove Capability":"Problem: Remove command fails\nSolutions:\n# Check current capabilities docker inspect container | grep -A5 CapAdd # Use exact capability name rfswift capabilities rm -c container -p NET_ADMIN # If still issues, capability may not have been added # (no error if removing non-existent capability)","capabilities-add#capabilities add":"Add a Linux capability to a container.\nOptions:\nFlag Description Required Example -c, --container STRING Container ID or name Yes -c my_container -p, --capability STRING Capability to add Yes -p NET_ADMIN","capabilities-rm#capabilities rm":"Remove a Linux capability from a container.\nOptions:\nFlag Description Required Example -c, --container STRING Container ID or name Yes -c my_container -p, --capability STRING Capability to remove Yes -p NET_ADMIN","capabilities-vs-privileged-mode#Capabilities vs Privileged Mode":"","capability-combinations#Capability Combinations":"","capability-not-taking-effect#Capability Not Taking Effect":"Problem: Added capability but operation still fails\nSolutions:\n# Check if capability was added docker inspect container | grep -A5 CapAdd # Try restarting process in container rfswift exec -c container # ... restart application ... # Some operations need multiple capabilities rfswift capabilities add -c container -p NET_ADMIN rfswift capabilities add -c container -p NET_RAW # May also need cgroup rules for devices rfswift cgroups add -c container -r \"c 189:* rwm\"","capability-risk-levels#Capability Risk Levels":"Low Risk:\nNET_BIND_SERVICE CHOWN (limited contexts) Medium Risk:\nNET_RAW NET_ADMIN DAC_READ_SEARCH High Risk:\nSYS_PTRACE DAC_OVERRIDE SETUID/SETGID Critical Risk (Avoid):\nSYS_ADMIN SYS_MODULE SYS_RAWIO","common-capabilities#Common Capabilities":"","common-combinations#Common Combinations":"WiFi Security Testing:\nrfswift capabilities add -c wifi_test -p NET_ADMIN rfswift capabilities add -c wifi_test -p NET_RAW Network Forensics:\nrfswift capabilities add -c forensics -p NET_ADMIN rfswift capabilities add -c forensics -p NET_RAW rfswift capabilities add -c forensics -p SYS_PTRACE System Debugging:\nrfswift capabilities add -c debug -p SYS_PTRACE rfswift capabilities add -c debug -p DAC_READ_SEARCH Web Development:\nrfswift capabilities add -c webdev -p NET_BIND_SERVICE Packet Analysis:\nrfswift capabilities add -c analysis -p NET_RAW rfswift capabilities add -c analysis -p NET_ADMIN","comparison#Comparison":"Feature Capabilities Privileged Mode Granularity Fine-grained All or nothing Security Better Worse Control Specific privileges Full privileges Risk Lower Higher Flexibility Add as needed Fixed at creation Best for Production Testing/development","examples#Examples":"","file-capabilities#File Capabilities":"DAC_OVERRIDE\nPurpose: Bypass file permission checks Use case: Access files regardless of permissions Risk: High - can read/write any file DAC_READ_SEARCH\nPurpose: Bypass read/execute permission checks Use case: Read files without permission Risk: Medium-High - can read protected files CHOWN\nPurpose: Change file ownership Use case: Changing file owners/groups Risk: Medium - can change file ownership","invalid-capability-name#Invalid Capability Name":"Error: invalid capability name\nSolutions:\n# Use correct capability names (all caps) # Good rfswift capabilities add -c work -p NET_ADMIN # Bad (wrong case) rfswift capabilities add -c work -p net_admin # Common capability names: # NET_ADMIN, NET_RAW, SYS_PTRACE, NET_BIND_SERVICE # DAC_OVERRIDE, DAC_READ_SEARCH, CHOWN","network-capabilities#Network Capabilities":"NET_ADMIN\nPurpose: Network administration (interfaces, routes, iptables) Use case: WiFi monitoring, packet capture, network reconfiguration Risk: Medium - can modify network configuration NET_RAW\nPurpose: Use RAW and PACKET sockets Use case: Packet crafting, raw socket operations, ping Risk: Medium - can send arbitrary packets NET_BIND_SERVICE\nPurpose: Bind to privileged ports (\u003c1024) Use case: Running services on standard ports Risk: Low - just port binding","operation-not-permitted#Operation Not Permitted":"Problem: Command fails with ‚ÄúOperation not permitted‚Äù\nSolutions:\n# Identify needed capability # Network operations ‚Üí NET_ADMIN rfswift capabilities add -c container -p NET_ADMIN # Raw sockets ‚Üí NET_RAW rfswift capabilities add -c container -p NET_RAW # Debugging ‚Üí SYS_PTRACE rfswift capabilities add -c container -p SYS_PTRACE # Privileged ports ‚Üí NET_BIND_SERVICE rfswift capabilities add -c container -p NET_BIND_SERVICE","permission-denied-error-persists#Permission Denied Error Persists":"Problem: Capability added but still permission denied\nSolutions:\n# May need multiple capabilities rfswift capabilities add -c work -p NET_ADMIN rfswift capabilities add -c work -p NET_RAW # Or may need privileged mode for this specific operation # (as last resort) rfswift run -i image -n work -u 1 # Check kernel security modules (SELinux, AppArmor) # May be blocking regardless of capabilities","real-world-scenarios#Real-World Scenarios":"WiFi monitoring mode:\n# Create container rfswift run -i penthertz/rfswift_noble:wifi -n wifi_mon # Add capabilities for WiFi monitoring rfswift capabilities add -c wifi_mon -p NET_ADMIN rfswift capabilities add -c wifi_mon -p NET_RAW # Add wireless interface rfswift bindings add -d -c wifi_mon -s /dev/wlan0 -t /dev/wlan0 # Now can set monitor mode rfswift exec -c wifi_mon airmon-ng start wlan0 exit Packet capture and analysis:\n# Network analysis container rfswift run -i penthertz/rfswift_noble:sdr_full -n netcap # Add packet capture capabilities rfswift capabilities add -c netcap -p NET_ADMIN rfswift capabilities add -c netcap -p NET_RAW # Run tcpdump rfswift exec -c netcap tcpdump -i eth0 -w capture.pcap exit Debugging application:\n# Development container rfswift run -i penthertz/rfswift_noble:sdr_full -n debug # Add debugging capability rfswift capabilities add -c debug -p SYS_PTRACE # Debug with GDB rfswift exec -c debug gdb -p exit Running services on privileged ports:\n# Web server container rfswift run -i penthertz/rfswift_noble:sdr_full -n web # Add capability to bind port 80 rfswift capabilities add -c web -p NET_BIND_SERVICE # Run web server on port 80 rfswift exec -c web python3 -m http.server 80 exit Network reconfiguration:\n# SDR with network tools rfswift run -i penthertz/rfswift_noble:sdr_full -n sdr_net # Add network capabilities rfswift capabilities add -c sdr_net -p NET_ADMIN rfswift capabilities add -c sdr_net -p NET_RAW # Configure network rfswift exec -c sdr_net ip link set dev eth0 mtu 9000 ip route add 192.168.1.0/24 via 192.168.1.1 exit","related-commands#Related Commands":"bindings - Add device/volume bindings cgroups - Manage device access run - Create containers with initial capabilities exec - Execute commands with added capabilities üîí Security First: Capabilities provide fine-grained privilege control. Always start with an unprivileged container and add only the specific capabilities needed for your task! High-Risk Capabilities: Capabilities like SYS_ADMIN, SYS_MODULE, and SYS_RAWIO provide extensive privileges. Avoid these in production. Use specific capabilities like NET_ADMIN or NET_RAW instead. Better Than Privileged: Using specific capabilities is more secure than running containers in privileged mode (-u 1). Grant only what‚Äôs needed: NET_ADMIN for WiFi, NET_RAW for packets, SYS_PTRACE for debugging.","rfswift-capabilities#rfswift capabilities":"rfswift capabilitiesDynamically add or remove Linux capabilities to running containers for fine-grained privilege control.","security-considerations#Security Considerations":"","security-hierarchy#Security Hierarchy":"Unprivileged Container (Safest) ‚Üì Add specific capabilities Container with Capabilities (Secure) ‚Üì Add more capabilities Container with Many Capabilities (Less secure) ‚Üì Enable privileged mode Privileged Container (Least secure)","subcommands#Subcommands":"","synopsis#Synopsis":"# Add capability rfswift capabilities add -c CONTAINER -p CAPABILITY # Remove capability rfswift capabilities rm -c CONTAINER -p CAPABILITY The capabilities command allows you to add or remove Linux capabilities to containers without restarting them. This provides fine-grained security control, granting specific privileges without running fully privileged containers.","system-capabilities#System Capabilities":"SYS_PTRACE\nPurpose: Trace processes with ptrace Use case: Debugging, reverse engineering, GDB Risk: High - can inspect/modify processes SYS_ADMIN\nPurpose: Wide range of system administration Use case: Mount operations, namespace management Risk: Very High - nearly equivalent to root SYS_MODULE\nPurpose: Load/unload kernel modules Use case: Custom kernel module work Risk: Critical - full kernel access","troubleshooting#Troubleshooting":"","when-to-use-each#When to Use Each":"Use capabilities when:\n‚úÖ Need specific privileges only ‚úÖ Production environment ‚úÖ Security is important ‚úÖ Know exact requirements ‚úÖ Want minimal risk Use privileged mode when:\n‚úÖ Quick testing ‚úÖ Need many privileges ‚úÖ Development only ‚úÖ Unsure what‚Äôs needed ‚ùå Not for production Example comparison:\n# Privileged mode (not recommended) rfswift run -i sdr_full -n work -u 1 # Better: Specific capabilities rfswift run -i sdr_full -n work rfswift capabilities add -c work -p NET_ADMIN rfswift capabilities add -c work -p NET_RAW"},"title":"capabilities"},"/docs/commands/cgroups/":{"data":{"basic-usage#Basic Usage":"Add USB device access:\nrfswift cgroups add -c sdr_work -r \"c 189:* rwm\" Add multiple device types:\nrfswift cgroups add -c analysis -r \"c 189:* rwm\" rfswift cgroups add -c analysis -r \"c 166:* rwm\" rfswift cgroups add -c analysis -r \"c 180:* rwm\" Remove cgroup rule:\nrfswift cgroups rm -c container -r \"c 189:* rwm\"","cannot-remove-rule#Cannot Remove Rule":"Problem: Remove command fails or rule persists\nSolutions:\n# Use exact rule string rfswift cgroups rm -c container -r \"c 189:* rwm\" # Check current rules docker inspect container | grep -A10 Devices # May need to restart container for removal # (as last resort) rfswift stop -c container rfswift exec -c container","cgroups-add#cgroups add":"Add a cgroup device rule to a container.\nOptions:\nFlag Description Required Example -c, --container STRING Container ID or name Yes -c my_container -r, --rule STRING Cgroup device rule Yes -r \"c 189:* rwm\"","cgroups-rm#cgroups rm":"Remove a cgroup device rule from a container.\nOptions:\nFlag Description Required Example -c, --container STRING Container ID or name Yes -c my_container -r, --rule STRING Cgroup device rule Yes -r \"c 189:* rwm\"","common-device-major-numbers#Common Device Major Numbers":"Device Type Major Number Examples USB Serial 188, 189 RTL-SDR, HackRF, USB devices USB ACM 166 ACM devices, modems USB Character 180 USB raw character devices TTY Serial 4 /dev/tty devices Video 81 /dev/video* (cameras) Sound 116 /dev/snd/* (audio) Input 13 /dev/input/* (keyboards, mice)","complete-device-access-setup#Complete Device Access Setup":"To access a hardware device from a container, you need three things:\nDevice binding (rfswift bindings) Cgroup rule (rfswift cgroups) Capabilities (rfswift capabilities) - sometimes graph TD A[Device Plugged In] --\u003e B[Add Device Binding] B --\u003e C[Add Cgroup Rule] C --\u003e D{Need Capabilities?} D --\u003e|Network device| E[Add NET_ADMIN] D --\u003e|Regular device| F[Ready to Use] E --\u003e F","device-access-workflow#Device Access Workflow":"","device-not-visible-in-container#Device Not Visible in Container":"Problem: Cgroup rule added but device doesn‚Äôt exist in container\nSolution:\n# This is a binding issue, not cgroups # Add device binding first rfswift bindings add -d -c container \\ -s /dev/device \\ -t /dev/device # Then add cgroup rule rfswift cgroups add -c container -r \"c 189:* rwm\"","examples#Examples":"","finding-device-major-numbers#Finding Device Major Numbers":"","permission-denied-after-adding-rule#Permission Denied After Adding Rule":"Problem: Device still shows permission denied\nSolutions:\n# Check rule was added docker inspect container | grep -A10 Devices # Verify device binding exists rfswift exec -c container ls -l /dev/device exit # If not visible, add binding first rfswift bindings add -d -c container -s /dev/device -t /dev/device # Then add cgroup rule rfswift cgroups add -c container -r \"c 189:* rwm\" # Check device major number is correct ls -l /dev/bus/usb # crw-rw-rw- 1 root root 189, 0 ... # ^^^ use this number # May need multiple rules for some devices rfswift cgroups add -c container -r \"c 188:* rwm\" rfswift cgroups add -c container -r \"c 180:* rwm\"","real-world-scenarios#Real-World Scenarios":"USB based SDRs setup:\n# Create container rfswift run -i penthertz/rfswift_noble:sdr_full -n sdrtest # Add device binding rfswift bindings add -d -c sdrtest -s /dev/bus/usb -t /dev/bus/usb # Add cgroup rule for USB access rfswift cgroups add -c sdrtest -r \"c 189:* rwm\" # Test access (e.g with RTL-SDR) rfswift exec -c sdrtest rtl_test -t exit USB serial device:\n# Container for serial work rfswift run -i penthertz/rfswift_noble:sdr_full -n serial_work # Add serial device rfswift bindings add -d -c serial_work -s /dev/ttyUSB0 -t /dev/ttyUSB0 # Add cgroup rules rfswift cgroups add -c serial_work -r \"c 188:* rwm\" rfswift cgroups add -c serial_work -r \"c 4:* rwm\" # Access serial rfswift exec -c serial_work screen /dev/ttyUSB0 115200 exit","related-commands#Related Commands":"bindings - Add device bindings (required first) capabilities - Add capabilities (sometimes needed) run - Create containers with initial device access exec - Access container after adding rules üîê Device Access Trinity: For hardware device access, you need three things: (1) bindings add -d to expose the device, (2) cgroups add to grant permission, and (3) sometimes capabilities add for system privileges! Binding First: Always add the device binding BEFORE adding cgroup rules. The container needs to see the device before you can grant permission to access it! USB Devices: Most SDRs use USB serial (major 189). Use ls -l /dev/device to find the major number, then add rule c 189:* rwm for full access to all USB serial devices.","rfswift-cgroups#rfswift cgroups":"rfswift cgroupsDynamically add or remove cgroup device access rules to running containers.","rule-examples#Rule Examples":"USB devices (most SDRs):\n\"c 189:* rwm\" # USB serial devices (major 189) \"c 188:* rwm\" # USB serial devices (major 188) ACM devices:\n\"c 166:* rwm\" # ACM devices (modems, etc.) TTY/Serial ports:\n\"c 4:* rwm\" # TTY devices All USB devices:\n\"c 189:* rwm\" \"c 188:* rwm\" \"c 180:* rwm\" \"c 166:* rwm\" Video devices:\n\"c 81:* rwm\" # Video4Linux devices Specific device:\n\"c 189:0 rwm\" # Specific USB device (major 189, minor 0)","rule-format#Rule Format":"Cgroup device rules follow this format:\n: Components:\ntype: c (character device) or b (block device) major: Device major number or * for all minor: Device minor number or * for all permissions: r (read), w (write), m (mknod)","subcommands#Subcommands":"","synopsis#Synopsis":"# Add cgroup rule rfswift cgroups add -c CONTAINER -r \"RULE\" # Remove cgroup rule rfswift cgroups rm -c CONTAINER -r \"RULE\" The cgroups command allows you to add or remove Linux cgroup device rules to containers without restarting them. This grants containers permission to access specific hardware devices.","troubleshooting#Troubleshooting":"","understanding-cgroup-rules#Understanding Cgroup Rules":"","using-ls--l#Using ls -l":"# Check device major:minor numbers ls -l /dev/device # Output: crw-rw-rw- 1 root root 189, 0 Jan 12 10:00 /dev/device # ^^^ ^ # major minor # Multiple devices ls -l /dev/device* /dev/otherpatterns","using-stat#Using stat":"# Get device numbers with stat stat -c \"%t:%T\" /dev/device # Output: bd:0 (189 in hex, 0 in decimal) # Decimal format stat -c \"%a %n\" /dev/device","using-sys-filesystem#Using /sys filesystem":"# Find all USB devices grep -r \"189\" /sys/class/* # Check specific device cat /sys/class/tty/ttyUSB0/dev # Output: 188:0","wildcard-not-working#Wildcard Not Working":"Problem: c 189:* doesn‚Äôt grant access to all devices\nSolutions:\n# Try specific major numbers rfswift cgroups add -c container -r \"c 189:* rwm\" rfswift cgroups add -c container -r \"c 188:* rwm\" # Or try specific device ls -l /dev/device # crw-rw-rw- 1 root root 189, 5 ... # ^^^ ^^^ # maj min rfswift cgroups add -c container -r \"c 189:5 rwm\"","wrong-major-number#Wrong Major Number":"Problem: Rule added but device still not accessible\nSolutions:\n# Get actual device major number ls -l /dev/device_name # crw-rw-rw- 1 root root 189, 0 ... # ^^^ # Or use stat stat -c \"%t:%T\" /dev/device_name # Add rule with correct major number rfswift cgroups add -c container -r \"c 189:* rwm\""},"title":"cgroups"},"/docs/commands/cleanup/":{"data":{"aggressive-strategy#Aggressive Strategy":"Remove everything unused:\n# Full cleanup rfswift cleanup --all --force Good for:\nEmergency space recovery Fresh start scenarios CI/CD systems","balanced-strategy#Balanced Strategy":"Remove most unused resources:\n# Containers and images rfswift cleanup --all Good for:\nRegular maintenance Development systems General cleanup","basic-usage#Basic Usage":"Interactive cleanup (asks confirmation):\nrfswift cleanup Full cleanup without prompts:\nrfswift cleanup --all --force Remove stopped containers only:\nrfswift cleanup --containers Remove unused images only:\nrfswift cleanup --images","cleanup-not-freeing-space#Cleanup Not Freeing Space":"Problem: Ran cleanup but disk usage still high\nSolutions:\n# Check what's using space docker system df -v # Try more aggressive cleanup docker system prune -a -f --volumes # Check for large log files find /var/lib/docker -name \"*.log\" -size +100M # Check other disk usage du -sh /var/lib/docker/* # May need to clean Docker logs truncate -s 0 /var/lib/docker/containers/*/*-json.log","cleanup-strategies#Cleanup Strategies":"","cleanup-targets#Cleanup Targets":"Resource Description When Removed Stopped containers Containers not running Always safe Dangling images Untagged images (:) Always safe Unused images Images not used by any container Safe if not needed Build cache Docker build layer cache Safe but slows rebuilds Networks Unused custom networks Usually safe","conservative-strategy#Conservative Strategy":"Remove only clearly unused resources:\n# Stopped containers only rfswift cleanup --containers --force Good for:\nProduction systems Careful disk management Preserving development environments","examples#Examples":"","important-container-removed#Important Container Removed":"Problem: Accidentally removed needed container\nSolutions:\n# Check backups ls ~/docker-backups/ # Restore from export rfswift import container -i backup.tar.gz -n restored_container # Recreate from image if no backup rfswift run -i penthertz/rfswift_noble:sdr_full -n recreated_container # Lesson: Always export important containers before cleanup rfswift export container -c important -o backup.tar.gz","options#Options":"Flag Description Default Example --all Remove all unused resources false --all --containers Remove stopped containers only false --containers --images Remove unused images only false --images --volumes Remove unused volumes only false --volumes --force Skip confirmation prompts false --force","permission-denied#Permission Denied":"Problem: Cleanup fails with permission errors\nSolutions:\n# Use sudo sudo rfswift cleanup --all --force # Or add user to docker group sudo usermod -aG docker $USER newgrp docker # Then retry rfswift cleanup --all --force","real-world-scenarios#Real-World Scenarios":"Weekly maintenance:\n# Clean up stopped containers and dangling images rfswift cleanup --containers --images Before major operations:\n# Free space before pulling large images rfswift cleanup --all # Then pull new images rfswift images pull -i penthertz/rfswift_noble:sdr_full Emergency disk space recovery:\n# Aggressive cleanup when disk is full rfswift cleanup --all --force # Check space recovered df -h Selective cleanup:\n# Keep running containers, remove images only rfswift cleanup --images --force Post-development cleanup:\n# After testing, clean up test containers and images rfswift cleanup --containers --images","related-commands#Related Commands":"last - List containers before cleanup remove - Remove specific containers delete - Remove specific images images - Check images before cleanup üßπ Regular Maintenance: Schedule regular cleanup with rfswift cleanup --containers --images --force to prevent disk space issues. Daily or weekly cleanup keeps your system healthy! Data Loss Risk: The --volumes flag removes ALL unused volumes, which may contain important data. Always check volumes before removing them, and backup any important data! Safe Defaults: Without flags, cleanup removes stopped containers and dangling images only - the safest cleanup. Use --all for more aggressive cleanup when you need more space.","rfswift-cleanup#rfswift cleanup":"rfswift cleanupAutomated cleanup of Docker resources to free disk space.","safety-levels#Safety Levels":"Safe to remove:\n‚úÖ Stopped containers (can recreate) ‚úÖ Dangling images (no tag, no use) ‚úÖ Build cache (recreated on next build) ‚úÖ Unused networks Caution required:\n‚ö†Ô∏è Unused images (may need later) ‚ö†Ô∏è Unused volumes (may contain data) Never removed:\n‚ùå Running containers ‚ùå Images used by running containers ‚ùå Volumes attached to containers","synopsis#Synopsis":"rfswift cleanup [OPTIONS] The cleanup command removes unused Docker resources including stopped containers, dangling images, unused volumes, and build cache. This helps maintain disk space and keep your Docker environment clean.","troubleshooting#Troubleshooting":"","what-gets-cleaned-up#What Gets Cleaned Up":""},"title":"cleanup"},"/docs/commands/commit/":{"data":{"basic-usage#Basic Usage":"Create backup image:\nrfswift commit -c my_sdr_work -i my_sdr_backup With version tag:\nrfswift commit -c assessment -i assessment_backup:v1.0 Before removing container:\n# Save state first rfswift commit -c temp_container -i saved_state # Safe to remove now rfswift remove -c temp_container # Can recreate later rfswift run -i saved_state -n restored_container","captured-in-image#Captured in Image":"When you commit a container, the new image includes:\nContent Included? Notes Container filesystem changes ‚úÖ Yes All modifications to files Installed packages ‚úÖ Yes APT, pip, npm packages Configuration files ‚úÖ Yes Modified configs in container Created files ‚úÖ Yes Scripts, data files, logs Environment variables ‚ö†Ô∏è Partial Runtime vars not preserved Running processes ‚ùå No Only filesystem, not RAM Mounted volumes ‚ùå No Volume data not in image Network configuration ‚ö†Ô∏è Partial Basic config only Port bindings ‚ùå No Must reconfigure on new container Example of what‚Äôs saved:\n# Inside container rfswift exec -c my_container # Changes that WILL be in committed image: apt-get install -y new-tool # ‚úÖ Saved pip3 install additional-package # ‚úÖ Saved echo \"alias ll='ls -la'\" \u003e\u003e ~/.bashrc # ‚úÖ Saved mkdir /root/my-scripts # ‚úÖ Saved cp tool.py /usr/local/bin/ # ‚úÖ Saved # Changes that WON'T be in committed image: # Data in mounted volumes # ‚ùå Not saved # Running processes # ‚ùå Not saved # Temporary /tmp files may not persist # ‚ö†Ô∏è Depends exit rfswift commit -c my_container -i my_configured_image","container-not-found#Container Not Found":"Error: Error: No such container: container_name\nSolutions:\n# List containers rfswift last","examples#Examples":"","image-name-already-exists#Image Name Already Exists":"Error: Error: Conflict: Tag already exists\nSolutions:\n# Option 1: Use different tag rfswift commit -c container -i image:v2 # Option 2: Remove old image first rfswift remove -c container rfswift commit -c container -i image:v1","mounted-volumes#Mounted Volumes":"Important: Mounted volume data is NOT included in committed images:\n# Create container with volume rfswift run -i sdr_full -n capture_work \\ -b ~/captures:/root/captures # Inside container rfswift exec -c capture_work # Files in /root/captures are on host (~/captures) # Files in /root/other are in container filesystem exit # Commit rfswift commit -c capture_work -i capture_backup # New container from committed image rfswift run -i capture_backup -n restored rfswift exec -c restored ls /root/captures # Empty! (no volume mounted) ls /root/other # Present! (was in container filesystem) exit # Need to mount volume again rfswift remove -c restored rfswift run -i capture_backup -n restored -b ~/captures:/root/captures","options#Options":"Flag Description Required Example -c, --container STRING Container to commit Yes -c my_container -i, --image STRING Name for new image Yes -i my_backup:v1","real-world-scenarios#Real-World Scenarios":"Save configured environment:\n# Spent hours configuring tools rfswift exec -c sdr_work # ... install additional tools, configure settings ... exit # Save all that work rfswift commit -c sdr_work -i sdr_configured:2024_01 Create project snapshot:\n# End of assessment phase rfswift commit -c client_assessment -i client_assessment_phase1:final # Continue to phase 2 rfswift exec -c client_assessment # ... more work ... exit # Save phase 2 rfswift commit -c client_assessment -i client_assessment_phase2:final Share custom environment with team:\n# Create customized environment rfswift commit -c my_setup -i team_sdr_environment:v1 # Export container for sharing rfswift export container -c team_sdr_environment:v1 -o sdr_backup.tar.gz # Export image for sharing rfswift export image -i imagetoexport -o sdr_backup.tar.gz # Team members import docker import Before major changes:\n# Checkpoint before risky operation rfswift commit -c production_monitor -i production_monitor_backup:pre_upgrade # Try upgrade rfswift exec -c production_monitor # ... attempt upgrade ... # ... something breaks ... exit # Restore from backup rfswift remove -c production_monitor rfswift run -i production_monitor_backup:pre_upgrade -n production_monitor Create versioned snapshots:\n# Daily snapshots during project rfswift commit -c research_container -i research_project:day_1 # ... work ... rfswift commit -c research_container -i research_project:day_2 # ... work ... rfswift commit -c research_container -i research_project:day_3 # Can return to any day's state rfswift run -i research_project:day_2 -n restore_day_2","related-commands#Related Commands":"run - Create containers from committed images export - Alternative backup method (creates tar.gz) import - Import exported containers download - Download images from registry to tar.gz images - Manage committed images remove - Remove containers after committing üí° Pro Tip: Before committing, clean up unnecessary files to keep image size small. Run apt-get clean, remove logs, and clear caches inside the container first! For portable backups, consider using export instead. Volume Data Not Included: Data in mounted volumes (specified with -b flag) is NOT saved in committed images. Only the container‚Äôs internal filesystem is captured. Use export for backups or copy volume data into container before committing. Commit vs Export vs Download: commit creates a Docker image for reuse, export creates a compressed portable backup, and download saves registry images offline. Choose based on your use case: development (commit), backup/transfer (export), or getting base images (download).","rfswift-commit#rfswift commit":"rfswift commitSave a container‚Äôs current state as a new Docker image.","synopsis#Synopsis":"rfswift commit -c CONTAINER_NAME -i NEW_IMAGE_NAME The commit command creates a new Docker image from a container‚Äôs current state, capturing all changes made to the filesystem. This is useful for preserving work, creating backups, or sharing customized environments.","troubleshooting#Troubleshooting":"","what-gets-committed#What Gets Committed":""},"title":"commit"},"/docs/commands/completion/":{"data":{"bash#Bash":"System-wide (requires sudo):\n/etc/bash_completion.d/rfswift User-specific:\n~/.bash_completion.d/rfswift ~/.bash_completion Enable in ~/.bashrc:\n# Add if not already present [[ -f ~/.bash_completion ]] \u0026\u0026 source ~/.bash_completion","basic-usage#Basic Usage":"Auto-detect and install:\nrfswift completion # Detected shell: bash # Installing completion script to /etc/bash_completion.d/rfswift # ‚úì Completion script installed successfully Install for specific shell:\n# Bash rfswift completion bash # Zsh rfswift completion zsh # Fish rfswift completion fish # PowerShell rfswift completion powershell","completion-features#Completion Features":"Smart completion:\nOnly shows relevant options for current context Completes container names from running containers Completes image names from local images Suggests common values for flags","completion-not-working#Completion Not Working":"Problem: Tab completion doesn‚Äôt work\nSolutions:\nFor Bash:\n# Check if completion file exists ls -la ~/.bash_completion.d/rfswift ls -la ~/.bash_completion # Check if sourced in .bashrc grep bash_completion ~/.bashrc # Add if missing echo '[[ -f ~/.bash_completion ]] \u0026\u0026 source ~/.bash_completion' \u003e\u003e ~/.bashrc # Reload source ~/.bashrc For Zsh:\n# Check if completion file exists ls -la ~/.zsh/completion/_rfswift # Check fpath echo $fpath # Add completion directory to .zshrc cat \u003e\u003e ~/.zshrc \u003c\u003c 'EOF' fpath=(~/.zsh/completion $fpath) autoload -Uz compinit compinit EOF # Reload source ~/.zshrc For Fish:\n# Check if completion file exists ls -la ~/.config/fish/completions/rfswift.fish # Reload completions fish_update_completions # Restart fish exec fish","completions-conflict#Completions Conflict":"Problem: Completions conflict with other tools\nSolutions:\n# Check what provides rfswift completion complete -p rfswift # Bash which -a rfswift # Check multiple installations # Remove conflicting completion rm /path/to/conflicting/completion # Reinstall correct one rfswift completion","examples#Examples":"","fish#Fish":"Location:\n~/.config/fish/completions/rfswift.fish No additional configuration needed - Fish loads completions automatically.","how-completion-works#How Completion Works":"","installation-locations#Installation Locations":"","old-completions-cached#Old Completions Cached":"Problem: Completions show old commands\nSolutions:\nBash:\n# Clear completion cache complete -r rfswift # Reinstall rfswift completion bash # Reload source ~/.bashrc Zsh:\n# Remove compiled completion files rm -f ~/.zcompdump* # Reinstall rfswift completion zsh # Rebuild cache autoload -Uz compinit compinit # Reload source ~/.zshrc Fish:\n# Clear fish cache rm -rf ~/.cache/fish/ # Reinstall rfswift completion fish # Restart exec fish","permission-denied#Permission Denied":"Problem: Cannot write completion file\nSolutions:\n# Check permissions ls -ld /etc/bash_completion.d # Install to user directory instead rfswift completion bash # Will install to ~/.bash_completion.d/ # Or use sudo for system-wide sudo rfswift completion bash","powershell#PowerShell":"Profile location:\n# Check profile path echo $PROFILE # Typical locations: # Windows PowerShell: # ~\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 # PowerShell Core: # ~\\Documents\\PowerShell\\Microsoft.PowerShell_profile.ps1 Enable in profile:\n# Add to profile . \"C:\\Path\\To\\CompletionScripts\\rfswift.ps1\"","related-commands#Related Commands":"update - Update RF Swift (refresh completions after) install - Install function scripts ‚å®Ô∏è Productivity Boost: Tab-completion dramatically improves workflow efficiency. Press Tab to complete commands, flags, container names, and image names automatically! Reload Required: After installing completions, you must reload your shell configuration (source ~/.bashrc or restart terminal) before tab-completion will work. Auto-Detection: Running rfswift completion without arguments automatically detects your shell and installs the appropriate completion script. You can also specify the shell explicitly!","rfswift-completion#rfswift completion":"rfswift completionGenerate and install shell completion scripts for tab-completion.","shell-not-detected#Shell Not Detected":"Problem: Auto-detection fails\nSolutions:\n# Specify shell explicitly rfswift completion bash # Or set SHELL variable export SHELL=/bin/bash rfswift completion","synopsis#Synopsis":"# Auto-detect shell and install rfswift completion # Install for specific shell rfswift completion bash rfswift completion zsh rfswift completion fish rfswift completion powershell The completion command generates and installs tab-completion scripts for your shell, enabling command, flag, and argument completion when you press Tab.","troubleshooting#Troubleshooting":"","what-gets-completed#What Gets Completed":"Commands:\nrfswift # Shows: run, exec, stop, remove, images, last, etc. Subcommands:\nrfswift images # Shows: local, remote, pull Flags:\nrfswift run - # Shows: -i, -n, -b, -p, -d, etc. Container names:\nrfswift exec -c # Shows: container1, container2, container3, etc. Image names:\nrfswift run -i # Shows: penthertz/rfswift_noble:sdr_full, penthertz/rfswift_noble:wifi, etc.","zsh#Zsh":"Common locations:\n~/.zsh/completion/_rfswift ~/.oh-my-zsh/completions/_rfswift /usr/local/share/zsh/site-functions/_rfswift ${fpath[1]}/_rfswift Enable in ~/.zshrc:\n# Add completion directory to fpath fpath=(~/.zsh/completion $fpath) # Initialize completion system autoload -Uz compinit compinit"},"title":"completion"},"/docs/commands/delete/":{"data":{"basic-usage#Basic Usage":"Delete by tag:\nrfswift delete -i penthertz/rfswift_noble:old_version Delete by image ID:\nrfswift delete -i a1b2c3d4e5f6 Delete custom built image:\nrfswift delete -i my_custom_sdr:v1.0","comparison#Comparison":"Command Target What It Deletes delete Images Docker images remove Containers Container instances","delete-vs-remove#Delete vs Remove":"","examples#Examples":"","image-deletion-impact#Image Deletion Impact":"When you delete an image:\nItem Deleted? Impact Image layers ‚úÖ Yes Removed from disk Image metadata ‚úÖ Yes Tags, labels removed Containers using image ‚ùå No Continue running Exported tar.gz files ‚ùå No Remain on disk Custom files you added ‚úÖ Yes Gone from image","image-has-dependent-child-images#Image Has Dependent Child Images":"Error: Error: image has dependent child images\nSolutions:\n# Force delete with docker docker rmi -f image:tag # Or delete child images first docker images --filter \"since=image:tag\" --format \"{{.Repository}}:{{.Tag}}\" | \\ while read child; do rfswift delete -i \"$child\" done # Then delete parent rfswift delete -i image:tag","image-in-use#Image In Use":"Error: Error: image is being used by running container\nSolutions:\n# Find containers using the image docker ps -a --filter ancestor=\"image:tag\" # Stop containers docker ps -a --filter ancestor=\"image:tag\" --format \"{{.Names}}\" | \\ xargs -r docker stop # Remove containers docker ps -a --filter ancestor=\"image:tag\" --format \"{{.Names}}\" | \\ xargs -r docker rm # Now delete image rfswift delete -i image:tag","image-not-found#Image Not Found":"Error: Error: No such image: image:tag\nSolutions:\n# Check exact image name rfswift images local # Check image ID docker images # Use correct format rfswift delete -i penthertz/rfswift_noble:sdr_full # Or by ID rfswift delete -i a1b2c3d4e5f6","important-notes#Important Notes":"Images in use cannot be deleted:\n# This will fail if containers are using the image rfswift delete -i penthertz/rfswift_noble:sdr_full # Error: image is being used by running container Solution: Stop/remove containers first:\n# Stop containers using the image rfswift stop -c container_using_image # Remove containers rfswift remove -c container_using_image # Now delete image rfswift delete -i penthertz/rfswift_noble:old_version","options#Options":"Flag Description Required Example -i, --image STRING Image ID or tag to delete Yes -i penthertz/rfswift_noble:old_version","permission-denied#Permission Denied":"Error: Permission denied\nSolutions:\n# Use sudo sudo rfswift delete -i image:tag # Or add user to docker group sudo usermod -aG docker $USER newgrp docker # Then retry rfswift delete -i image:tag","real-world-scenarios#Real-World Scenarios":"Clean up old versions:\n# Check what you have rfswift images local # Delete old version rfswift delete -i penthertz/rfswift_noble:tag # Verify deletion rfswift images local Remove test images:\n# After testing rfswift delete -i test_image:experimental # Remove multiple test images rfswift delete -i test_build:v1 rfswift delete -i test_build:v2 rfswift delete -i test_build:v3 Free disk space:\n# Check current usage docker system df # Delete large unused images rfswift delete -i penthertz/rfswift_noble:sdr_full_old # Check space recovered docker system df Remove failed builds:\n# Build failed, leaving dangling image rfswift delete -i failed_build:latest # Or delete by ID rfswift delete -i a1b2c3d4e5f6 Cleanup after upgrade:\n# After upgrading containers, remove old image rfswift upgrade -c my_container -i new_image:v2 # Delete old image rfswift delete -i old_image:v1","related-commands#Related Commands":"images - List and manage images remove - Remove containers export - Backup images before deletion build - Build new images cleanup - Automated cleanup ‚ö†Ô∏è Permanent Deletion: Deleting an image is permanent. If you might need it later, use export image to create a backup first. You can always import it back if needed. Containers First: You cannot delete an image while containers are using it. Stop and remove containers first with stop and remove commands, then delete the image. Disk Space Recovery: Deleting large images can free significant disk space (1-4GB per image). Check with docker system df before and after to see space recovered!","rfswift-delete#rfswift delete":"rfswift deleteDelete Docker images from the local system to free disk space.","synopsis#Synopsis":"rfswift delete -i IMAGE_ID_OR_TAG The delete command removes Docker images from your local system. This is useful for freeing disk space, removing old versions, or cleaning up after testing.","tag-refers-to-multiple-images#Tag Refers to Multiple Images":"Problem: Same tag on different images\nSolution:\n# Use image ID instead of tag docker images # Delete by specific ID rfswift delete -i a1b2c3d4e5f6","troubleshooting#Troubleshooting":"","what-gets-deleted#What Gets Deleted":""},"title":"delete"},"/docs/commands/download/":{"data":{"authentication-required#Authentication Required":"Error: authentication required for private registry\nSolutions:\n# Login to registry first docker login registry.example.com # Enter username and password # Then download rfswift download -i registry.example.com/image:tag -o output.tar.gz # For Docker Hub private repos docker login rfswift download -i myuser/private-image:tag -o output.tar.gz","basic-usage#Basic Usage":"Download RF Swift image:\nrfswift download -i penthertz/rfswift_noble:sdr_full -o rfswift-sdr-full.tar.gz Download with automatic pull:\nrfswift download -i penthertz/rfswift_noble:sdr_full -o sdr_full.tar.gz --pull Download specific version:\nrfswift download -i penthertz/rfswift_noble:bluetooth -o bluetooth-tools-v2025.tar.gz Download to specific directory:\nrfswift download -i penthertz/rfswift_noble:wifi \\ -o ~/offline-images/wifi-tools-$(date +%Y%m%d).tar.gz","download-interrupted#Download Interrupted":"Problem: Download stopped mid-way\nSolutions:\n# Check if partial file exists ls -lh output.tar.gz # Remove partial file rm output.tar.gz # Retry download rfswift download -i penthertz/rfswift_noble:sdr_full -o output.tar.gz --pull # For unstable connections, use screen/tmux screen -S download rfswift download -i image -o output.tar.gz --pull # Ctrl+A, D to detach","examples#Examples":"","image-not-found-in-registry#Image Not Found in Registry":"Error: Error: image not found: penthertz/rfswift_noble:unknown_tag\nSolutions:\n# List available images rfswift images remote # Verify spelling rfswift download -i penthertz/rfswift_noble:sdr_full -o output.tar.gz","network-connection-failed#Network Connection Failed":"Error: Error: connection timeout or network unreachable\nSolutions:\n# Check network connectivity ping registry.hub.docker.com # Check Docker daemon docker info # Use proxy if behind firewall export HTTP_PROXY=http://proxy:port export HTTPS_PROXY=http://proxy:port # Retry with longer timeout # (May need Docker daemon configuration)","options#Options":"Flag Description Required Example -i, --image STRING Image name to download Yes -i penthertz/rfswift_noble:sdr_full -o, --output STRING Output file path Yes -o rfswift-sdr.tar.gz --pull Pull image first if not present locally No --pull","permission-denied#Permission Denied":"Error: permission denied writing output file\nSolutions:\n# Check directory permissions ls -ld $(dirname output.tar.gz) # Create directory with proper permissions mkdir -p ~/downloads chmod 755 ~/downloads # Use absolute path rfswift download -i image -o ~/downloads/image.tar.gz # Or use sudo sudo rfswift download -i image -o /opt/images/image.tar.gz","pull-flag-not-working#Pull Flag Not Working":"Problem: --pull doesn‚Äôt seem to work\nSolutions:\n# Verify flag syntax (no equals sign) rfswift download -i image -o output.tar.gz --pull # Not: --pull=true # Manually pull first if needed docker pull penthertz/rfswift_noble:sdr_full rfswift download -i penthertz/rfswift_noble:sdr_full -o output.tar.gz # Check image exists after pull docker images | grep rfswift","real-world-scenarios#Real-World Scenarios":"Prepare offline installation media:\n# Download all required RF Swift images rfswift download -i penthertz/rfswift_noble:sdr_full \\ -o /media/usb/rfswift-sdr-full.tar.gz --pull rfswift download -i penthertz/rfswift_noble:bluetooth \\ -o /media/usb/rfswift-bluetooth.tar.gz --pull rfswift download -i penthertz/rfswift_noble:wifi \\ -o /media/usb/rfswift-wifi.tar.gz --pull # Create README for offline users cat \u003e /media/usb/README.txt \u003c\u003c 'EOF' RF Swift Offline Installation To install: 1. Import images: rfswift import image -i rfswift-*.tar.gz 2. Run container: rfswift run -i penthertz/rfswift_noble:sdr_full -n workspace EOF Air-gapped system preparation:\n# On internet-connected system OFFLINE_DIR=~/offline-bundle mkdir -p \"$OFFLINE_DIR\" # Download latest images rfswift download -i penthertz/rfswift_noble:sdr_full \\ -o \"$OFFLINE_DIR/sdr_full_$(date +%Y%m%d).tar.gz\" --pull rfswift download -i penthertz/rfswift_noble:hardware \\ -o \"$OFFLINE_DIR/hardware_$(date +%Y%m%d).tar.gz\" --pull # Create checksum file cd \"$OFFLINE_DIR\" sha256sum *.tar.gz \u003e checksums.sha256 # Transfer entire directory to air-gapped system Version archival:\n# Archive specific version before upgrade rfswift download -i penthertz/rfswift_noble:sdr_full \\ -o archives/rfswift-sdr-full-v0.6.5.tar.gz # Document version echo \"RF Swift SDR Full v0.6.5 - Archived $(date)\" \\ \u003e archives/rfswift-sdr-full-v0.6.5.txt","related-commands#Related Commands":"export - Export local images/containers to tar.gz import - Import downloaded archives images - Manage images (pull, list) run - Run containers from downloaded images üì• Always Use ‚Äìpull: For downloading latest versions, always include the --pull flag. Without it, RF Swift uses the locally cached image which may be outdated. Space Requirements: Downloading and compressing images requires approximately 2x the final file size in available disk space. A 1.5 GB download needs ~3 GB free space. Offline Distribution: The download command is specifically designed for creating offline installation packages. Combine with import image on the destination system to complete the workflow.","rfswift-download#rfswift download":"rfswift downloadDownload Docker images from registries and save them as compressed archives for offline use.","synopsis#Synopsis":"rfswift download -i IMAGE_NAME -o OUTPUT_FILE.tar.gz [--pull] The download command pulls Docker images from registries (Docker Hub, private registries) and saves them locally as compressed tar.gz files. This enables offline distribution, air-gapped installations, and image archival.","troubleshooting#Troubleshooting":""},"title":"download"},"/docs/commands/exec/":{"data":{"advanced-usage#Advanced Usage":"","basic-usage#Basic Usage":"Enter most recent container:\nrfswift exec Enter specific container by name:\nrfswift exec -c my_sdr_container Enter with specific working directory:\nrfswift exec -c my_container -w /root/projects Enter by container ID:\nrfswift exec -c a1b2c3d4e5f6 Short container ID:\nrfswift exec -c a1b2c3","common-workflows#Common Workflows":"","comparison-run-vs-exec#Comparison: run vs exec":"Aspect run exec Purpose Create new container Enter existing container Container state Creates new Uses existing Image required Yes No Configuration Full options available Limited options Use when Starting new work Continuing existing work Typical frequency Once per project Multiple times per day Typical flow:\n# Day 1: Create with run rfswift run -i sdr_full -n project -b ~/work:/root/work # Day 1-N: Enter with exec rfswift exec -c project # ... work ... exit # Repeat exec as needed rfswift exec -c project","container-not-found#Container Not Found":"Error: Error: No such container: container_name\nSolutions:\n# List all containers to find correct name rfswift last # Maybe it was removed? rfswift run -i image -n container_name","container-selection#Container Selection":"Flag Description Default Example -c, --container STRING Container name or ID Most recent -c my_container -w, --workdir STRING Working directory inside container /root -w /root/projects","container-selection--c---container#Container Selection (\u003ccode\u003e-c, --container\u003c/code\u003e)":"Specifies which container to enter. Accepts:\nContainer name: Full name as specified during creation Container ID: Full or partial Docker container ID Auto-selection: If omitted, uses most recently created container How auto-selection works:\n# These containers were created in this order: # 1. sdr_container # 2. wifi_container # 3. bluetooth_container (most recent) rfswift exec # Enters: bluetooth_container (most recent) rfswift exec -c sdr_container # Enters: sdr_container (explicit) Finding container names:\n# List recent containers rfswift last # Show all containers docker ps -a # Show only running containers docker ps Partial container ID matching:\n# Full ID rfswift exec -c a1b2c3d4e5f6g7h8 # Short form (first 12 chars) rfswift exec -c a1b2c3d4e5f6 # Minimal (first few unique chars) rfswift exec -c a1b2","container-states#Container States":"The exec command works with containers in different states:","container-wont-start#Container Won\u0026rsquo;t Start":"Error: Container fails to start when entering stopped container\nSolutions:\n# Check container status docker ps -a | grep container_name # Check logs docker logs container_name # Try manual start docker start container_name # If still fails, recreate rfswift remove -c container_name rfswift run -i image -n container_name","custom-shell-environment#Custom Shell Environment":"# Inside container, customize environment rfswift exec -c container # Set custom aliases echo 'alias ll=\"ls -la\"' \u003e\u003e ~/.zshrc echo 'alias scan=\"rtl_test -t\"' \u003e\u003e ~/.zshrc # Reload source ~/.zshrc","daily-assessment-workflow#Daily Assessment Workflow":"# Morning: Start fresh rfswift run -i pentest -n daily_work -b ~/work:/root/work # Throughout day: Enter as needed rfswift exec -c daily_work # Exit and return multiple times exit rfswift exec -c daily_work # End of day: Stop but keep for tomorrow rfswift stop -c daily_work # Next morning: Resume rfswift exec -c daily_work # Auto-starts and enters","default-shell#Default Shell":"RF Swift containers use zsh as the default shell with:\nOh My Zsh configuration Syntax highlighting Auto-completion Custom prompt showing container name Terminal prompt example:\n‚îå‚îÄ[root@container_name] - [/root/projects] - [Thu Jan 12, 14:30] ‚îî‚îÄ[$]\u003e","detailed-explanations#Detailed Explanations":"","development-workflow#Development Workflow":"# Setup development container rfswift run -i sdr_full -n sdr_dev \\ -b ~/code:/root/code \\ -b ~/.gitconfig:/root/.gitconfig:ro # Edit code on host with your IDE # Test in container rfswift exec -c sdr_dev -w /root/code cd my_project ./build.sh ./test.sh exit # Repeat edit-test cycle rfswift exec -c sdr_dev -w /root/code","enter-as-different-user#Enter as Different User":"RF Swift containers run as root by default. To change user:\n# Inside container rfswift exec -c container su - username # solution for now","examples#Examples":"","execute-single-command-non-interactive#Execute Single Command (Non-Interactive)":"While exec is primarily for interactive shells, you can execute single commands:\n# Note: This requires using docker directly docker exec -it container_name command # For RF Swift interactive access, use: rfswift exec -c container_name","multiple-containers-with-similar-names#Multiple Containers with Similar Names":"Problem: Partial name matches multiple containers\nSolutions:\n# Use full container name rfswift exec -c full_container_name # Or use container ID docker ps -a # Get full ID rfswift exec -c a1b2c3d4e5f6 # List recent to identify rfswift last","multiple-sessions#Multiple Sessions":"You can have multiple exec sessions in the same container:\n# Terminal 1 rfswift exec -c my_container # Terminal 2 (simultaneously) rfswift exec -c my_container # Both sessions work in the same container # Changes in one are visible in the other Use cases:\nMonitor logs in one terminal while working in another Run long-running process in one, interact in another Separate recording sessions for different tasks","non-existent-containers#Non-Existent Containers":"Error handling:\nrfswift exec -c nonexistent_container # Error: No such container: nonexistent_container # Solution: Create container first rfswift run -i image -n nonexistent_container","options#Options":"","permission-issues-inside-container#Permission Issues Inside Container":"Problem: Can‚Äôt access files or directories\nSolutions:\n# Check file permissions inside container rfswift exec -c container ls -la /path/to/file # Fix permissions inside container chmod 755 /path/to/file chown root:root /path/to/file # Or fix on host (for mounted volumes) exit chmod 755 ~/host-path/file rfswift exec -c container","real-world-workflows#Real-World Workflows":"Resume assessment work:\n# Yesterday's work rfswift run -i pentest -n client_assessment \\ -b ~/client-work:/root/work # Today - resume where you left off rfswift exec -c client_assessment -w /root/work Debug with recording:\nrfswift exec -c problematic_container \\ --record \\ --record-output troubleshooting-$(date +%Y%m%d-%H%M).cast Quick check on running container:\n# Check what's running rfswift last # Jump into most recent rfswift exec # Or specific one rfswift exec -c sdr_capture Multiple sessions in same container:\n# Terminal 1 rfswift exec -c sdr_analysis -w /root/captures # Terminal 2 (different session, same container) rfswift exec -c sdr_analysis -w /root/tools","recording-fails#Recording Fails":"Problem: --record flag doesn‚Äôt work\nSolutions:\n# Check if asciinema is installed on host which asciinema # Install if missing (Ubuntu/Debian) sudo apt-get install asciinema # Install on macOS brew install asciinema # Verify recording works asciinema rec test.cast # Press Ctrl+D asciinema play test.cast","recording-options#Recording Options":"Flag Description Example --record Enable session recording --record --record-output STRING Custom recording filename --record-output debug.cast","related-commands#Related Commands":"run - Create new containers stop - Stop running containers last - List recent containers remove - Delete containers log - Replay recorded sessions bindings - Add devices/volumes to running containers üí° Quick Tip: Create a shell alias for faster access: alias rfe='rfswift exec' then just type rfe to enter your most recent container! Recording Reminder: When recording sessions with --record, remember that your terminal title will show ‚Äúüî¥ RECORDING‚Äù as a visual reminder. Everything you type and see will be captured!","rfswift-exec#rfswift exec":"rfswift execExecute commands in a running or stopped container, typically used to enter containers with an interactive shell.","running-containers#Running Containers":"Most common use case:\n# Container is already running docker ps | grep my_container # Shows running container rfswift exec -c my_container # Enters immediately","session-recording#Session Recording":"Records the entire terminal session for documentation, debugging, or training.\nWhat gets recorded:\nAll terminal input (commands typed) All terminal output (command results) Timing information for accurate playback Tool outputs and error messages Auto-generated filenames: Format: rfswift-exec-{container}-{timestamp}.cast\nrfswift exec -c my_container --record # Creates: rfswift-exec-my_container-20240112-143022.cast Custom filenames:\n# Simple name --record-output session.cast # With date --record-output session-$(date +%Y%m%d).cast # Full path --record-output ~/recordings/client-assessment.cast # Organized structure --record-output ~/assessments/client-$(date +%Y%m%d)/session.cast Recording location:\nAuto-generated: Current working directory on host Custom: As specified in --record-output path During recording:\nNo visible indication inside container exit of the sessions ends recording Playback:\nrfswift log replay -i session.cast rfswift log replay -i session.cast -s 2.0 # 2x speed","shell-behavior#Shell Behavior":"","stopped-containers#Stopped Containers":"Container was previously stopped:\n# Container exists but is stopped docker ps -a | grep my_container # Shows exited container rfswift exec -c my_container # RF Swift automatically starts the container, then enters it What happens:\nRF Swift detects container is stopped Starts the container with docker start Waits for container to be ready Enters with interactive shell","synopsis#Synopsis":"rfswift exec [-c CONTAINER] [-w WORKDIR] [options] The exec command enters an existing container with an interactive shell. If no container is specified, it automatically uses the most recently created container.","terminal-display-issues#Terminal Display Issues":"Problem: Terminal formatting looks wrong\nSolutions:\n# Reset terminal rfswift exec -c container reset # Or clear screen clear # Set correct TERM export TERM=xterm-256color","training-workflow#Training Workflow":"# Instructor prepares example rfswift run -i sdr_full -n training_demo \\ -s /dev/bus/usb:/dev/bus/usb # Record demonstration rfswift exec -c training_demo \\ --record \\ --record-output training-lesson-01.cast # Demonstrate tools and techniques rtl_test -t gqrx exit # Students replay later rfswift log replay -i training-lesson-01.cast -s 1.5","troubleshooting#Troubleshooting":"","troubleshooting-workflow#Troubleshooting Workflow":"# Issue reported in container rfswift exec -c problematic_container --record # Investigate and record findings ps aux df -h netstat -tulpn exit # Share recording with team rfswift log replay -i rfswift-exec-problematic_container-*.cast","with-session-recording#With Session Recording":"Record with auto-generated filename:\nrfswift exec -c assessment --record Record with custom filename:\nrfswift exec -c pentest --record --record-output debug-session.cast Record in specific directory with working dir:\nrfswift exec -c analysis \\ -w /root/data \\ --record \\ --record-output ~/recordings/analysis-$(date +%Y%m%d-%H%M%S).cast","working-directory--w---workdir#Working Directory (\u003ccode\u003e-w, --workdir\u003c/code\u003e)":"Sets the initial directory when entering the container. Useful for:\nStarting in project directories Continuing work in specific locations Accessing mounted volumes directly Default behavior:\nIf not specified: /root (container default) Directory must exist in container Can be any valid path Common working directories:\n# User home -w /root # Project directory -w /root/projects # Captures directory -w /root/captures # Mounted volume -w /mnt/shared # Tool directory -w /opt/tools # Temporary work -w /tmp/analysis Non-existent directory:\n# This will fail if directory doesn't exist rfswift exec -c container -w /root/nonexistent # Solution: Create in container first or bind from host rfswift bindings add -c container -b /pathto/projects:/root/projects rfswift exec -c container -w /root/projects","working-directory-doesnt-exist#Working Directory Doesn\u0026rsquo;t Exist":"Error: cannot change directory to '/root/nonexistent'\nSolutions:\n# Use default directory rfswift exec -c container # Create directory in container rfswift exec -c container mkdir -p /root/nonexistent exit # Or bind from host rfswift bindings add -c container -b /pathto/host-dir:/root/nonexistent rfswift exec -c container -w /root/nonexistent","working-directory-examples#Working Directory Examples":"Start in projects directory:\nrfswift exec -c dev_container -w /root/projects Start in captures directory:\nrfswift exec -c sdr_work -w /root/captures Start in mounted volume:\nrfswift exec -c analysis -w /mnt/data"},"title":"exec"},"/docs/commands/export/":{"data":{"container-export#Container Export":"When exporting a container:\nContent Included? Notes Container filesystem ‚úÖ Yes All files and modifications Installed packages ‚úÖ Yes Everything in container Configuration files ‚úÖ Yes Modified configs Running processes ‚ùå No Only filesystem Mounted volumes ‚ùå No Volume data not included Container metadata ‚ö†Ô∏è Limited Basic info only Network config ‚ùå No Not preserved Port bindings ‚ùå No Not preserved Important: Export captures filesystem only, not Docker metadata like port bindings or network configuration.","containerimage-not-found#Container/Image Not Found":"Error: Error: No such container/image: name\nSolutions:\n# List containers rfswift last # List images rfswift images local","examples#Examples":"","export-container#Export Container":"Flag Description Required Example -c, --container STRING Container to export Yes -c my_container -o, --output STRING Output filename Yes -o backup.tar.gz","export-containers#Export Containers":"Basic container export:\nrfswift export container -c my_sdr_container -o sdr_backup.tar.gz Export with descriptive filename:\nrfswift export container -c client_assessment \\ -o client_assessment_$(date +%Y%m%d).tar.gz Export to specific directory:\nrfswift export container -c important_work \\ -o ~/backups/containers/important_work_backup.tar.gz Export before removal:\n# Create backup before deleting rfswift export container -c old_container -o archives/old_container_final.tar.gz rfswift remove -c old_container","export-image#Export Image":"Flag Description Required Example -i, --images STRINGS Image(s) to export (can specify multiple) Yes -i sdr_full -o, --output STRING Output filename Yes -o backup.tar.gz","export-images#Export Images":"Basic image export:\nrfswift export image -i sdr_full -o sdr_full_image.tar.gz Export custom image:\nrfswift export image -i my_custom_sdr:v1.0 -o custom_sdr_v1.tar.gz","file-size-considerations#File Size Considerations":"","image-export#Image Export":"When exporting an image:\nContent Included? Notes Image layers ‚úÖ Yes All filesystem layers Image metadata ‚úÖ Yes Tags, labels, etc. Build history ‚úÖ Yes Layer history Configuration ‚úÖ Yes Default settings","minimizing-export-size#Minimizing Export Size":"Before exporting, clean up:\nrfswift exec -c my_container # Remove package caches apt-get clean rm -rf /var/lib/apt/lists/* # Remove temporary files rm -rf /tmp/* rm -rf /root/.cache/* # Remove unnecessary logs truncate -s 0 /var/log/*.log # Remove development files if not needed apt-get remove -y build-essential apt-get autoremove -y exit # Now export will be smaller rfswift export container -c my_container -o clean_backup.tar.gz","options#Options":"","permission-denied#Permission Denied":"Error: Permission denied when writing output file\nSolutions:\n# Check output directory permissions ls -ld ~/backups/ # Create directory if needed mkdir -p ~/backups/containers # Set correct permissions chmod 755 ~/backups/containers # Or use sudo sudo rfswift export container -c container -o /backup/file.tar.gz","related-commands#Related Commands":"import - Import exported containers/images commit - Create images from containers download - Download images from registry remove - Remove containers after export üíæ Backup Strategy: Export creates compressed, portable backups. For production environments, schedule regular automated exports to multiple locations (local, NAS, offsite). Volume Data Not Included: Exports only include the container filesystem, not mounted volumes. Back up volume data separately using standard file backup tools. Compression: Export automatically compresses to tar.gz format, typically achieving 3:1 compression ratio. This saves significant storage space compared to uncompressed backups.","rfswift-export#rfswift export":"rfswift exportExport containers or images to compressed archive files for backup or transfer.","synopsis#Synopsis":"# Export container rfswift export container -c CONTAINER_NAME -o OUTPUT_FILE.tar.gz # Export image rfswift export image -i IMAGE_NAME -o OUTPUT_FILE.tar.gz The export command creates compressed tar.gz archives of containers or images, preserving all data, configuration, and metadata. This is the recommended method for creating portable backups.","troubleshooting#Troubleshooting":"","typical-export-sizes#Typical Export Sizes":"Container Type Uncompressed Compressed (tar.gz) Compression Ratio Minimal (base only) 500 MB 150-200 MB ~3:1 SDR with tools 2-3 GB 700 MB - 1 GB ~3:1 Full SDR stack 5-8 GB 1.5-2.5 GB ~3:1 With large data 20+ GB 5-10 GB ~2-3:1","what-gets-exported#What Gets Exported":""},"title":"export"},"/docs/commands/host/":{"data":{"basic-usage#Basic Usage":"Enable pulseaudio with default settings:\nrfswift host audio enable Enable with custom address:\nrfswift host audio enable -s tcp:192.168.1.100:34567 Unload pulseaudio module:\nrfswift host audio unload","environment-variable#Environment Variable":"Containers need PULSE_SERVER set:\n# Automatically set by rfswift run with -p flag PULSE_SERVER=tcp:127.0.0.1:34567 # Container applications use this to find pulse server","examples#Examples":"","host-audio-enable#host audio enable":"Enable pulseaudio network module for container audio access.\nOptions:\nFlag Description Default Example -s, --pulseserver STRING Pulse server address tcp:127.0.0.1:34567 -s tcp:127.0.0.1:34567","host-audio-unload#host audio unload":"Unload the TCP module from pulseaudio server.\nNo additional options.","how-audio-passthrough-works#How Audio Passthrough Works":"","localhost-vs-network-binding#Localhost vs Network Binding":"Localhost (Secure):\n# Only local containers can access rfswift host audio enable -s tcp:127.0.0.1:34567 Network Binding (Less Secure):\n# Any machine on network can access rfswift host audio enable -s tcp:0.0.0.0:34567 # Or specific interface rfswift host audio enable -s tcp:192.168.1.100:34567","module-not-loading#Module Not Loading":"Problem: rfswift host audio enable fails\nSolutions:\n# Check if pulseaudio is running ps aux | grep pulseaudio # Start pulseaudio if needed pulseaudio --start # Check for conflicts pactl list modules | grep tcp # Kill existing modules pactl unload-module module-native-protocol-tcp # Try again rfswift host audio enable","module-wont-unload#Module Won\u0026rsquo;t Unload":"Problem: unload command fails\nSolutions:\n# Force unload with pactl pactl unload-module module-native-protocol-tcp # Or restart pulseaudio pulseaudio --kill pulseaudio --start # Module will be gone after restart","no-audio-in-container#No Audio in Container":"Problem: Container has no audio output\nSolutions:\n# Verify module is loaded pactl list modules | grep module-native-protocol-tcp # Check PULSE_SERVER in container rfswift exec -c container echo $PULSE_SERVER exit # Should show: tcp:127.0.0.1:34567 # If not set, recreate container with -p flag rfswift run -i sdr_full -n work -p tcp:127.0.0.1:34567","permission-denied#Permission Denied":"Problem: Cannot load module\nSolutions:\n# Run as your user (not root) # Pulseaudio runs as user, not root # Check pulseaudio ownership ps aux | grep pulseaudio # If running as different user, restart pulseaudio --kill pulseaudio --start # Then load module rfswift host audio enable","port-already-in-use#Port Already in Use":"Problem: Port 34567 already in use\nSolutions:\n# Check what's using the port sudo lsof -i :34567 # Use different port rfswift host audio enable -s tcp:127.0.0.1:34568 # Update container creation rfswift run -i sdr_full -n work -p tcp:127.0.0.1:34568","pulseaudio-tcp-module#Pulseaudio TCP Module":"When you enable audio:\nLoad TCP module: Pulseaudio loads module-native-protocol-tcp Bind to port: Listens on specified address (default: 127.0.0.1:34567) Container access: Containers connect via PULSE_SERVER environment variable Audio streams: Audio from container apps plays on host graph LR A[Container App] --\u003e|PULSE_SERVER| B[TCP:34567] B --\u003e|Network| C[Host Pulseaudio] C --\u003e|Audio| D[Host Speakers]","real-world-scenarios#Real-World Scenarios":"Setup for SDR with audio:\n# Enable audio on host rfswift host audio enable # Create container with audio rfswift run -i penthertz/rfswift_noble:sdr_full -n sdr_audio \\ -p tcp:127.0.0.1:34567 # Audio now works in container rfswift exec -c sdr_audio gqrx # Audio output works! exit Remote audio access:\n# Enable on specific interface rfswift host audio enable -s tcp:192.168.1.100:34567 # Containers on network can access audio # Use with -p flag when creating container Troubleshooting audio:\n# Unload module rfswift host audio unload # Wait a moment sleep 2 # Re-enable rfswift host audio enable # Test audio in container rfswift exec -c sdr_work speaker-test -c 2 exit Clean shutdown:\n# Before stopping RF Swift work rfswift host audio unload # This cleanly removes the module","related-commands#Related Commands":"run - Create containers with audio (-p flag) exec - Test audio in containers stop - Stop containers before unloading üîä Audio for SDR: The host audio commands enable audio passthrough from containers to your host speakers. Essential for SDR applications like GQRX that need audio output! Run as User: Always run rfswift host audio enable as your regular user, NOT as root. Pulseaudio runs as your user and needs proper permissions. Container Flag Required: Don‚Äôt forget the -p tcp:127.0.0.1:34567 flag when creating containers. Without it, containers won‚Äôt know where to find the pulseaudio server!","rfswift-host#rfswift host":"rfswift hostConfigure host system for RF Swift container operations.","security-considerations#Security Considerations":"","subcommands#Subcommands":"","synopsis#Synopsis":"# Enable pulseaudio network access rfswift host audio enable [-s SERVER_ADDRESS] # Unload pulseaudio TCP module rfswift host audio unload The host command configures the host system to support RF Swift containers, primarily managing pulseaudio server settings for audio passthrough to containers.","troubleshooting#Troubleshooting":""},"title":"host"},"/docs/commands/images/":{"data":{"-version-management-v070#üÜï Version Management (v0.7.0+)":"Starting with RF Swift v0.7.0, images now support proper versioning to help you track and manage different image releases.","authentication-required#Authentication Required":"Problem: Private registry requires login\nSolutions:\n# Login to registry docker login registry.example.com # Then pull rfswift images pull -i registry.example.com/image:tag # For Docker Hub private images docker login rfswift images pull -i myuser/private-image:tag","images-local#images local":"List all RF Swift images present on the local system.\nUsage:\nrfswift images local Output includes:\nImage repository and tag Image ID Creation date Image size Version information (v0.7.0+)","images-pull#images pull":"Pull images from Docker registries to local system.\nUsage:\nrfswift images pull -i IMAGE_NAME [-t TAG] [-V version] Options:\nFlag Description Required Example -i, --image STRING Image reference to pull Yes -i penthertz/rfswift_noble:sdr_full -t, --tag STRING Rename to target tag locally No -t my_sdr:v1 -V, --version STRING Rename to wanted version No -V 0.1.1","images-remote#images remote":"List available RF Swift images from the official Penthertz registry.\nUsage:\nrfswift images remote [-v] Options:\nFlag Description Example -v, --versions Show available versions for each image -v Output includes:\nAvailable image names Image descriptions Available tags/versions Version history (with -v flag)","no-images-listed-locally#No Images Listed Locally":"Problem: images local shows no RF Swift images\nSolutions:\n# Pull your first image rfswift images pull -i sdr_full # Check all Docker images (not just RF Swift) docker images # Verify Docker is running docker ps","pull-fails#Pull Fails":"Error: Error pulling image\nSolutions:\n# Check image name spelling rfswift images remote -v # Verify exact name and version # Try with docker directly docker pull penthertz/rfswift:sdr_full # Check disk space df -h # Check network ping registry.hub.docker.com","pulling-specific-versions#Pulling Specific Versions":"# Pull latest version (default) rfswift images pull -i sdr_full # Pull specific version rfswift images pull -i sdr_full -V 0.1.1","related-commands#Related Commands":"build - Build custom images download - Download images to files export - Export images to archives import - Import images from archives delete - Remove images retag - Retag images locally run - Run containers from images upgrade - Upgrade container to new image version üè∑Ô∏è New in v0.7.0: Use rfswift images remote -v to see all available versions for each image. Pin your production environments to specific versions for stability! üñºÔ∏è Check Before Pull: Use images remote -v to see what‚Äôs available before pulling. This helps you choose the right image variant and version for your needs. Disk Space: RF Swift images can be large (1.5-4GB). Always check available disk space with df -h before pulling multiple images or versions. Use sdr_light for space-constrained systems. Version Pinning: For production environments, always pin to a specific version (e.g., sdr_full-v0.7.0) instead of using the latest tag. This ensures reproducibility and prevents unexpected changes!","remote-registry-not-accessible#Remote Registry Not Accessible":"Problem: images remote fails or shows no images\nSolutions:\n# Check network connectivity ping registry.hub.docker.com # Check Docker Hub status curl -I https://hub.docker.com # Try direct docker search docker search penthertz/rfswift_noble # Check if behind proxy/firewall","rfswift-images#rfswift images":"rfswift imagesManage Docker images - list local images, browse remote registry, pull images, and track versions.","subcommands#Subcommands":"","synopsis#Synopsis":"# List local images rfswift images local # List remote registry images rfswift images remote # List remote images with versions rfswift images remote -v # Pull image from registry rfswift images pull -i IMAGE_NAME [-t TAG] [-V version] The images command provides comprehensive image management: view locally available images, discover images in the RF Swift registry, pull images from Docker registries, and track image versions for better environment control.","troubleshooting#Troubleshooting":"","version-comparison#Version Comparison":"üì¶ RF Swift Images ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Repository ‚îÇ Tag ‚îÇ Image ID ‚îÇ Created ‚îÇ Size ‚îÇ Status ‚îÇ Version ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ penthertz/rfswift_noble ‚îÇ sdr_light_0.1.1 ‚îÇ cdf39442893e ‚îÇ 2026-01-19T20:17:49+01:00 ‚îÇ 13076.96 MB ‚îÇ Up to date ‚îÇ 0.1.1 ‚îÇ ...","version-not-found#Version Not Found":"Error: Version not found or Tag not found\nSolutions:\n# List all available versions rfswift images remote -v # Verify the version exists # Use the exact version string shown in the list # Pull with correct version format rfswift images pull -i wifi v0.1.0","viewing-available-versions#Viewing Available Versions":"# List remote images with all available versions rfswift images remote -v Example output:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Tag ‚îÇ Pushed Date ‚îÇ Image ‚îÇ Size ‚îÇ Versions ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ wifi ‚îÇ 2026-01-27 16:27 ‚îÇ penthertz/rfswift_noble:wifi ‚îÇ 7981.2 MB ‚îÇ latest, 0.1.1 ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ sdr_full ‚îÇ 2026-01-27 16:27 ‚îÇ penthertz/rfswift_noble:sdr_full ‚îÇ 14176.2 MB ‚îÇ latest, 0.1.1 ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§"},"title":"images"},"/docs/commands/import/":{"data":{"common-workflows#Common Workflows":"","container-import#Container Import":"When importing a container (from export container):\nContent Imported? Notes Container filesystem ‚úÖ Yes Complete filesystem state Installed packages ‚úÖ Yes All software Configuration files ‚úÖ Yes All configs Created files ‚úÖ Yes Data, scripts, logs Layer history ‚ùå No Flattened to single layer Container metadata ‚ö†Ô∏è Limited Basic info only Mounted volumes ‚ùå No Not included in export Running processes ‚ùå No Filesystem only","cross-platform-migration#Cross-Platform Migration":"# === From Development Laptop to Production Server === # On development laptop (macOS/Windows) rfswift export container -c sdr_dev -o sdr_dev_export.tar.gz # Transfer to production server (Linux) scp sdr_dev_export.tar.gz prod-server:/tmp/ # On production server rfswift import container -i /tmp/sdr_dev_export.tar.gz \\ -n sdr_production:v1.0 # Run with production configuration rfswift run -i sdr_production:v1.0 -n sdr_prod \\ -b /data/captures:/root/captures \\ -s /dev/device:/dev/device \\ -g \"c 189:* rwm\" \\ -t bridge","disaster-recovery-workflow#Disaster Recovery Workflow":"# === Scenario: Production system failed === # 1. Get backup from backup system scp backup-server:/backups/production_20250112.tar.gz /tmp/ # 2. Import container rfswift import container -i /tmp/production_20250112.tar.gz \\ -n production_restored:emergency # 3. Restore volumes from separate backup tar xzf /tmp/production_volumes_20250112.tar.gz -C ~/ # 4. Run restored container with volumes rfswift run -i production_restored:emergency -n production \\ -b ~/production-data:/root/data \\ -t bridge \\ -w 8080:80/tcp # 5. Verify service curl http://localhost:8080/health","examples#Examples":"","image-import#Image Import":"When importing an image (from export image or download):\nContent Imported? Notes Image layers ‚úÖ Yes Complete layer history Image metadata ‚úÖ Yes Tags, labels, config Build history ‚úÖ Yes Layer creation history Default configuration ‚úÖ Yes CMD, ENV, WORKDIR, etc. Important: Volume data is never included in exports/imports. Back up volumes separately.","image-name-already-exists#Image Name Already Exists":"Error: Error: image name already in use\nSolutions:\n# Option 1: Use different name rfswift import container -i backup.tar.gz -n restored_alternative:v1 # Option 2: Remove existing image first docker rmi existing_image:tag rfswift import container -i backup.tar.gz -n existing_image:tag # Option 3: Add version tag rfswift import container -i backup.tar.gz -n existing_image:v2","import-container#Import Container":"Flag Description Required Example -i, --input STRING Input tar.gz file path Yes -i backup.tar.gz -n, --name STRING Name for the imported image Yes -n myimage:tag","import-containers#Import Containers":"Basic container import:\nrfswift import container -i sdr_backup.tar.gz -n sdr_restored:v1 Import with descriptive tag:\nrfswift import container -i client_assessment_20250112.tar.gz \\ -n client_assessment_restored:2025_01_12 Import and immediately run:\n# Import rfswift import container -i backup.tar.gz -n my_container_restored # Run new container from imported image rfswift run -i my_container_restored -n my_container","import-image#Import Image":"Flag Description Required Example -i, --input STRING Input tar.gz file path Yes -i images.tar.gz","import-images#Import Images":"Basic image import:\nrfswift import image -i sdr_full_image.tar.gz Import multiple images:\n# This imports all images contained in the archive rfswift import image -i rfswift_images_bundle.tar.gz Import downloaded RF Swift image:\nrfswift import image -i rfswift-sdr-full-20250112.tar.gz","options#Options":"","permission-denied#Permission Denied":"Error: Permission denied reading archive\nSolutions:\n# Check file permissions ls -l backup.tar.gz # Read permission for user chmod 644 backup.tar.gz # Or use sudo sudo rfswift import container -i backup.tar.gz -n restored:v1 # Or add user to docker group sudo usermod -aG docker $USER newgrp docker","real-world-scenarios#Real-World Scenarios":"Disaster recovery:\n# On backup system, import critical containers rfswift import container -i /backup/dr/production_monitor_20250112.tar.gz \\ -n production_monitor_restored # Start restored container rfswift run -i production_monitor_restored -n production_monitor # Verify functionality rfswift exec -c production_monitor System migration:\n# On new system after receiving transfer rfswift import container -i sdr_work_transfer.tar.gz \\ -n sdr_work_migrated:v1 # Run with same name as original rfswift run -i sdr_work_migrated:v1 -n sdr_work \\ -b ~/captures:/root/captures # Resume work rfswift exec -c sdr_work Offline installation:\n# Import RF Swift images on air-gapped system rfswift import image -i rfswift-images-offline-bundle.tar.gz # List imported images rfswift images local # Run container rfswift run -i penthertz/rfswift_noble:sdr_full -n offline_work Team distribution:\n# Each team member imports training environment rfswift import image -i sdr_course_2024_q1.tar.gz # Run personal workspace rfswift run -i sdr_course_2024_q1 -n student_workspace Project restoration:\n# Import archived project rfswift import container -i archives/client_2024_01_container.tar.gz \\ -n client_project_archive:2024_01 # Run for review rfswift run -i client_project_archive:2024_01 -n project_review \\ -b ~/pathto/review:/root/work","related-commands#Related Commands":"export - Create archives to import download - Download images for offline import run - Run containers from imported images images - Manage imported images remove - Remove imported containers üíæ Import Strategy: Always verify archive integrity before importing with tar -tzf file.tar.gz. For production systems, test imports in a non-production environment first! Volume Data: Imported containers don‚Äôt include volume data from the original. Back up and restore volumes separately, then remount when running the restored container. Container vs Image Import: Use import container for container exports (creates new flattened image), use import image for image exports (preserves layers and tags). Choose based on your source archive type!","rfswift-import#rfswift import":"rfswift importImport containers or images from compressed archive files.","synopsis#Synopsis":"# Import container filesystem as image rfswift import container -i INPUT_FILE.tar.gz -n IMAGE_NAME # Import Docker image(s) rfswift import image -i INPUT_FILE.tar.gz The import command restores containers and images from tar.gz archives created by the export or download commands, enabling backup restoration and system migration.","troubleshooting#Troubleshooting":"","what-gets-imported#What Gets Imported":""},"title":"import"},"/docs/commands/install/":{"data":{"basic-usage#Basic Usage":"Install SDR++ software:\nrfswift install -c work -i sdrpp_soft_install Install GNU Radio modules:\nrfswift install -c sdr_work -i gnuradio_modules_install Install wireless tools:\nrfswift install -c wifi_analysis -i wireless_tools_install","examples#Examples":"","function-not-found#Function Not Found":"Problem: Installation function doesn‚Äôt exist\nSolutions:\n# Check available functions or in the documentation https://rfswift.io/docs/guide/list-of-tools/ # See RF Swift documentation or GitHub # Verify function name spelling rfswift install -c container -i sdrpp_soft_install # Correct rfswift install -c container -i sdrpp_install # Wrong # Update RF Swift for new functions rfswift update","installation-failed#Installation Failed":"Problem: Installation function fails\nSolutions:\n# Check container is running rfswift last | grep container_name # Check internet connectivity in container rfswift exec -c container -e \"ping -c 3 google.com\" # Check disk space rfswift exec -c container -e \"df -h\" # Try with more verbose output rfswift exec -c container # Run installation command manually to see errors exit # Update package lists first rfswift exec -c container -e \"apt-get update\" # Then retry install rfswift install -c container -i function_name","options#Options":"Flag Description Required Example -c, --container STRING Container ID or name ‚úÖ Yes -c my_container -i, --install STRING Function name to execute ‚úÖ Yes -i sdrpp_soft_install","real-world-scenarios#Real-World Scenarios":"Setup new SDR container:\n# Create container rfswift run -i penthertz/rfswift_noble:sdr_light -n sdr_custom # Install additional tools rfswift install -c sdr_custom -i sdrpp_soft_install rfswift install -c sdr_custom -i hackrf_tools_install rfswift install -c sdr_custom -i rtlsdr_tools_install # Container now has custom toolset rfswift exec -c sdr_custom Add missing tool:\n# Working in container, need additional tool rfswift exec -c analysis # Realize you need inspectrum exit # Install from host rfswift install -c analysis -i inspectrum_install # Tool now available rfswift exec -c analysis inspectrum Batch installation:\n# Install multiple tools TOOLS=( \"sdrpp_soft_install\" \"gqrx_install\" \"urh_install\" \"inspectrum_install\" ) for tool in \"${TOOLS[@]}\"; do echo \"Installing: $tool\" rfswift install -c sdr_full -i \"$tool\" done Custom toolchain setup:\n# Create specialized container rfswift run -i penthertz/rfswift_noble:base -n custom_rf # Install specific tools rfswift install -c custom_rf -i gnuradio_install rfswift install -c custom_rf -i hackrf_tools_install rfswift install -c custom_rf -i limesuite_install # Commit as custom image rfswift commit -c custom_rf -i my_custom_toolchain:v1","related-commands#Related Commands":"exec - Execute commands after installation commit - Save container after installations run - Create container for installations upgrade - Upgrade container with new tools üîß Automated Setup: The install command uses predefined functions that handle dependencies, compilation, and configuration automatically. No need to manually compile or configure! Internet Required: Installation functions download source code and packages from the internet. Ensure your container has network access during installation! Commit After Installing: After installing tools, commit your container with rfswift commit to preserve your work. Otherwise, changes are lost if the container is removed!","rfswift-install#rfswift install":"rfswift installInstall software and tools inside containers using predefined function scripts.","synopsis#Synopsis":"rfswift install -c CONTAINER -i FUNCTION_NAME The install command executes predefined installation functions inside containers to add software, tools, or configurations. These functions are part of RF Swift‚Äôs installation script library and handle dependencies, compilation, and setup automatically.","troubleshooting#Troubleshooting":""},"title":"install"},"/docs/commands/last/":{"data":{"basic-usage#Basic Usage":"List all containers:\nrfswift last Example output:\nCONTAINER ID NAME IMAGE STATUS CREATED PORTS a1b2c3d4e5f6 sdr_work penthertz/rfswift_noble:sdr_full Up 2 hours 3 hours ago 0.0.0.0:8080-\u003e80/tcp b2c3d4e5f6g7 bluetooth_1 penthertz/rfswift_noble:bluetooth Up 1 day 2 days ago c3d4e5f6g7h8 analysis penthertz/rfswift_noble:sdr_full Exited 1 week ago","clean-up-old-containers#Clean Up Old Containers":"# List containers rfswift last # Identify old unused ones rfswift last | grep \"Exited\" # Remove specific container rfswift remove -c old_container","examples#Examples":"","options#Options":"The last command takes no options and displays all containers.","quick-container-check#Quick Container Check":"# Check what containers exist rfswift last # Find specific container rfswift last | grep sdr_work # Count total containers rfswift last | tail -n +2 | wc -l","related-commands#Related Commands":"run - Create new containers remove - Remove containers stop - Stop running containers exec - Access containers cleanup - Automated cleanup üìã Quick Overview: rfswift last is your first stop for seeing what containers exist. It shows all containers (running and stopped) with their essential information at a glance. No Filtering Options: Unlike docker ps, the last command shows all containers without filtering options. Use grep, awk, or pipe to docker ps for advanced filtering. All Containers Shown: rfswift last shows both running AND stopped containers (equivalent to docker ps -a). Use grep \"Up\" to see only running ones, or grep \"Exited\" for stopped ones.","rfswift-last#rfswift last":"rfswift lastList all RF Swift containers with their status and information.","synopsis#Synopsis":"rfswift last The last command provides a quick overview of all RF Swift containers on the system, showing their names, status, images, creation time, and other details. This is your go-to command for checking what containers exist.","understanding-output#Understanding Output":"Output columns:\nCONTAINER ID: Short container ID NAME: Container name IMAGE: Docker image used STATUS: Running state (Up/Exited) CREATED: When container was created PORTS: Port bindings (if any) Status values:\nUp X minutes/hours/days: Container is running Exited (0): Container stopped normally Exited (137): Container was killed Created: Container created but never started Restarting: Container is restarting","use-cases#Use Cases":""},"title":"last"},"/docs/commands/log/":{"data":{"asciinema-format-cast#Asciinema Format (.cast)":"By default, RF Swift uses asciinema format, which records:\nTerminal output with timing information Exact keystroke timing Terminal dimensions Environment metadata Advantages:\nCompact file size Precise timing reproduction Web-embeddable Editable timing Example .cast file:\n{\"version\": 2, \"width\": 120, \"height\": 30, \"timestamp\": 1704981234} [0.123456, \"o\", \"$ rfswift run -i sdr_full -n demo\\r\\n\"] [1.234567, \"o\", \"Container started: demo\\r\\n\"]","basic-usage#Basic Usage":"Start recording:\nrfswift log start # Recording started: rfswift-session-20240112-143015.cast Start recording with custom filename:\nrfswift log start -o tutorial-wifi-analysis.cast Stop recording:\nrfswift log stop Replay a session:\nrfswift log replay -i tutorial-wifi-analysis.cast Replay at 2x speed:\nrfswift log replay -i tutorial-wifi-analysis.cast -s 2.0 List all recordings:\nrfswift log list List recordings in specific directory:\nrfswift log list --dir ~/rfswift-tutorials","distribute#Distribute":"","distribution#Distribution":"# Create distribution package mkdir -p rfswift-training-package cp ~/recordings/*.cast rfswift-training-package/ # Add README cat \u003e rfswift-training-package/README.md \u003c\u003c 'EOF' # RF Swift Training Materials ## Lessons 1. basics.cast - RF Swift basics 2. wifi-analysis.cast - WiFi analysis 3. sdr-setup.cast - SDR setup ## Playback ```bash rfswift log replay -i lesson-name.cast EOF","examples#Examples":"","interactive-playback#Interactive Playback":"If using asciinema format, you can use asciinema player for interactive control:\n# Install asciinema pip install asciinema # Play with controls asciinema play session.cast # Controls during playback: # Space - Pause/Resume # . - Step forward # Ctrl+C - Exit","log-list#log list":"List all recorded session files in a directory.\nOptions:\nFlag Description Default Example --dir STRING Directory to search Current directory --dir ~/recordings","log-replay#log replay":"Replay a previously recorded session.\nOptions:\nFlag Description Default Example -i, --input STRING Input file to replay Required -i session.cast -s, --speed FLOAT Playback speed multiplier 1.0 -s 2.0","log-start#log start":"Start recording a terminal session.\nOptions:\nFlag Description Default Example -o, --output STRING Output file path Auto-generated -o my-session.cast --use-script Force use of script command false --use-script","log-stop#log stop":"Stop the currently active recording session.\nNo options required.","package#Package":"tar czf rfswift-training.tar.gz rfswift-training-package/","playback-control#Playback Control":"","real-world-scenarios#Real-World Scenarios":"Create a tutorial:\n# Start recording rfswift log start -o sdr-tutorial-basics.cast # Perform tutorial steps rfswift run -i penthertz/rfswift_noble:sdr_full -n tutorial rfswift exec -c tutorial rtl_test -t # ... demonstrate features ... exit # Stop recording rfswift log stop # Replay to verify rfswift log replay -i sdr-tutorial-basics.cast Document a bug:\n# Record the problem rfswift log start -o bug-report-issue-123.cast # Reproduce the issue rfswift exec -c production # ... reproduce bug ... exit # Stop recording rfswift log stop # Share bug-report-issue-123.cast with team","recording-file-not-found#Recording File Not Found":"Problem: Cannot find recorded file\nSolutions:\n# Check current directory ls -la *.cast # List all recordings rfswift log list # Check in home directory rfswift log list --dir ~ # Find by date find ~ -name \"*.cast\" -mtime -1 # Last 24 hours","recording-format#Recording Format":"","recording-not-starting#Recording Not Starting":"Problem: rfswift log start fails\nSolutions:\n# Check if asciinema is installed which asciinema # Install asciinema pip install asciinema # or apt-get install asciinema # Ubuntu/Debian brew install asciinema # macOS # Use script command as fallback rfswift log start --use-script","related-commands#Related Commands":"exec - Execute commands that can be recorded run - Run containers to record last - Show containers for recording sessions üé¨ Perfect for Training: The log command is ideal for creating training materials. Record once, share with your entire team. Students can replay at their own pace with speed control! Sensitive Information: Recordings capture everything displayed in the terminal, including passwords and API keys if shown. Review recordings before sharing publicly! Asciinema vs Script: RF Swift prefers asciinema format (.cast) for its precise timing and web-embeddable features. The script command is available as a fallback with --use-script.","replay-not-working#Replay Not Working":"Problem: Cannot replay session\nSolutions:\n# Check file exists ls -l session.cast # Verify file is not corrupted file session.cast # Try with asciinema directly asciinema play session.cast # Use script format instead rfswift log start --use-script","rfswift-log#rfswift log":"rfswift logRecord and replay terminal sessions for documentation and training.","script-format-fallback#Script Format (Fallback)":"When asciinema is not available, RF Swift falls back to the script command:\nUse --use-script flag to force:\nrfswift log start --use-script -o session.txt","self-hosting#Self-Hosting":"# Copy recordings to web server scp *.cast webserver:/var/www/tutorials/ # Link in documentation # https://tutorials.example.com/wifi-setup.cast","share-rfswift-trainingtargz-with-team#Share rfswift-training.tar.gz with team":"","sharing-recordings#Sharing Recordings":"","speed-control#Speed Control":"# Normal speed (1.0x) rfswift log replay -i session.cast # Fast playback (2x) rfswift log replay -i session.cast -s 2.0 # Very fast (3x) rfswift log replay -i session.cast -s 3.0 # Slow playback (0.5x) rfswift log replay -i session.cast -s 0.5 # Very slow (0.25x) rfswift log replay -i session.cast -s 0.25","subcommands#Subcommands":"","synopsis#Synopsis":"# Start recording a session rfswift log start [-o OUTPUT_FILE] [--use-script] # Stop recording rfswift log stop # Replay a recorded session rfswift log replay -i INPUT_FILE [-s SPEED] # List recorded sessions rfswift log list [--dir DIRECTORY] The log command records RF Swift terminal sessions using asciinema (or the script command as fallback). This is perfect for creating tutorials, documenting workflows, or sharing demonstrations.","troubleshooting#Troubleshooting":"","web-embedding-asciinema#Web Embedding (Asciinema)":"# Upload to asciinema.org asciinema upload session.cast # Returns URL: https://asciinema.org/a/abc123 # Embed in documentation: #"},"title":"log"},"/docs/commands/ports/":{"data":{"basic-usage#Basic Usage":"Bind port:\nrfswift ports bind -c web_server -b \"8080:80/tcp\" Unbind port:\nrfswift ports unbind -c web_server -b \"8080:80/tcp\" List ports:\nrfswift ports list -c web_server","binding-examples#Binding Examples":"Basic TCP port:\n\"8080:80/tcp\" # Host port 8080 ‚Üí Container port 80 (TCP) UDP port:\n\"5000:5000/udp\" # Host port 5000 ‚Üí Container port 5000 (UDP) Same port both sides:\n\"3000:3000/tcp\" # Port 3000 on both sides Specific host IP:\n\"127.0.0.1:8080:80/tcp\" # Only accessible from localhost Multiple port mappings:\n\"8080:80/tcp\" # HTTP \"8443:443/tcp\" # HTTPS \"3000:3000/udp\" # Custom UDP service","binding-syntax#Binding Syntax":"Port bindings follow this format:\n[host_ip:]host_port:container_port/protocol Components:\nhost_ip: Host IP to bind to (optional, defaults to 0.0.0.0) host_port: Port on host system container_port: Port inside container protocol: tcp or udp","binding-to-specific-ips#Binding to Specific IPs":"Public access (default):\n# Accessible from anywhere rfswift ports bind -c service -b \"8080:80/tcp\" # Binds to 0.0.0.0:8080 Localhost only:\n# Only accessible from host rfswift ports bind -c service -b \"127.0.0.1:8080:80/tcp\" # Binds to 127.0.0.1:8080 Specific network interface:\n# Only accessible from specific IP rfswift ports bind -c service -b \"192.168.1.100:8080:80/tcp\"","cannot-bind-to-port#Cannot Bind to Port":"Problem: Binding fails without clear error\nSolutions:\n# Check if container is running docker ps | grep container_name # Check permissions for low ports (\u003c1024) # Use higher port instead rfswift ports bind -c service -b \"8080:80/tcp\" # Check firewall rules sudo iptables -L -n | grep 8080 # Check if port is blocked sudo ufw status","common-port-numbers#Common Port Numbers":"","development-ports#Development Ports":"Service Port Use Case React Dev 3000 React development server Node.js 3000, 8000 Node applications Python HTTP 8000 Python SimpleHTTPServer Flask 5000 Flask development Django 8000 Django development LiveReload 35729 Live reload/hot reload Webpack 8080 Webpack dev server Vite 5173 Vite dev server","examples#Examples":"","port-already-in-use#Port Already in Use":"Error: port is already allocated\nSolutions:\n# Check what's using the port netstat -tuln | grep :8080 lsof -i :8080 # Use different host port rfswift ports bind -c service -b \"8081:80/tcp\" # Or stop conflicting service sudo systemctl stop service-using-8080 # Then bind rfswift ports bind -c service -b \"8080:80/tcp\"","port-binding-format#Port Binding Format":"","port-range-restrictions#Port Range Restrictions":"Safe port ranges:\n# User ports (1024-49151) - Safe for non-root users rfswift ports bind -c service -b \"8080:80/tcp\" # Dynamic/private ports (49152-65535) - Good for temporary services rfswift ports bind -c service -b \"50000:80/tcp\" Avoid privileged ports:\n# Privileged ports (\u003c1024) require special capabilities # Use higher ports and reverse proxy if needed rfswift ports bind -c service -b \"8080:80/tcp\" # Good # Not: rfswift ports bind -c service -b \"80:80/tcp\" # Requires privileges","port-unbind-fails#Port Unbind Fails":"Problem: Cannot remove port binding\nSolutions:\n# Check exact binding rfswift ports list -c container # Use exact binding string rfswift ports unbind -c container -b \"8080:80/tcp\" # If still fails, may need container restart # (as last resort)","ports-bind#ports bind":"Add a port binding to a container.\nOptions:\nFlag Description Required Example -c, --container STRING Container ID or name Yes -c my_container -b, --binding STRING Port binding specification Yes -b \"8080:80/tcp\"","ports-list#ports list":"List all port bindings for a container.\nOptions:\nFlag Description Required Example -c, --container STRING Container ID or name Yes -c my_container","ports-unbind#ports unbind":"Remove a port binding from a container.\nOptions:\nFlag Description Required Example -c, --container STRING Container ID or name Yes -c my_container -b, --binding STRING Port binding specification Yes -b \"8080:80/tcp\"","real-world-scenarios#Real-World Scenarios":"Web server on custom port:\n# Start container rfswift run -i penthertz/rfswift_noble:sdr_full -n web_service # Add web server port rfswift ports bind -c web_service -b \"8080:80/tcp\" # Start web server rfswift exec -c web_service python3 -m http.server 80 exit # Access from host: http://localhost:8080 Multiple service ports:\n# API server container rfswift run -i penthertz/rfswift_noble:sdr_full -n api_server # Bind HTTP and HTTPS rfswift ports bind -c api_server -b \"8080:80/tcp\" rfswift ports bind -c api_server -b \"8443:443/tcp\" # Add metrics port rfswift ports bind -c api_server -b \"9090:9090/tcp\" # List all bindings rfswift ports list -c api_server UDP service:\n# Network analysis container rfswift run -i penthertz/rfswift_noble:sdr_full -n netflow # Add UDP port for netflow rfswift ports bind -c netflow -b \"2055:2055/udp\" # Start netflow collector rfswift exec -c netflow nfcapd -p 2055 exit Development server:\n# Development container rfswift run -i penthertz/rfswift_noble:sdr_full -n dev_env # Add development ports rfswift ports bind -c dev_env -b \"3000:3000/tcp\" # React dev server rfswift ports bind -c dev_env -b \"5000:5000/tcp\" # API backend rfswift ports bind -c dev_env -b \"35729:35729/tcp\" # LiveReload Temporary port for testing:\n# Test container rfswift run -i penthertz/rfswift_noble:sdr_full -n test_service # Bind port temporarily rfswift ports bind -c test_service -b \"9999:80/tcp\" # Run tests curl http://localhost:9999 # Remove when done rfswift ports unbind -c test_service -b \"9999:80/tcp\" Change port mapping:\n# Service running on port 8080 rfswift ports list -c service # Switch to port 8081 rfswift ports unbind -c service -b \"8080:80/tcp\" rfswift ports bind -c service -b \"8081:80/tcp\" # Now accessible on port 8081","related-commands#Related Commands":"run - Create containers with initial port bindings exec - Access container to test services bindings - Manage volume/device bindings last - List containers with port information üîå Dynamic Port Mapping: The ports command enables adding and removing port bindings without restarting containers. Perfect for development when you need to expose services on the fly! Privileged Ports: Ports below 1024 require special privileges. Use ports 1024+ (like 8080 instead of 80) to avoid permission issues. Set up a reverse proxy if you need standard ports. Protocol Matters: Always specify the protocol (/tcp, /sctp or /udp) in your binding. Some services need both protocols on the same port - bind each separately!","rf-swift-common-ports#RF Swift Common Ports":"Service Port Use Case Web UI 8080 Web interfaces API 8000 REST APIs WebSocket 9000 Real-time data Metrics 9090 Prometheus metrics Status 8081 Health checks","rfswift-ports#rfswift ports":"rfswift portsDynamically manage port bindings on running containers.","security-considerations#Security Considerations":"","service-not-accessible#Service Not Accessible":"Problem: Port bound but service not accessible\nSolutions:\n# Check binding was successful in the summary \u0026 test from inside container first rfswift exec -c container curl localhost:80 exit # If works inside, check from host curl localhost:8080 # Check container network mode docker inspect container | grep -A5 NetworkMode # Verify firewall sudo iptables -L -n sudo ufw status","standard-ports#Standard Ports":"Service Port Protocol Use Case HTTP 80 TCP Web servers HTTPS 443 TCP Secure web servers SSH 22 TCP Remote access FTP 21 TCP File transfer SMTP 25 TCP Email DNS 53 TCP/UDP Domain name service MySQL 3306 TCP Database PostgreSQL 5432 TCP Database Redis 6379 TCP Cache/database MongoDB 27017 TCP Database","subcommands#Subcommands":"","synopsis#Synopsis":"# Bind port rfswift ports bind -c CONTAINER -b \"HOST_PORT:CONTAINER_PORT/PROTOCOL\" # Unbind port rfswift ports unbind -c CONTAINER -b \"HOST_PORT:CONTAINER_PORT/PROTOCOL\" # List port bindings rfswift ports list -c CONTAINER The ports command allows you to add, remove, or list port bindings for running containers without restarting them. This enables dynamic port mapping for network services.","troubleshooting#Troubleshooting":"","wrong-protocol#Wrong Protocol":"Problem: Service works with TCP but not UDP (or vice versa)\nSolutions:\n# Check protocol in binding rfswift ports list -c container # Bind correct protocol rfswift ports bind -c service -b \"5000:5000/udp\" # Some services need both rfswift ports bind -c service -b \"53:53/tcp\" rfswift ports bind -c service -b \"53:53/udp\""},"title":"ports"},"/docs/commands/remove/":{"data":{"1-verify-before-removing#1. Verify Before Removing":"# Double-check container name docker ps -a | grep container_name # Verify it's the right one docker inspect container_name | grep -E \"Name|Image|Created\" # Then remove rfswift remove -c container_name","2-commit-important-containers-before-removing#2. Commit Important Containers Before Removing":"# Save state as image rfswift commit -c important_container -i important_backup # Then safe to remove rfswift remove -c important_container # Can recreate later rfswift run -i important_backup -n restored_container","3-check-for-data-outside-mounted-volumes#3. Check for Data Outside Mounted Volumes":"# Before removing, check for important files rfswift exec -c my_container find /root -type f -size +10M # Find large files ls -la /root/ # Check for important data exit # Copy important files to host first docker cp my_container:/root/important_file.dat ~/backup/ # Then safe to remove rfswift remove -c my_container","4-document-container-configuration#4. Document Container Configuration":"# Save configuration before removing docker inspect my_container \u003e my_container_config.json # Save as script for recreation cat \u003e recreate_container.sh \u003c\u003c 'EOF' rfswift run -i sdr_full -n my_container \\ -s /dev/bus/usb:/dev/bus/usb \\ -b /pathto/captures:/root/captures \\ -g \"c 189:* rwm\" EOF # Now safe to remove rfswift remove -c my_container","5-use-batch-removal-carefully#5. Use Batch Removal Carefully":"# Bad: Remove all at once without checking docker rm $(docker ps -aq) # Dangerous! # Good: List first, then decide docker ps -a # Review the list docker rm container1 container2 container3 # Explicit list","6-regular-cleanup-schedule#6. Regular Cleanup Schedule":"# Weekly cleanup script #!/bin/bash # cleanup_old_containers.sh # Remove containers older than 30 days docker container prune -f --filter \"until=720h\" # Remove unused images docker image prune -f --filter \"until=720h\" echo \"Cleanup complete. Disk space recovered:\" docker system df Add to crontab:\n# Run every Sunday at 2 AM 0 2 * * 0 /path/to/cleanup_old_containers.sh","accidental-removal#Accidental Removal":"Problem: Removed wrong container\nRecovery options:\nIf you have backups:\n# From committed image rfswift run -i backup_image -n restored_container # From exported tar rfswift import -i backup.tar.gz If no backups:\n‚ùå Container cannot be recovered ‚ùå Data inside container is lost ‚úÖ Mounted volumes still exist ‚úÖ Can recreate container from original image Prevention:\n# Always verify before removing docker ps -a | grep container_name # Read the output carefully before confirming # Use tab completion to avoid typos rfswift remove -c my_cont","advanced-usage#Advanced Usage":"","basic-usage#Basic Usage":"Remove a stopped container:\nrfswift remove -c my_old_container Remove by container ID:\nrfswift remove -c a1b2c3d4e5f6 Remove with short container ID:\nrfswift remove -c a1b2c3","before-removing-checklist#Before Removing: Checklist":"# 1. Verify container name docker ps -a | grep container_name # 2. Check for important data rfswift exec -c container_name ls -la /root/ # Look for files NOT in mounted volumes exit # 3. Back up if needed rfswift commit -c container_name -i backup_image # 4. Export if needed for transfer rfswift export -c container_name -o container_backup.tar.gz # 5. Remove rfswift remove -c container_name","best-practices#Best Practices":"","bulk-removal-with-pattern#Bulk Removal with Pattern":"# Remove all containers matching pattern docker ps -a --format '{{.Names}}' | grep \"^test_\" | while read container; do echo \"Removing $container...\" rfswift remove -c \"$container\" done # Or using docker directly docker rm $(docker ps -aq --filter \"name=test_*\")","common-workflows#Common Workflows":"","conditional-removal#Conditional Removal":"# Remove only if container exists if docker ps -a --format '{{.Names}}' | grep -q \"^container_name$\"; then rfswift remove -c container_name echo \"Container removed\" else echo \"Container not found\" fi","configuration-loss#Configuration Loss":"Removed containers lose:\nPort bindings and network configuration Device bindings and cgroups Capabilities and security settings Environment variables Startup commands To preserve configuration:\n# Option 1: Commit to image before removing rfswift commit -c my_container -i my_container_backup rfswift remove -c my_container # Option 2: Document configuration docker inspect my_container \u003e container_config.json rfswift remove -c my_container # Recreate later from documentation","container-has-dependent-containers#Container Has Dependent Containers":"Error: Error: cannot remove container: container has dependent containers\nSolutions:\n# Find dependent containers docker ps -a --filter \"ancestor=container_name\" # Remove dependent containers first docker rm dependent_container # Then remove parent rfswift remove -c parent_container # Or force remove entire chain docker rm -f $(docker ps -aq --filter \"ancestor=container_name\")","container-not-found#Container Not Found":"Error: Error: No such container: container_name\nSolutions:\n# List all containers rfswift last docker ps -a # Check for typos docker ps -a | grep partial_name # Container may already be removed # No action needed if that's the case","container-still-running#Container Still Running":"Warning: Container is running, stopping first...\nThis is normal: RF Swift automatically stops running containers before removal.\nTo avoid the warning:\n# Stop first rfswift stop -c my_container rfswift remove -c my_container","data-loss#Data Loss":"When you remove a container:\nData Location Preserved? Example Container filesystem ‚ùå DELETED /root/captures/data.bin (inside container) Mounted volumes ‚úÖ PRESERVED ~/captures:/root/captures (host directory) Container configuration ‚ùå DELETED Network settings, capabilities, cgroups Container metadata ‚ùå DELETED Creation date, history, logs Docker images ‚úÖ PRESERVED Source images remain available Important distinction:\n# Create container with volume rfswift run -i sdr_full -n my_container \\ -b /pathto/captures:/root/captures # Inside container: # /root/captures - SAFE (mounted from host) # /root/temp_work - AT RISK (inside container) # After remove: rfswift remove -c my_container # ~/captures on host: Still exists ‚úÖ # /root/temp_work: Gone forever ‚ùå","disk-space-management#Disk Space Management":"","disk-space-not-freed#Disk Space Not Freed":"Problem: Removed container but disk space unchanged\nExplanation: Container removed, but:\nImage still exists (most disk space) Volumes still exist Build cache remains Solutions:\n# Remove unused images docker image prune -a # Remove unused volumes docker volume prune # Complete cleanup docker system prune -a --volumes # Warning: This removes ALL unused Docker data! # Or targeted removal docker rmi image_name docker volume rm volume_name","examples#Examples":"","freeing-disk-space#Freeing Disk Space":"Conservative approach (remove only stopped containers):\n# Remove specific stopped containers rfswift remove -c old_container_1 rfswift remove -c old_container_2 # Remove all stopped containers docker cleanup [other options] # check that command before ;) Moderate approach (remove old data):\n# Remove containers unused for 7 days docker container prune --filter \"until=168h\" # Remove images unused for 7 days docker image prune -a --filter \"until=168h\" Aggressive approach (full cleanup):\n# WARNING: This removes ALL unused Docker data! docker system prune -a --volumes # This removes: # - Stopped containers # - Unused images # - Unused networks # - Unused volumes # - Build cache Space recovery comparison:\n# Before cleanup docker system df # Containers: 5GB (3GB reclaimable) # Remove 3 old containers rfswift remove -c old1 rfswift remove -c old2 rfswift remove -c old3 # After cleanup docker system df # Containers: 2GB (0GB reclaimable) # Freed: 3GB","options#Options":"Flag Description Required Example -c, --container STRING Container name or ID to remove Yes -c my_container","permission-denied#Permission Denied":"Error: Permission denied or Cannot connect to Docker daemon\nSolutions:\n# Use sudo on Linux sudo rfswift remove -c my_container # Or add user to docker group sudo usermod -aG docker $USER newgrp docker # Then try again rfswift remove -c my_container","project-lifecycle#Project Lifecycle":"# Week 1: Create project container rfswift run -i pentest -n project_alpha \\ -b ~/projects/alpha:/root/work # Weeks 1-4: Use for project rfswift exec -c project_alpha # Project complete: Back up and remove rfswift commit -c project_alpha -i project_alpha_final rfswift remove -c project_alpha # Optional: Export final state docker save project_alpha_final | gzip \u003e project_alpha_archive.tar.gz","real-world-scenarios#Real-World Scenarios":"Clean up completed project:\n# Project complete, remove container rfswift remove -c client_assessment_2024_01 Free disk space:\n# Remove old test containers rfswift remove -c test_container_1 rfswift remove -c test_container_2 rfswift remove -c experiment_old Remove failed containers:\n# Clean up containers that didn't work rfswift remove -c broken_config rfswift remove -c failed_setup Weekly cleanup:\n# Remove all containers older than 7 days # (See cleanup command for automated version) rfswift remove -c week_old_container Before recreating container:\n# Need to recreate with different config rfswift remove -c sdr_container rfswift run -i sdr_full -n sdr_container -s /dev/bus/usb:/dev/bus/usb","related-commands#Related Commands":"run - Create new containers stop - Stop containers before removing commit - Save container state before removing export - Export container before removing cleanup - Automated container cleanup last - List containers to identify removal candidates ‚ö†Ô∏è Cannot Be Undone: Container removal is permanent. All data inside the container filesystem is lost forever. Only mounted volumes are preserved. Always verify you‚Äôre removing the correct container! üí° Before Removing Important Containers: Always commit to an image first: rfswift commit -c container -i backup then rfswift remove -c container. This gives you a safety net! Disk Space Tip: Removing containers frees some space, but most disk usage is from images. Use docker image prune to free significant disk space after removing containers.","remove-and-archive#Remove and Archive":"#!/bin/bash # archive_and_remove.sh CONTAINER=$1 ARCHIVE_DIR=~/container_archives # Create archive directory mkdir -p \"$ARCHIVE_DIR\" # Export container echo \"Archiving $CONTAINER...\" rfswift export -c \"$CONTAINER\" -o \"$ARCHIVE_DIR/${CONTAINER}_$(date +%Y%m%d).tar.gz\" # Verify export if [ -f \"$ARCHIVE_DIR/${CONTAINER}_$(date +%Y%m%d).tar.gz\" ]; then echo \"Archive created successfully\" # Remove container rfswift remove -c \"$CONTAINER\" echo \"Container removed. Archive saved to $ARCHIVE_DIR\" else echo \"Error: Archive creation failed. Container NOT removed.\" exit 1 fi","remove-with-verification#Remove with Verification":"#!/bin/bash # safe_remove.sh CONTAINER=$1 # Verify container exists if ! docker ps -a --format '{{.Names}}' | grep -q \"^${CONTAINER}$\"; then echo \"Error: Container '$CONTAINER' not found\" exit 1 fi # Show container info echo \"Container details:\" docker inspect \"$CONTAINER\" --format='Name: {{.Name}} Image: {{.Config.Image}} Created: {{.Created}} Status: {{.State.Status}}' # Confirm removal read -p \"Remove this container? (yes/no): \" confirm if [ \"$confirm\" = \"yes\" ]; then rfswift remove -c \"$CONTAINER\" echo \"Container removed\" else echo \"Removal cancelled\" fi","rfswift-remove#rfswift remove":"rfswift removePermanently delete a container and free associated disk space.","safe-removal-practices#Safe Removal Practices":"","synopsis#Synopsis":"rfswift remove -c CONTAINER_NAME The remove command permanently deletes a container from your system. This operation cannot be undone - all data stored within the container‚Äôs filesystem will be lost.\nDestructive Operation: This command permanently deletes the container. Data in mounted volumes is preserved, but any data stored inside the container filesystem is lost forever.","testing-and-development#Testing and Development":"# Create test container rfswift run -i sdr_full -n test_new_config # Test configuration rfswift exec -c test_new_config # ... test ... exit # If test fails, remove and try again rfswift remove -c test_new_config rfswift run -i sdr_full -n test_new_config # Try different config # If test succeeds, remove test container rfswift remove -c test_new_config # Create production container with working config rfswift run -i sdr_full -n production # Use tested config","troubleshooting#Troubleshooting":"","understanding-disk-usage#Understanding Disk Usage":"# Check Docker disk usage docker system df # Output shows: # TYPE TOTAL ACTIVE SIZE RECLAIMABLE # Images 10 5 5.2GB 2.1GB (40%) # Containers 8 2 1.5GB 1.2GB (80%) # Local Volumes 3 1 500MB 300MB (60%) # Build Cache 15 0 2.1GB 2.1GB (100%)","what-gets-deleted#What Gets Deleted":""},"title":"remove"},"/docs/commands/rename/":{"data":{"basic-usage#Basic Usage":"Simple rename:\nrfswift rename -n old_container -d new_container Fix a typo:\nrfswift rename -n sdr_containr -d sdr_container More descriptive name:\nrfswift rename -n test -d sdr_spectrum_analysis_2024_01","container-state-during-rename#Container State During Rename":"The rename operation works on both:\nRunning containers: Continue running without interruption Stopped containers: Remain stopped after rename No downtime:\n# Container is running docker ps | grep web_server # Rename while running rfswift rename -n web_server -d api_backend # Still running with new name docker ps | grep api_backend # Processes inside container are unaffected","examples#Examples":"","invalid-container-name#Invalid Container Name":"Error: Invalid container name\nCommon causes:\nSpaces in name Special characters (!@#$%^\u0026*) Starting with hyphen Uppercase and symbols mixed Solutions:\n# Remove spaces rfswift rename -n old -d my_new_container # Not \"my new container\" # Remove special characters rfswift rename -n old -d my_container # Not \"my-container!\" # Don't start with hyphen rfswift rename -n old -d my_container # Not \"-my-container\" # Use lowercase and underscores rfswift rename -n old -d my_sdr_container_2024","new-name-already-exists#New Name Already Exists":"Error: Error: Conflict. The container name \"...\" is already in use\nSolutions:\n# Check existing containers docker ps -a | grep new_name # Option 1: Choose different name rfswift rename -n old_name -d alternative_name # Option 2: Remove/rename conflicting container first rfswift rename -n new_name -d new_name_backup rfswift rename -n old_name -d new_name # Option 3: Remove conflicting container rfswift remove -c new_name rfswift rename -n old_name -d new_name","options#Options":"Flag Description Required Example -n, --name STRING Current container name Yes -n old_container -d, --destination STRING New container name Yes -d new_container","permission-denied#Permission Denied":"Error: Permission denied or Cannot connect to Docker daemon\nSolutions:\n# Use sudo on Linux sudo rfswift rename -n old_name -d new_name # Or add user to docker group sudo usermod -aG docker $USER newgrp docker # Then try again rfswift rename -n old_name -d new_name","real-world-scenarios#Real-World Scenarios":"Add date to container name:\nrfswift rename -n client_assessment -d client_assessment_2024_01_12 Organize by project:\nrfswift rename -n wifi_tools -d project_alpha_wifi_scanner Change naming convention:\n# Old convention: type_number rfswift rename -n sdr_1 -d rtlsdr_spectrum_analyzer # New convention: purpose_date rfswift rename -n test_container -d frequency_scan_2024_jan Clarify purpose:\nrfswift rename -n container1 -d bluetooth_le_scanner_building_a Stage-based naming:\n# Development to production rfswift rename -n api_server_dev -d api_server_prod # Testing to staging rfswift rename -n web_test -d web_staging","related-commands#Related Commands":"run - Create containers with proper names from the start last - View container names exec - Access containers by name remove - Remove containers commit - Save container state üí° Naming Tip: Use a consistent naming convention from the start. Format like {purpose}_{project}_{date} makes containers easy to identify and organize: sdr_analysis_alpha_2024_01 No Downtime: Renaming a running container doesn‚Äôt interrupt it. Processes continue running, and all configuration remains intact. Only the name changes! Update Dependencies: If scripts, monitoring systems, or other containers reference the old name, update them before or immediately after renaming to avoid broken integrations.","rfswift-rename#rfswift rename":"rfswift renameChange a container‚Äôs name to a new identifier.","source-container-not-found#Source Container Not Found":"Error: Error: No such container: old_name\nSolutions:\n# List all containers rfswift last","synopsis#Synopsis":"rfswift rename -n OLD_NAME -d NEW_NAME The rename command changes a container‚Äôs name without affecting its data, configuration, or state. This is useful for organizing containers, fixing naming mistakes, or adapting to new naming conventions.","troubleshooting#Troubleshooting":"","what-changes#What Changes":"When you rename a container:\n‚úÖ Container name changes ‚úÖ Container appears with new name in rfswift last and docker ps ‚úÖ Docker internal references update","what-happens-during-rename#What Happens During Rename":"","what-stays-the-same#What Stays the Same":"Everything else remains unchanged:\n‚úÖ Container ID (unchanged) ‚úÖ All data inside container ‚úÖ Mounted volumes and bindings ‚úÖ Network configuration ‚úÖ Port mappings ‚úÖ Capabilities and cgroups ‚úÖ Container state (running/stopped) ‚úÖ Running processes (if container is running) ‚úÖ Creation date and history Example:\n# Before rename docker ps # CONTAINER ID NAME IMAGE CREATED # a1b2c3d4e5f6 old_name rfswift:sdr 2 hours ago rfswift rename -n old_name -d new_name # After rename docker ps # CONTAINER ID NAME IMAGE CREATED # a1b2c3d4e5f6 new_name rfswift:sdr 2 hours ago # Same ID, new name, same creation time"},"title":"rename"},"/docs/commands/retag/":{"data":{"basic-usage#Basic Usage":"Create new tag for existing image:\nrfswift retag -i penthertz/rfswift_noble:sdr_full -t my_sdr:v1 Create alias for convenience:\nrfswift retag -i penthertz/rfswift_noble:sdr_full -t sdr:latest Mark as production:\nrfswift retag -i my_custom_image:test -t my_custom_image:production Version tagging:\nrfswift retag -i my_image:latest -t my_image:v1.0.0","cannot-retag-while-container-running#Cannot Retag While Container Running":"Problem: Want to retag image being used by container\nSolution:\n# This is actually OK - containers are unaffected # Tags can be changed while containers are running # Container continues using the image it was started with # New tag just provides another reference to same image rfswift retag -i penthertz/rfswift_noble:sdr_full -t my_sdr:v1 # Running containers using penthertz/rfswift_noble:sdr_full are unaffected","examples#Examples":"","how-retag-works#How Retag Works":"","invalid-tag-format#Invalid Tag Format":"Error: invalid reference format\nSolutions:\n# Check tag format (no spaces, special chars) # Good rfswift retag -i image:old -t image:new # Bad rfswift retag -i image:old -t \"image with spaces:new\" rfswift retag -i image:old -t \"image:new tag\" # Use underscores or hyphens rfswift retag -i image:old -t image_new:v1 rfswift retag -i image:old -t image-new:v1","key-differences#Key Differences":"Feature retag rename Target Images Containers Operation Creates new tag Changes container name Original Remains unchanged Changed Multiple names Yes (many tags) No (one name) Disk usage None None","options#Options":"Flag Description Required Example -i, --image STRING Source image reference Yes -i penthertz/rfswift_noble:sdr_full -t, --tag STRING New tag name Yes -t my_sdr:production","permission-denied#Permission Denied":"Error: Permission denied\nSolutions:\n# Use sudo sudo rfswift retag -i source:tag -t new:tag # Or add user to docker group sudo usermod -aG docker $USER newgrp docker # Then retry rfswift retag -i source:tag -t new:tag","real-world-scenarios#Real-World Scenarios":"Environment-based tagging:\n# Pull image rfswift images pull -i penthertz/rfswift_noble:sdr_full # Create environment-specific tags rfswift retag -i penthertz/rfswift_noble:sdr_full -t sdr_work:development rfswift retag -i penthertz/rfswift_noble:sdr_full -t sdr_work:staging rfswift retag -i penthertz/rfswift_noble:sdr_full -t sdr_work:production Version management:\n# Tag current version rfswift retag -i my_custom_sdr:latest -t my_custom_sdr:v1.2.0 # Keep latest tag updated rfswift retag -i my_custom_sdr:v1.2.0 -t my_custom_sdr:latest # Create stable release tag rfswift retag -i my_custom_sdr:v1.2.0 -t my_custom_sdr:stable","recommended-patterns#Recommended Patterns":"Version-based:\n# Semantic versioning my_image:v1.2.3 my_image:v1.2 my_image:v1 # Date-based my_image:2025.01.12 my_image:2026_q1 # Git-based my_image:commit_a1b2c3d my_image:branch_develop Environment-based:\nmy_image:development my_image:dev my_image:testing my_image:test my_image:staging my_image:stage my_image:production my_image:prod Purpose-based:\nmy_image:latest my_image:stable my_image:experimental my_image:beta my_image:release Combined:\nmy_image:v1.2.3_production my_image:v1.2_stable my_image:2026.01_dev my_image:v1_experimental","related-commands#Related Commands":"images - List and manage images rename - Rename containers build - Build images to tag delete - Remove old tags export - Export tagged images üè∑Ô∏è No Disk Space Used: Retagging creates a new reference to the same image data. Multiple tags for one image don‚Äôt use extra disk space - they all point to the same layers! Original Tag Remains: Unlike rename for containers, retag doesn‚Äôt remove the original tag. Both the old and new tags will exist. Use delete to remove unwanted tags. Version Management: Use retag to create semantic version tags (v1.2.3), major version tags (v1), and special tags (latest, stable). This makes version management and rollback much easier!","retag-vs-rename#Retag vs Rename":"","rfswift-retag#rfswift retag":"rfswift retagCreate new tags for existing Docker images or rename image tags.","source-image-not-found#Source Image Not Found":"Error: Error: No such image: source:tag\nSolutions:\n# List available images rfswift images local # Check exact image name docker images | grep image_name # Pull if needed rfswift images pull -i penthertz/rfswift_noble:sdr_full # Then retag rfswift retag -i penthertz/rfswift_noble:sdr_full -t my_sdr:v1","synopsis#Synopsis":"rfswift retag -i IMAGE_REFERENCE -t NEW_TAG The retag command creates a new tag for an existing Docker image. This is useful for organizing images, creating aliases, marking versions, or preparing images for distribution.","tag-already-exists#Tag Already Exists":"Problem: Tag already points to different image\nSolution:\n# Check existing tag rfswift images local # Remove old tag first rfswift delete old_image:new_tag # Then create new tag rfswift retag -i source:tag -t new_tag:version # Or: Tag overwrites automatically with same ID rfswift retag -i source:tag -t existing:tag","tag-best-practices#Tag Best Practices":"Good tag names:\n# Clear and descriptive sdr_analysis:v2.1.0_production sdr_analysis:stable sdr_analysis:2026_q1_release # Environment markers app:prod_v1.2 app:dev_latest app:staging_candidate Avoid:\n# Ambiguous image:1 image:a image:test1 # Too generic my_tag temp old new","tag-creation-process#Tag Creation Process":"When you retag an image:\nNo duplication: New tag points to same image layers No disk space used: Both tags reference same underlying data Multiple tags allowed: One image can have many tags Original tag remains: Source tag is NOT removed graph LR A[Image Layers] --\u003e B[Tag: original:v1] A --\u003e C[Tag: original:latest] A --\u003e D[Tag: my_version:prod] Example:\n# Original image docker images # penthertz/rfswift_noble:sdr_full a1b2c3d4e5f6 2.5GB # Create new tag rfswift retag -i penthertz/rfswift_noble:sdr_full -t my_sdr:work # Both tags exist, pointing to same image docker images # penthertz/rfswift_noble:sdr_full a1b2c3d4e5f6 2.5GB # my_sdr:work a1b2c3d4e5f6 2.5GB # Same image ID, no extra disk space","tag-naming-conventions#Tag Naming Conventions":"","troubleshooting#Troubleshooting":""},"title":"retag"},"/docs/commands/run/":{"data":{"1-use-descriptive-names#1. Use Descriptive Names":"# Good rfswift run -i sdr_full -n rtlsdr_spectrum_analysis_2024_01 # Not recommended rfswift run -i sdr_full -n test1","2-start-unprivileged#2. Start Unprivileged":"Always start with -u 0 and add capabilities as needed:\n# Start unprivileged rfswift run -i wifi -n wifi_scan -u 0 # Add capabilities if needed rfswift capabilities add -c wifi_scan -a NET_ADMIN","3-use-read-only-mounts-for-reference-data#3. Use Read-Only Mounts for Reference Data":"rfswift run -i analysis -n data_analysis \\ -b ~/samples:/root/samples:ro \\ -b ~/output:/root/output","4-record-important-sessions#4. Record Important Sessions":"rfswift run -i pentest -n client_assessment \\ --record \\ --record-output client-$(date +%Y%m%d).cast","5-use-bridge-network-for-services#5. Use Bridge Network for Services":"rfswift run -i web_tools -n web_server \\ -t bridge \\ -w 127.0.0.1:8080:80/tcp","6-organize-project-directories#6. Organize Project Directories":"# Create organized structure mkdir -p /pathto/rf-assessments/{captures,projects,recordings} # Use in containers rfswift run -i sdr_full -n assessment \\ -b /pathto/rf-assessments/captures:/root/captures,/pathto/rf-assessments/projects:/root/projects \\ --record-output /pathto/rf-assessments/recordings/session.cast","audio-not-working#Audio Not Working":"Problem: No audio output from container\nSolution:\n# Enable audio support first rfswift host audio enable # Check PulseAudio is running ps aux | grep pulse # Run container with correct server rfswift run -i image -n container -p tcp:127.0.0.1:34567","basic-usage#Basic Usage":"Create a simple SDR container:\nrfswift run -i sdr_full -n my_sdr Create with default image from config:\n# Requires imagename set in ~/.config/rfswift/config.ini rfswift run -n my_container","best-practices#Best Practices":"","capabilities--a---capabilities#Capabilities (\u003ccode\u003e-a, --capabilities\u003c/code\u003e)":"Add specific Linux capabilities for fine-grained privilege control.\nCommon capabilities:\n# Network operations -a NET_ADMIN,NET_RAW # Process debugging -a SYS_PTRACE # Low port binding -a NET_BIND_SERVICE # File ownership changes -a CHOWN,DAC_OVERRIDE See Capabilities Reference for complete list.","cgroups--g---cgroups#Cgroups (\u003ccode\u003e-g, --cgroups\u003c/code\u003e)":"Control which device types the container can access.\nFormat: type major:minor permissions\ntype: c (character) or b (block) major:minor: Device numbers (use * for all) permissions: r (read), w (write), m (mknod) Common rules:\n# USB serial (RTL-SDR, HackRF) -g \"c 189:* rwm\" # ACM devices (Proxmark3, Arduino) -g \"c 166:* rwm\" # USB converters -g \"c 188:* rwm\" # Audio devices -g \"c 116:* rwm\" # GPU devices -g \"c 226:* rwm\" # Multiple devices -g \"c 189:* rwm,c 166:* rwm,c 188:* rwm\" Find device major numbers:\nls -l /dev/your_device # Example output: crw-rw---- 1 root dialout 189, 0 ... # ^^^ major number","common-patterns#Common Patterns":"","complex-real-world-examples#Complex Real-World Examples":"Complete SDR assessment setup:\nrfswift run -i sdr_full -n site_survey \\ -u 0 \\ -s /dev/bus/usb:/dev/bus/usb \\ -b /pathto/captures:/root/captures \\ -b /pathto/projects:/root/projects:ro \\ -g \"c 189:* rwm,c 116:* rwm\" \\ -t bridge \\ -w 8080:80/tcp \\ --record \\ --record-output site-survey-2024-01-12.cast Bluetooth security assessment:\nrfswift run -i bluetooth -n bt_pentest \\ -u 0 \\ -a NET_ADMIN,NET_RAW \\ -s /dev/ttyACM0:/dev/ttyACM0 \\ -b /pathto/bt-captures:/root/captures \\ -g \"c 166:* rwm\" \\ -t bridge \\ --record","container-name-already-exists#Container Name Already Exists":"Error: Error response from daemon: Conflict. The container name \"...\" is already in use\nSolution:\n# Remove existing container rfswift remove -c container_name # Or use different name rfswift run -i image -n container_name_2","container-naming--n---name#Container Naming (\u003ccode\u003e-n, --name\u003c/code\u003e)":"Assigns a unique name to the container. Names must be unique across all containers (running or stopped).\nNaming conventions:\n# Good names (descriptive, unique) -n rtlsdr_capture_session_1 -n client_assessment_2024_01 -n wifi_audit_conference_room -n bluetooth_pentest_device_a # Avoid generic names -n test # Too generic -n container1 # Not descriptive","detailed-option-explanations#Detailed Option Explanations":"","development-container#Development Container":"rfswift run -i sdr_full -n sdr_dev \\ -b ~/code:/root/code \\ -b ~/.ssh:/root/.ssh:ro \\ -b ~/.gitconfig:/root/.gitconfig:ro \\ -w 8888:8888/tcp","device--volume-options#Device \u0026amp; Volume Options":"Flag Description Example -s, --devices STRING Device mappings (comma-separated) -s /dev/ttyUSB0:/dev/ttyUSB0 -b, --bind STRING Volume bindings (comma-separated) -b ~/projects:/root/projects","device-mappings--s---devices#Device Mappings (\u003ccode\u003e-s, --devices\u003c/code\u003e)":"Make specific host devices available in the container.\nFormat: host_device:container_device or just host_device (same path in container)\n# Single device -s /dev/ttyUSB0:/dev/ttyUSB0 # Multiple devices -s /dev/ttyUSB0:/dev/ttyUSB0,/dev/ttyACM0:/dev/ttyACM0 Cgroups + Devices: You need BOTH cgroup rules and device mappings. Cgroups allow access to device types, mappings make specific devices available.","device-not-accessible#Device Not Accessible":"Problem: Device binding added but can‚Äôt access device in container\nSolution:\n# Add cgroup rule for device type rfswift run -i image -n container \\ -s /dev/ttyUSB0:/dev/ttyUSB0 \\ -g \"c 189:* rwm\" # Or add dynamically rfswift cgroups add -c container -g \"c 189:* rwm\"","display--audio-options#Display \u0026amp; Audio Options":"Flag Description Default Example -d, --display STRING X11 display setting DISPLAY=:0 -d DISPLAY=:1 -p, --pulseserver STRING PulseAudio server address tcp:127.0.0.1:34567 -p tcp:127.0.0.1:4713 --no-x11 Disable X11 forwarding false --no-x11","display-options#Display Options":"X11 Display (-d): Configure X11 forwarding for GUI applications\n-d DISPLAY=:0 # Default display -d DISPLAY=:1 # Alternate display PulseAudio (-p): Configure audio server\n-p tcp:127.0.0.1:34567 # Default -p tcp:localhost:4713 # Custom port Disable X11 (--no-x11): For headless containers\n--no-x11 # No GUI support","examples#Examples":"","image-not-found#Image Not Found":"Error: Error: No such image: penthertz/rfswift_noble:image_name\nSolution:\n# Pull image first rfswift images pull -i image_name # Or let run pull automatically (if network available) rfswift run -i image_name -n container","image-selection--i---image#Image Selection (\u003ccode\u003e-i, --image\u003c/code\u003e)":"Specifies which RF Swift image to use for the container.\nFormats:\n# Full registry path -i penthertz/rfswift_noble:sdr_full # Short name (resolves to penthertz/rfswift_noble:IMAGE) -i sdr_full # Custom registry -i myregistry.com/rfswift:custom Common images:\nsdr_full - Complete SDR toolkit sdr_light - Lightweight SDR tools bluetooth - Bluetooth security tools wifi - Wi-Fi assessment tools hardware - Hardware hacking tools automotive - Vehicle protocol tools See List of Images for all available images.","isolated-analysis-container#Isolated Analysis Container":"rfswift run -i reversing -n isolated_analysis \\ -u 0 \\ -t none \\ -b ~/samples:/root/samples:ro \\ -b ~/output:/root/output \\ --no-x11","network-modes--t---network#Network Modes (\u003ccode\u003e-t, --network\u003c/code\u003e)":"Configure container network isolation:\nMode Description Use Case host No isolation (default) Most RF tools, full network access bridge Default Docker bridge Web services, API servers none No network access Offline analysis, malware analysis container:NAME Share network with another container Linked services # Full network access (default) -t host # Isolated with port forwarding -t bridge -w 8080:80/tcp # Complete isolation -t none","network-operations-fail#Network Operations Fail":"Problem: Wi-Fi/Bluetooth tools can‚Äôt configure interfaces\nSolution:\n# Add network capabilities rfswift run -i wifi -n wifi_tools \\ -a NET_ADMIN,NET_RAW \\ -t bridge","network-options#Network Options":"Flag Description Default Example -t, --network STRING Network mode host -t bridge -z, --exposedports STRING Expose ports for inter-container communication None -z 8080,3000 -w, --bindedports STRING Bind ports to host None -w 8080:80/tcp -x, --extrahosts STRING Add extra host entries None -x pluto.local:192.168.1.2","options#Options":"","permission-denied-for-device#Permission Denied for Device":"Problem: Permission denied when accessing device\nSolution:\n# Check host permissions ls -l /dev/your_device # Add user to device group on host sudo usermod -aG dialout $USER newgrp dialout # Then run container rfswift run -i image -n container -s /dev/your_device:/dev/your_device","port-already-in-use#Port Already in Use":"Problem: Can‚Äôt bind port - already in use\nSolution:\n# Check what's using the port sudo lsof -i :8080 # Use different host port rfswift run -i image -n container -w 8081:80/tcp # Or stop conflicting service sudo systemctl stop service_name","port-configuration#Port Configuration":"Exposed ports (-z): Make ports available to other containers\n-z 8080 # Single port -z 8080,3000,3001 # Multiple ports Bound ports (-w): Publish ports to host\n# Format: host_port:container_port/protocol -w 8080:80/tcp # With host IP -w 127.0.0.1:8080:80/tcp # Multiple ports -w 8080:80/tcp,8443:443/tcp","privilege-level--u---privileged#Privilege Level (\u003ccode\u003e-u, --privileged\u003c/code\u003e)":"Controls container privilege level:\n0 (default): Unprivileged - Recommended for most use cases 1: Privileged - Full host access, use only when necessary When to use privileged mode:\nKernel module loading required Low-level hardware access Complex network operations Security Risk: Privileged containers can escape isolation and compromise the host. Use -u 1 only when absolutely necessary and remove the container after use.","quick-container-for-testing#Quick Container for Testing":"# Minimal setup rfswift run -i sdr_light -n test # With one device rfswift run -i sdr_full -n quick_test -s /dev/bus/usb:/dev/bus/usb","recording-options#Recording Options":"Flag Description Example --record Enable session recording --record --record-output STRING Custom recording filename --record-output session.cast","recording-options-1#Recording Options":"Enable recording (--record): Records terminal session\n--record # Auto-generated filename Custom filename (--record-output): Specify recording filename\n--record-output client-session.cast --record-output /path/to/recordings/$(date +%Y%m%d)-session.cast Recordings are saved in asciinema format (.cast files) and can be replayed with rfswift log replay.","related-commands#Related Commands":"exec - Enter an existing container stop - Stop a running container remove - Remove a container bindings - Dynamically add devices/volumes capabilities - Modify capabilities after creation cgroups - Modify cgroup rules after creation ports - Manage ports after creation üí° Tip: Use rfswift run --help to see all options with their current default values from your config file.","repeatable-assessment-container#Repeatable Assessment Container":"# Save as script: setup_assessment.sh #!/bin/bash CONTAINER_NAME=\"assessment_$(date +%Y%m%d)\" rfswift run -i pentest -n \"$CONTAINER_NAME\" \\ -u 0 \\ -t bridge \\ -b ~/assessments:/root/work \\ --record \\ --record-output \"${CONTAINER_NAME}.cast\"","required-flags#Required Flags":"Flag Description Example -i, --image STRING Image name or tag to use -i sdr_full -n, --name STRING Name for the new container -n my_container","rfswift-run#rfswift run":"rfswift runCreate and start a new container from an RF Swift image.","security-options#Security Options":"Flag Description Default Example -u, --privileged INT Privilege level (1=privileged, 0=unprivileged) 0 -u 0 -a, --capabilities STRING Additional capabilities (comma-separated) None -a NET_ADMIN,NET_RAW -g, --cgroups STRING Cgroup device rules (comma-separated) See config -g \"c 189:* rwm\" -m, --seccomp STRING Custom seccomp profile path Default -m /path/to/profile.json","synopsis#Synopsis":"rfswift run -i IMAGE -n CONTAINER_NAME [options] The run command is the primary way to create new containers in RF Swift. It pulls the specified image (if not already available), creates a container with the given name, and starts it with an interactive shell.","troubleshooting#Troubleshooting":"","volume-bindings--b---bind#Volume Bindings (\u003ccode\u003e-b, --bind\u003c/code\u003e)":"Share directories between host and container.\nFormat: host_path:container_path[:options]\nOptions:\nNone (default): Read-write access :ro: Read-only access # Read-write binding -b ~/projects:/root/projects # Read-only binding -b ~/samples:/root/samples:ro # Multiple bindings -b ~/projects:/root/projects,~/captures:/root/captures Use cases:\nShare project files Save captures to host Mount firmware samples (read-only) Share tool configurations","with-devices#With Devices":"All USB devices:\nrfswift run -i sdr_full -n rtlsdr_work \\ -s /dev/bus/usb:/dev/bus/usb \\ -g \"c 189:* rwm\" Multiple USB serial devices:\nrfswift run -i hardware -n multi_device \\ -s /dev/ttyUSB0:/dev/ttyUSB0,/dev/ttyACM0:/dev/ttyACM0 \\ -g \"c 189:* rwm,c 166:* rwm\"","with-network-configuration#With Network Configuration":"Bridge network with port binding:\nrfswift run -i web_tools -n web_server \\ -t bridge \\ -w 8080:80/tcp Multiple ports exposed and bound:\nrfswift run -i api_server -n backend \\ -t bridge \\ -z 3000,3001,3002 \\ -w 8080:3000/tcp,8081:3001/tcp Network isolation (no network):\nrfswift run -i analysis -n offline_analysis \\ -t none \\ -b ~/data:/root/data Custom host entries:\nrfswift run -i penthertz/rfswift_noble:telecom -n network_test \\ -x \"device1.local:192.168.1.10,device2.local:192.168.1.11\"","with-security-configuration#With Security Configuration":"Unprivileged container with specific capabilities:\nrfswift run -i wifi -n wifi_scan \\ -u 0 \\ -a NET_ADMIN,NET_RAW \\ -t bridge With custom seccomp profile:\nrfswift run -i pentest -n secure_assessment \\ -u 0 \\ -m ~/seccomp-profiles/restricted.json \\ -g \"c 189:* rwm\" Privileged mode (use sparingly):\nrfswift run -i hardware -n hardware_debug \\ -u 1","with-session-recording#With Session Recording":"Record with auto-generated filename:\nrfswift run -i bluetooth -n bt_assessment \\ --record Record with custom filename:\nrfswift run -i sdr_full -n client_pentest \\ --record \\ --record-output client-assessment-2024-01-12.cast Combined: Recording with security and devices:\nrfswift run -i wifi -n wifi_audit \\ -u 0 \\ -a NET_ADMIN,NET_RAW \\ -t bridge \\ -s /dev/wlan0:/dev/wlan0 \\ --record \\ --record-output wifi-audit-session.cast","x11-not-working#X11 Not Working":"Problem: GUI applications won‚Äôt start or display\nSolution:\n# On host (Linux) xhost +local: # Then run container rfswift run -i image -n container -d DISPLAY=$DISPLAY # Or disable X11 for headless operation rfswift run -i image -n container --no-x11"},"title":"run"},"/docs/commands/stop/":{"data":{"basic-usage#Basic Usage":"Stop a specific container:\nrfswift stop -c my_sdr_container Stop by container ID:\nrfswift stop -c a1b2c3d4e5f6 Stop with short container ID:\nrfswift stop -c a1b2c3","batch-container-management#Batch Container Management":"# Stop multiple related containers CONTAINERS=\"capture1 capture2 capture3\" for container in $CONTAINERS; do echo \"Stopping $container...\" rfswift stop -c $container done # Or using docker directly docker stop capture1 capture2 capture3","common-workflows#Common Workflows":"","container-already-stopped#Container Already Stopped":"Problem: Trying to stop an already stopped container\nrfswift stop -c my_container # Error: Container is not running Solution:\n# Check if running docker ps | grep my_container # If not in output, it's already stopped docker ps -a | grep my_container # No action needed","container-lifecycle-management#Container Lifecycle Management":"# Week 1: Create and use rfswift run -i sdr_full -n project_alpha # Week 1-2: Use daily rfswift exec -c project_alpha # Weekend: Stop to save resources rfswift stop -c project_alpha # Week 3: Resume rfswift exec -c project_alpha # Project complete: Remove if not needed anymore rfswift remove -c project_alpha","container-not-found#Container Not Found":"Error: Error: No such container: container_name\nSolutions:\n# List all containers rfswift las # Container may have been removed # Need to create new one rfswift run -i image -n container_name","container-state-after-stop#Container State After Stop":"# Check container status docker ps -a | grep my_container # Output shows: # STATUS: Exited (0) 2 minutes ago Container is:\n‚úÖ Still exists in Docker ‚úÖ Can be restarted ‚úÖ Can be committed to an image ‚úÖ Can be removed ‚ùå Not consuming CPU ‚ùå Not consuming RAM ‚úÖ Still consuming disk space","container-wont-stop#Container Won\u0026rsquo;t Stop":"Problem: Container doesn‚Äôt stop after reasonable time\nSolutions:\n# Wait longer (some containers need cleanup time) rfswift stop -c my_container # Wait 30-60 seconds # Force stop with Docker docker kill my_container # Immediate force stop # Check what's preventing shutdown docker logs my_container","daily-work-cycle#Daily Work Cycle":"# Monday: Create container rfswift run -i pentest -n weekly_work -b ~/work:/root/work # Monday-Friday: Use throughout week rfswift exec -c weekly_work # ... work ... exit # Each evening: Stop to free resources rfswift stop -c weekly_work # Each morning: Resume rfswift exec -c weekly_work # Auto-starts # Friday: Clean up when done rfswift remove -c weekly_work","data-loss-concerns#Data Loss Concerns":"Problem: Worried about losing data when stopping\nVerification:\n# Check mounted volumes docker inspect my_container | grep -A 10 Mounts # Data in mounted volumes is safe # Data in container filesystem is preserved when stopped # Only running processes and RAM contents are lost # To be extra safe, commit before stopping rfswift commit -c my_container -i backup_image rfswift stop -c my_container","data-persistence#Data Persistence":"When a container is stopped:\n‚úÖ Container filesystem: All data inside the container is preserved ‚úÖ Mounted volumes: Data in mounted directories remains intact ‚úÖ Container configuration: All settings, bindings, and capabilities are preserved ‚úÖ Network configuration: Port bindings and network settings are saved ‚ùå Running processes: All processes inside the container are terminated ‚ùå Memory state: RAM contents are lost (not hibernated) Example:\n# Create container with captures rfswift run -i sdr_full -n capture_session -b ~/captures:/root/captures # Inside container: Start long capture rfswift exec -c capture_session rtl_sdr -f 100M -s 2.4M capture.dat \u0026 exit # Stop container rfswift stop -c capture_session # Process terminates, but files in ~/captures persist # Resume later rfswift exec -c capture_session ls /root/captures # Files still there","examples#Examples":"","multiple-containers-with-similar-names#Multiple Containers with Similar Names":"Problem: Ambiguous container name\nSolutions:\n# Use full name rfswift stop -c full_container_name # Use container ID docker ps # Get ID rfswift stop -c a1b2c3d4e5f6 # List to identify rfswift last","options#Options":"Flag Description Required Example -c, --container STRING Container name or ID to stop Yes -c my_container","permission-denied#Permission Denied":"Problem: Can‚Äôt stop container\nSolutions:\n# Use sudo on Linux (if not in docker group) sudo rfswift stop -c my_container # Or add user to docker group sudo usermod -aG docker $USER newgrp docker # Then try again rfswift stop -c my_container","process-handling#Process Handling":"Graceful shutdown:\nDocker sends SIGTERM to all processes Processes have 10 seconds to clean up If processes don‚Äôt exit, Docker sends SIGKILL Container stops Important for:\nDatabase containers (ensure data consistency) Long-running captures (may lose in-progress data) Network services (connections are dropped)","real-world-scenarios#Real-World Scenarios":"End of work day:\n# Stop assessment container for the day rfswift stop -c client_assessment # Resume tomorrow rfswift exec -c client_assessment Free up resources:\n# Stop idle containers to free memory rfswift stop -c sdr_capture rfswift stop -c wifi_analysis rfswift stop -c bluetooth_scanner Before system maintenance:\nFor now you can do the following trick:\n# Stop all RF Swift containers before system update for container in $(docker ps -q --filter \"ancestor=penthertz/rfswift_noble\"); do rfswift stop -c $container done Temporary pause:\n# Stop container during lunch break rfswift stop -c long_running_capture # Resume after lunch rfswift exec -c long_running_capture","related-commands#Related Commands":"run - Create new containers exec - Enter and restart stopped containers remove - Permanently delete containers last - List recent containers with status commit - Save container state before stopping üí° Quick Tip: Create a nightly cron job to stop idle RF Swift containers and free resources: crontab -e then add 0 2 * * * /path/to/stop_idle_containers.sh Data Safety: Stopping a container is completely safe - all your data is preserved. Only running processes are terminated. Think of it like ‚Äúsleep mode‚Äù for your container! Long-Running Processes: If you have captures or long-running processes inside a container, they will be terminated when the container stops. Save your work before stopping!","resource-management#Resource Management":"# List running containers docker ps # Stop idle containers rfswift stop -c sdr_test1 rfswift stop -c old_assessment rfswift stop -c experiment_container","rfswift-stop#rfswift stop":"rfswift stopStop a running container without removing it.","stop-vs-exit#Stop vs Exit":"Operation stop exit (from shell) Initiated from Host Inside container Stops container ‚úÖ Always ‚ö†Ô∏è Sometimes* Graceful shutdown ‚úÖ Yes ‚ö†Ô∏è Depends Use when Managing from host Done with current session Container stops if no other processes are running Workflow comparison:\n# Using exit (from inside container) rfswift exec -c my_container # ... work ... exit # Container may still be running if background processes exist # Using stop (from host) rfswift stop -c my_container # Container definitely stops, all processes terminate","synopsis#Synopsis":"rfswift stop -c CONTAINER_NAME The stop command gracefully stops a running container while preserving all data and state. The container can be restarted later with exec or using Docker commands.","troubleshooting#Troubleshooting":"","what-happens-when-you-stop-a-container#What Happens When You Stop a Container":""},"title":"stop"},"/docs/commands/update/":{"data":{"already-up-to-date#Already Up-to-Date":"Problem: ‚ÄúAlready up-to-date‚Äù but version seems old\nSolutions:\n# Check current version rfswift --version # Check latest release # Visit: https://github.com/penthertz/rfswift/releases # Force reinstall if needed curl -fsSL \"https://raw.githubusercontent.com/PentHertz/RF-Swift/refs/heads/main/get_rfswift.sh\" | sh","basic-usage#Basic Usage":"Update to latest version:\nrfswift update Example output:\nChecking for updates... Current version: v0.6.4 Latest version: v0.6.5 Downloading update... Installing RF Swift v0.6.5... ‚úì Update successful! RF Swift updated to v0.6.5","binary-corrupted#Binary Corrupted":"Problem: Update succeeded but binary doesn‚Äôt work\nSolutions:\n# Restore backup sudo mv /usr/local/bin/rfswift.old /usr/local/bin/rfswift # Or reinstall curl -fsSL \"https://raw.githubusercontent.com/PentHertz/RF-Swift/refs/heads/main/get_rfswift.sh\" | sh # Verify rfswift --version rfswift last","download-failed#Download Failed":"Problem: Cannot download new version\nSolutions:\n# Check internet connection curl -I https://github.com # Check firewall/proxy settings # Try with sudo sudo rfswift update","examples#Examples":"","not-updated#NOT Updated":"Component Updated? How to Update Docker images ‚ùå No rfswift images pull Containers ‚ùå No rfswift upgrade User data ‚ùå No Never modified Configuration ‚ùå No Preserved","options#Options":"The update command takes no options.","related-commands#Related Commands":"images - Update Docker images separately upgrade - Upgrade containers to new images completion - Regenerate completions after update ‚¨ÜÔ∏è Regular Updates: Keep RF Swift updated for the latest features, bug fixes, and security improvements. Updates are automatic and safe - your containers and data are never modified! Binary Only: The update command only updates the RF Swift CLI tool, not Docker images or containers. Use rfswift images pull to update images and rfswift upgrade to upgrade containers. Automatic Backup: The update process automatically backs up your current version to /usr/local/bin/rfswift.old, allowing easy rollback if needed!","rfswift-update#rfswift update":"rfswift updateUpdate RF Swift to the latest version from the official Penthertz repository.","synopsis#Synopsis":"rfswift update The update command downloads and installs the latest version of RF Swift, including the command-line tool and all its components. The update process is automatic and handles backup of the current version.","troubleshooting#Troubleshooting":"","update-failed#Update Failed":"Problem: Update command fails\nSolutions:\n# Check internet connection ping github.com # Check permissions ls -l /usr/local/bin/rfswift # Update with sudo if needed sudo rfswift update # Check disk space df -h /usr/local # Try manual installation curl -fsSL \"https://raw.githubusercontent.com/PentHertz/RF-Swift/refs/heads/main/get_rfswift.sh\" | sh","update-triggers#Update Triggers":"When to update:\n‚úÖ New features announced ‚úÖ Security updates released ‚úÖ Bug fixes available ‚úÖ Before starting new projects ‚úÖ Monthly maintenance When to delay:\n‚ö†Ô∏è During active critical work ‚ö†Ô∏è In production environments (test first) ‚ö†Ô∏è When disconnected/offline","updated-components#Updated Components":"When you run rfswift update:\nComponent Updated? Location RF Swift binary ‚úÖ Yes /usr/local/bin/rfswift CLI tool ‚úÖ Yes Command-line interface Helper scripts ‚úÖ Yes Internal utilities Documentation ‚úÖ Yes Built-in help","what-gets-updated#What Gets Updated":""},"title":"update"},"/docs/commands/upgrade/":{"data":{"basic-usage#Basic Usage":"Upgrade to latest version:\nrfswift upgrade -c my_container Upgrade to specific version:\nrfswift upgrade -c sdr_work -i penthertz/rfswift_noble:sdr_full Upgrade with preserved directories:\nrfswift upgrade -c analysis_work \\ -i penthertz/rfswift_noble:sdr_full \\ -r /root/scripts,/root/captures,/opt/tools Downgrade to previous version:\nrfswift upgrade -c production -i penthertz/rfswift_noble:v0.6.4","configuration-lost-after-upgrade#Configuration Lost After Upgrade":"Problem: Network/volume/device settings missing\nCause: Upgrade creates new container, doesn‚Äôt copy Docker configuration\nSolution:\n# Document current configuration before upgrade docker inspect old_container \u003e old_container_config.json # After upgrade, reconfigure manually rfswift bindings add -c container -s ~/data -t /root/data rfswift capabilities add -c container -p NET_ADMIN rfswift cgroups add -c container -r \"c 189:* rwm\" rfswift ports bind -c container -b \"8080/tcp:8080\"","container-not-found#Container Not Found":"Error: Error: No such container: container_name\nSolutions:\n# List containers rfswift last","examples#Examples":"","how-upgrade-works#How Upgrade Works":"","image-pull-failed#Image Pull Failed":"Error: Error pulling image\nSolutions:\n# Check network connectivity ping registry.hub.docker.com # Pull manually first docker pull penthertz/rfswift_noble:sdr_full # Retry upgrade rfswift upgrade -c container -i penthertz/rfswift_noble:sdr_full","old-container-still-running#Old Container Still Running":"Problem: Upgrade completes but old container still active\nSolution:\n# Stop old container manually rfswift stop -c container_old # Verify new container is running docker ps | grep container # Remove old container when satisfied rfswift remove -c container_old","options#Options":"Flag Description Required Example -c, --container STRING Container name or ID to upgrade Yes -c my_container -i, --image STRING Target image name/tag No (defaults to latest) -i telecom_15012025 -r, --repositories STRING Comma-separated directories to preserve No -r /root/tools,/opt/data","preserved-directory-not-found#Preserved Directory Not Found":"Error: Directory /root/nonexistent not found in source container\nSolutions:\n# Check what directories exist rfswift exec -c old_container ls -la /root/ exit # Adjust -r flag to existing directories only rfswift upgrade -c container -r /root/existing,/opt/tools","related-commands#Related Commands":"run - Create new containers commit - Save container state before upgrade export - Backup before upgrade import - Restore from backup if upgrade fails images - Check available images for upgrade ‚¨ÜÔ∏è Always Backup First: Before upgrading, create a backup with export container. This allows easy rollback if the upgrade has issues. The old container is kept as container_old for verification. Reconfiguration Required: Upgrade creates a new container, so volume bindings, device mappings, network settings, and capabilities must be reconfigured manually after upgrade. Document these before upgrading! Selective Preservation: Use the -r flag to preserve only necessary directories. Preserving too much may carry over conflicts, while preserving too little requires more post-upgrade setup. Balance based on your needs!","rfswift-upgrade#rfswift upgrade":"rfswift upgradeUpgrade containers to newer image versions while preserving selected data directories.","rollback-failed#Rollback Failed":"Problem: Can‚Äôt restore old container after bad upgrade\nSolution:\n# If you have backup rfswift import container -i backup.tar.gz -n container_restored rfswift run -i container_restored -n container # If old container still exists rfswift remove -c container # Remove bad new container rfswift rename -n container_old -d container rfswift exec -c container","synopsis#Synopsis":"rfswift upgrade -c CONTAINER_NAME [-i IMAGE_NAME] [-r REPOSITORIES] The upgrade command follows this pattern: pull new image ‚Üí create new container ‚Üí copy preserved directories ‚Üí inherit original container name. This enables seamless version upgrades while maintaining important data.","troubleshooting#Troubleshooting":"","upgrade-process#Upgrade Process":"The upgrade command follows this sequence:\nValidate: Check source container exists Pull: Download target image (if not present locally) Create: Start new container from target image Copy: Transfer preserved directories from old to new container Stop: Stop old container Rename: Rename old container (adds _old suffix) Inherit: New container inherits original name Cleanup: Old container remains stopped for verification graph LR A[Old Container] --\u003e|Pull Image| B[New Image] B --\u003e|Create| C[New Container] A --\u003e|Copy Directories| C A --\u003e|Stop \u0026 Rename| D[Old Container_old] C --\u003e|Inherit Name| E[New Container with Original Name]","what-doesnt-get-preserved#What Doesn\u0026rsquo;t Get Preserved":"Important: The upgrade command creates a completely new container, so:\n‚ùå Volume bindings (must remount) ‚ùå Device mappings (must reconfigure) ‚ùå Network configuration (must reconfigure) ‚ùå Port bindings (must reconfigure) ‚ùå Capabilities (must reconfigure) ‚ùå Cgroup rules (must reconfigure) Solution: After upgrade, reconfigure these settings:\n# Upgrade rfswift upgrade -c work -r /root/data # Reconfigure volumes rfswift bindings add -c work -s ~/captures -t /root/captures # Reconfigure devices rfswift bindings add -c work -d -s /dev/device -t /dev/device # Reconfigure capabilities rfswift capabilities add -c work -p NET_ADMIN","what-gets-preserved#What Gets Preserved":"Content Preserved? How Directories in -r flag ‚úÖ Yes Copied to new container Files in preserved dirs ‚úÖ Yes Complete copy Other directories ‚ùå No Use new image defaults Container name ‚úÖ Yes Inherited by new container Mounted volumes ‚ö†Ô∏è Reconfigure Must remount manually Network settings ‚ö†Ô∏è Reconfigure Must reconfigure manually Port bindings ‚ö†Ô∏è Reconfigure Must reconfigure manually"},"title":"upgrade"},"/docs/comparisons/":{"data":{"":"","next-steps#Next Steps":"Dive right into the following section to get started:\nGetting StartedLearn how to run RF Swift Compile RF Swift binaryCompile RF Swift and develop around the framework","questions-or-feedback#Questions or Feedback?":"‚ùì RF Swift is still in active development. Have a question or feedback? Feel free to open an issue!","rf-swift-vs-specific-security-or-rf-distributions-comparison#RF Swift vs. Specific Security or RF distributions comparison":"Your hearth struggle choosing a specific distribution and RF Swift? Here are some key arguments that at the end made us developped that solution ;)\nWith RF Swift‚Äôs container-based architecture, each engagement runs in its own isolated environment. You can experiment freely, knowing that a broken dependency or conflicting library won‚Äôt cascade across your entire system.\nFeature RF Swift Pentest Distributions Dragon OS üñ•Ô∏è Host OS Preservation ‚úÖ Runs alongside your existing OS ‚ùå Requires dedicated partition or VM ‚ùå Requires dedicated partition or VM üß∞ Tool Isolation ‚úÖ Tools run in containers without impacting system ‚ö†Ô∏è Tools can affect system stability ‚ö†Ô∏è Tools can affect system stability üöÄ Deployment Speed ‚úÖ Fast container deployment ‚ùå Full OS installation required ‚ùå Full OS installation required üì¶ VM Requirement ‚úÖ No VM needed ‚ö†Ô∏è Needs VM for non-dedicated machines ‚ö†Ô∏è Needs VM for non-dedicated machines üîß Tool Availability ‚úÖ Extensive collection for RF, hardware security, and reversing ‚úÖ Extensive collection for general pentesting ‚úÖ Specialized for RF üîÑ Tool Updates ‚úÖ Independent container updates ‚ö†Ô∏è Tied to system update cycle ‚ö†Ô∏è Tied to system update cycle üîÅ Rollback Capability ‚úÖ Instant rollback via container images ‚ùå Requires snapshots or manual backup ‚ùå Requires snapshots or manual backup üíæ Storage Efficiency ‚úÖ Modular‚Äîinstall only what you need ‚ùå Requires significant disk space ‚ùå Requires significant disk space üõ°Ô∏è Security Isolation ‚úÖ Strong container isolation with custom confinement ‚ö†Ô∏è Limited isolation between applications ‚ö†Ô∏è Limited isolation between applications üîå Network Containment ‚úÖ Per-container network isolation ‚ö†Ô∏è Requires additional setup ‚ö†Ô∏è Requires additional setup üèóÔ∏è Architecture Support ‚úÖ x86_64, ARM64, RISC-V64 ‚úÖ x86_64, ARM64 ‚ö†Ô∏è Primarily x86_64 üß© Customization ‚úÖ Highly modular‚Äîpick specific tools ‚úÖ Customizable, but changes affect entire system ‚ö†Ô∏è Limited customization üì± USB Device Access ‚úÖ Streamlined USB forwarding ‚úÖ Direct access ‚úÖ Direct access üîä Audio Support ‚úÖ Container-based audio support ‚úÖ Native audio support ‚úÖ Native audio support üåê Internet Connectivity ‚úÖ Configurable per container ‚úÖ System-wide configuration ‚úÖ System-wide configuration Pentest Distributions includes Kali Linux, Pentoo, Parrot OS, and similar security-focused operating systems.","use-case-scenarios#Use Case Scenarios":"Scenario RF Swift Kali Linux/Pentoo/Parrot OS Dragon OS Air-gapped environments ‚≠ê‚≠ê‚≠ê ‚≠ê‚≠ê‚≠ê ‚≠ê‚≠ê‚≠ê Security assessments ‚≠ê‚≠ê‚≠ê‚≠ê ‚≠ê‚≠ê‚≠ê ‚≠ê Quick assessment on personal device ‚≠ê‚≠ê‚≠ê ‚≠ê ‚≠ê Deployment on a burner laptop ‚≠ê‚≠ê‚≠ê ‚≠ê ‚≠ê Low storage environments ‚≠ê‚≠ê‚≠ê ‚≠ê ‚≠ê Multiple architecture development ‚≠ê‚≠ê‚≠ê ‚≠ê‚≠ê ‚≠ê Isolated testing environment ‚≠ê‚≠ê‚≠ê ‚≠ê ‚ùå Organization of traces ‚≠ê‚≠ê‚≠ê ‚ùå ‚ùå Sharing setups accross users and servers ‚≠ê‚≠ê‚≠ê ‚ùå ‚ùå Recording sessions ‚≠ê‚≠ê‚≠ê ‚ùå ‚ùå"},"title":"Comparisons with dedicated distributions"},"/docs/container_scripts/":{"data":{"available-scripts#Available Scripts":"Avahi Container ScriptEnable service discovery for PlutoSDR and network devices LibreSDR Firmware SwapUpgrade USRP B210/B220 with enhanced FPGA firmware RF Scripts UpdaterKeep your RF Swift scripts updated with the latest versions","hardware-enhancement#Hardware Enhancement":"Scripts that modify or optimize hardware functionality:\nLibreSDR Firmware Swap: Enhances USRP devices with improved firmware","maintenance#Maintenance":"Scripts that help keep your environment updated and optimized:\nRF Scripts Updater: Synchronizes local scripts with the latest versions","next-steps#Next Steps":"Explore each script‚Äôs dedicated documentation for detailed usage instructions, examples, and technical details.","overview#Overview":"RF Swift provides several utility scripts that simplify common tasks inside containers. These scripts enable advanced functionality, streamline configuration, and help you get the most out of your RF and hardware tools.","rf-swift-container-scripts#RF Swift Container Scripts":"RF Swift Container Scripts","script-categories#Script Categories":"","service-enablement#Service Enablement":"Scripts that activate or configure services inside containers:\nAvahi Container Script: Enables mDNS service discovery","troubleshooting#Troubleshooting":"If you encounter issues with container scripts:\nEnsure the script has execute permissions (chmod +x scriptname) Check that required dependencies are installed in the container Verify you have the necessary permissions for the operation Consult the specific script documentation for troubleshooting guidance","using-container-scripts#Using Container Scripts":"All container scripts are automatically installed in RF Swift containers and available in the system PATH. You can execute them directly from any directory inside the container:\n# Example: Start Avahi service discovery avahicontainer_start # Example: Update RF scripts update_rfscripts # Example: Swap USRP firmware libresdr_swapfpga","why-container-scripts#Why Container Scripts?":"Container scripts extend RF Swift‚Äôs capabilities by:\nSimplifying Complex Tasks: Turn multi-step processes into single commands Enhancing Device Compatibility: Improve functionality with specialized hardware Maintaining Updates: Keep tools and utilities current with minimal effort Enabling Advanced Features: Access capabilities not available in standard configurations"},"title":"üõ†Ô∏è Container Scripts"},"/docs/container_scripts/avahi_inside_container/":{"data":{"advanced-usage#Advanced Usage":"","auto-starting-avahi#Auto-Starting Avahi":"To automatically start Avahi when running a container:\nrfswift run -i sdr_full -n pluto_container -e \"avahicontainer_start \u0026\u0026 /bin/bash\"","common-issues#Common Issues":"If the script doesn‚Äôt solve your service discovery issues:\nNetwork Configuration: Ensure your container is using the host network (the default for RF Swift)\n# Check network mode of your container rfswift container list Firewall Settings: Multicast DNS uses UDP port 5353 - ensure it‚Äôs not blocked\n# Check if multicast traffic is allowed sudo iptables -L | grep 5353 Multiple Avahi Instances: Sometimes conflicts occur if the host is also running Avahi\n# On your host system, temporarily stop Avahi if needed sudo systemctl stop avahi-daemon","custom-service-files#Custom Service Files":"You can add custom Avahi service files to advertise specific services:\n# Create a custom service file cat \u003e /etc/avahi/services/myservice.service \u003c\u003c EOF \u003c?xml version=\"1.0\" standalone='no'?\u003e \u003c!DOCTYPE service-group SYSTEM \"avahi-service.dtd\"\u003e MyCustomService _myservice._tcp 12345 EOF # Restart Avahi to apply avahi-daemon -r","manual-execution#Manual Execution":"To manually start Avahi in a running container:\n# Inside your RF Swift container avahicontainer_start","overview#Overview":"The avahicontainer_start script is a utility included in RF Swift containers to enable service discovery through Avahi. This script is particularly useful when working with PlutoSDR and other devices that rely on zeroconf/mDNS discovery.","plutosdr-example#PlutoSDR Example":"When working with PlutoSDR, you can use this script to enable automatic discovery:\n# Start Avahi service avahicontainer_start # Wait a moment for services to register sleep 2 # Find PlutoSDR on the network iio_info -s # Should show something like: # Available IIO contexts: # Context 0: ip:pluto.local","script-details#Script Details":"The avahicontainer_start script in /usr/sbin initializes the D-Bus daemon and Avahi service within a container:","troubleshooting#Troubleshooting":"","using-the-avahi-container-start-script#Using the Avahi Container Start Script":"Using the Avahi Container Start Script","using-the-script#Using the Script":"","verifying-its-working#Verifying It\u0026rsquo;s Working":"After running the script, you can verify that Avahi is properly running:\n# Check if Avahi is running ps aux | grep avahi # Test service discovery avahi-browse -a","what-this-script-does#What This Script Does":"Create D-Bus Directory: Creates the /var/run/dbus directory if it doesn‚Äôt exist Start D-Bus Daemon: Launches the D-Bus system daemon in the background Wait Period: Pauses for 2 seconds to ensure D-Bus is fully initialized Start Avahi Daemon: Launches the Avahi daemon in daemon mode (-D)","when-to-use-this-script#When to Use This Script":"Use the avahicontainer_start script when:\nWorking with PlutoSDR or similar devices that use network service discovery Running tools that require mDNS (multicast DNS) or service discovery Encountering ‚ÄúAvahi daemon not running‚Äù or similar errors"},"title":"Avahi Container Start Script"},"/docs/container_scripts/libresdr_swap_firmware/":{"data":{"1-backup-the-original-binary#1. Backup the Original Binary":"Before making any changes, it‚Äôs recommended to back up the original FPGA firmware:\nEnter your choice [1-4]: 1 This creates a backup at: /usr/share/uhd/images/usrp_b210_fpga_backup.bin\nIf a backup already exists, this operation will be skipped to prevent overwriting your existing backup.","2-replace-the-original-binary#2. Replace the Original Binary":"To replace the original firmware with a LibreSDR version:\nEnter your choice [1-4]: 2 You‚Äôll be presented with two replacement options:\nSelect the binary to replace the original: 1) libresdr_b210.bin 2) libresdr_b220.bin 3) Cancel libresdr_b210.bin: Enhanced firmware for USRP B210 devices libresdr_b220.bin: Enhanced firmware for USRP B220 devices","3-restore-the-backup-binary#3. Restore the Backup Binary":"If you need to revert to the original firmware:\nEnter your choice [1-4]: 3 This will restore the previously backed-up firmware file.","4-exit#4. Exit":"To exit the utility:\nEnter your choice [1-4]: 4","common-issues#Common Issues":"Device not recognized after firmware swap:\nDisconnect and reconnect the device Restart the UHD service: sudo systemctl restart uhd Errors during firmware replacement:\nEnsure you have sufficient disk space Verify that the LibreSDR firmware files exist in the correct location Permission issues:\nThe utility must be run with sudo or as root","file-locations#File Locations":"The utility manages the following files:\nOriginal firmware: /usr/share/uhd/images/usrp_b210_fpga.bin Backup location: /usr/share/uhd/images/usrp_b210_fpga_backup.bin LibreSDR B210: /rftools/sdr/libresdr/libresdr_b210.bin LibreSDR B220: /rftools/sdr/libresdr/libresdr_b220.bin","important-notes#Important Notes":"Always backup your original firmware before making any changes After changing firmware, you may need to restart any applications using the USRP device Some LibreSDR features may require specific software support The enhanced firmware may consume more power or generate more heat during operation","libresdr-fpga-swap-utility#LibreSDR FPGA Swap Utility":"LibreSDR FPGA Swap Utility","main-menu-options#Main Menu Options":"The utility presents a menu with four options:\nWhat would you like to do? 1) Backup the original binary 2) Replace the original binary 3) Restore the backup binary 4) Exit","overview#Overview":"The libresdr_swapfpga utility allows you to easily switch between different FPGA firmware binaries for USRP B210/B220 devices when using them with LibreSDR. This tool provides a simple interface to backup, replace, and restore FPGA firmware files, enabling enhanced functionality with LibreSDR modifications.","restoring-from-command-line#Restoring from Command Line":"If you need to restore the original firmware without the utility:\nsudo cp /usr/share/uhd/images/usrp_b210_fpga_backup.bin /usr/share/uhd/images/usrp_b210_fpga.bin","running-the-utility#Running the Utility":"The utility must be run with root privileges:\nsudo libresdr_swapfpga","system-requirements#System Requirements":"Root privileges (required to modify files in /usr/share/uhd/images/) UHD (USRP Hardware Driver) installed LibreSDR firmware files","technical-details#Technical Details":"","troubleshooting#Troubleshooting":"","using-the-utility#Using the Utility":"","what-this-utility-does#What This Utility Does":"This utility manages the FPGA firmware files that control the behavior of USRP B210/B220 software-defined radio devices. It allows you to:\nBackup the original USRP FPGA firmware Replace the firmware with LibreSDR-enhanced versions Restore the original firmware when needed","when-to-use-this-utility#When to Use This Utility":"Use the libresdr_swapfpga utility when:\nYou want to enhance your USRP B210/B220 with LibreSDR capabilities You need to switch between different FPGA firmware versions for testing You want to restore the original firmware for standard UHD operation"},"title":"LibreSDR FPGA Swap Utility"},"/docs/container_scripts/rfswift_install/":{"data":{"changing-the-target-directory#Changing the Target Directory":"Edit the update_rfscripts file to change the TARGET_DIR variable:\n# Original TARGET_DIR=\"$(pwd)/scripts\" # Modified example (specific directory) TARGET_DIR=\"/opt/rfswift/scripts\"","common-issues#Common Issues":"Network Connection Errors\nEnsure you have a working internet connection Check if GitHub is accessible from your network Permission Errors\nIf you see permission errors, check the ownership of your scripts directory: ls -la ~/scripts Ensure you have write permissions to the directory: chmod u+w ~/scripts Execution Fails After Update\nIf scripts won‚Äôt execute after updating, check the permissions: chmod +x ~/scripts/*.sh","customization#Customization":"If you need to modify the default behavior of the script updater:","file-handling#File Handling":"The utility uses rsync with the following options:\n-a: Archive mode (preserves permissions, timestamps, etc.) -v: Verbose output so you can see which files are updated --delete: Removes local files that no longer exist in the repository","overview#Overview":"The update_rfscripts utility is a tool that keeps your local RF Swift scripts synchronized with the latest versions from the official repository. This ensures you always have access to the most recent tools, fixes, and improvements without manually downloading and managing script files.","preserving-local-modifications#Preserving Local Modifications":"If you‚Äôve made local changes to scripts that you want to keep, remove the --delete option from the rsync command:\n# Change from rsync -av --delete \"$TEMP_DIR/\" \"$TARGET_DIR/\" # To rsync -av \"$TEMP_DIR/\" \"$TARGET_DIR/\"","related-documentation#Related Documentation":"RF Swift Utilities Custom Script Development Troubleshooting","repository-source#Repository Source":"The scripts are downloaded from the official RF Swift images repository:\nhttps://github.com/PentHertz/RF-Swift-images","rf-scripts-update-utility#RF Scripts Update Utility":"RF Scripts Update Utility","running-the-utility#Running the Utility":"To update your RF scripts, simply run:\nupdate_rfscripts No root privileges are required, as the scripts are installed to your user‚Äôs home directory.","script-location-and-usage#Script Location and Usage":"","technical-details#Technical Details":"","troubleshooting#Troubleshooting":"","update-process#Update Process":"The utility uses a four-step process:\nPreparation: Creates necessary directories and sets up a temporary workspace Download: Uses curl and tar to fetch only the scripts folder from the repository Synchronization: Uses rsync with the --delete option to ensure your local directory exactly matches the repository Finalization: Sets executable permissions and cleans up temporary files","using-the-updated-scripts#Using the Updated Scripts":"After updating, you can use the scripts directly from your home directory. For example:\n# Run a specific script ~/scripts/entrypoint.sh tool_name_install # Or add to your PATH for easier access echo 'export PATH=\"$HOME/scripts:$PATH\"' \u003e\u003e ~/.bashrc source ~/.bashrc","using-the-utility#Using the Utility":"","what-this-utility-does#What This Utility Does":"The utility performs several operations to update your local scripts directory:\nCreates a scripts directory in your home folder if it doesn‚Äôt exist Downloads the latest scripts from the RF-Swift-images GitHub repository Synchronizes the files to your local directory, adding new files and updating existing ones Sets proper permissions on the scripts to make them executable Cleans up any temporary files used during the update process","what-to-expect#What to Expect":"When you run the utility, you‚Äôll see a series of colored messages indicating the progress:\nYellow text: Indicates the creation of new directories (if needed) Blue text: Shows progress information as files are downloaded and copied Red text: Alerts you to any errors (hopefully you won‚Äôt see these) Green text: Confirms successful completion of the update Example output:\nFetching file list from https://github.com/PentHertz/RF-Swift-images Updating scripts in /home/user/scripts sending incremental file list ./ automotive_software.sh cal_devices.sh common.sh corebuild.sh entrypoint.sh gr_oot_modules.sh lab_software.sh reverse_software.sh ... Cleaning up temporary files Update completed successfully.","when-to-use-this-utility#When to Use This Utility":"Use the update_rfscripts utility:\nAfter a new RF Swift release to get the latest scripts When you need access to newly added tools If you suspect your scripts might be outdated Before starting a new RF assessment to ensure you have the latest capabilities","where-scripts-are-installed#Where Scripts Are Installed":"The utility installs all scripts to the scripts directory in your home folder:\n~/scripts/"},"title":"RF Scripts Update Utility"},"/docs/development/":{"data":{"community-resources#Community Resources":"Join the RF Swift community to get help with development:\nDiscord: Join our Discord server GitHub Issues: Report bugs or request features Documentation: Refer to the API Reference (coming soon) üöß Additional development documentation is being actively created. We welcome contributions to the documentation, especially for specialized development scenarios and custom image recipes.","cross-platform-development#Cross-Platform Development":"RF Swift supports multiple platforms and architectures. When developing:\nTest on multiple operating systems when possible Use BuildX for cross-platform container builds Consider architecture-specific optimizations for ARM64 and RISC-V The YAML build system automatically handles multi-architecture builds when BuildX is configured","development-environment-setup#Development Environment Setup":"Before diving into RF Swift development, ensure your environment meets these prerequisites:","getting-started-with-development#Getting Started with Development":"RF Swift is designed to be extensible and customizable. You can tailor it to your specific RF assessment needs by:\nCompiling the binary from source with custom features or for specific architectures Building custom container images with specialized tools using the simplified YAML recipe format Contributing to the core project by adding new features or fixing issues","key-development-areas#Key Development Areas":"Compile RF Swift BinaryBuild the RF Swift binary from source for different platforms and architectures YAML Recipe GuideCreate custom container images using simple, readable YAML recipes without Dockerfile complexity Building Custom ImagesAdvanced Docker image creation with Dockerfiles and multi-stage builds","prerequisites#Prerequisites":"Go 1.20+: Required for compiling the RF Swift binary Docker: Required for building and testing container images BuildX: Required for cross-platform image building Git: Required for source code management","quick-example#Quick Example":"Create a custom image with just a YAML recipe file:\n# my-custom-image.yaml base_image: \"ubuntu:24.04\" tag: \"my-custom-sdr:latest\" packages: - rtl-sdr - hackrf - gqrx-sdr python_packages: - numpy - scipy run_commands: - \"echo 'Custom image ready!'\" Build it with a single command:\nrfswift build -r my-custom-image.yaml This approach makes it much easier to:\nüöÄ Quickly prototype new image configurations üìù Share recipes with the community üîÑ Version control your image definitions üõ†Ô∏è Customize existing images without Dockerfile knowledge See the Building Custom Images section for detailed information about the YAML recipe format and advanced features.","rf-swift-development-guide#RF Swift Development Guide":"RF Swift Development GuideThis section covers topics related to developing with RF Swift, building custom components, and contributing to the project. Whether you want to compile the RF Swift binary from source, create custom container images using the new YAML build system, or extend the project‚Äôs capabilities, you‚Äôll find the necessary guidance here.","simplified-image-building-with-yaml-recipes#Simplified Image Building with YAML Recipes":"RF Swift now includes a powerful YAML-based build system that simplifies the process of creating custom images. Instead of writing complex Dockerfiles, you can define your image requirements in a simple, readable YAML format."},"title":"üßë‚Äçüç≥ Development"},"/docs/development/building-images/":{"data":{"-advanced-usage#üîß Advanced Usage":"","-best-practices#üí° Best Practices":"","-complete-function-reference-table#üß† Complete Function Reference Table":"Category Function Retry Logic Logging Exit on Error Output colorecho No Console No Output goodecho No Console No Output criticalecho No Console Yes Output criticalecho-noexit No Console No Install installfromnet Yes (5√ó) Console Yes (on failure) Install install_dependencies Yes (implicit) apt logs Yes (on failure) Install check_and_install_lib Yes (implicit) Console + apt Yes (on failure) Python pip3install Yes (5√ó) pip logs Yes (on failure) Git gitinstall No Console + DB Yes (on failure) Build cmake_clone_and_build No Console + DB Yes (on failure) Build grclone_and_build No Console + DB Yes (on failure)","-git-and-source-management#üß¨ Git and Source Management":"","-output--logging-functions#üé® Output \u0026amp; Logging Functions":"These functions provide consistent, colored output for different message types during container builds.","-package-installation-helpers#üì¶ Package Installation Helpers":"","-python-package-management#üêç Python Package Management":"","-related-documentation#üìö Related Documentation":"Build Custom ImagesUse these helpers in your YAML recipes and Dockerfiles System ConfigurationConfigure RF Swift for your hardware Contribute on GitHubImprove or extend these helper functions","-troubleshooting#üÜò Troubleshooting":"","-yaml-vs-dockerfile-when-to-use-each#üìã YAML vs Dockerfile: When to Use Each":"","check_and_install_lib-lib-name-pkg-config-name#\u003ccode\u003echeck_and_install_lib \u0026lt;lib-name\u0026gt; \u0026lt;pkg-config-name\u0026gt;\u003c/code\u003e":"Checks if a library is installed using pkg-config. If not found, installs it via apt-fast.\nParameters:\nlib-name: Debian package name pkg-config-name: Name used by pkg-config (usually without -dev suffix) Usage:\n# Check for libusb check_and_install_lib \"libusb-1.0-0-dev\" \"libusb-1.0\" # Check for FFTW check_and_install_lib \"libfftw3-dev\" \"fftw3\" # Check for OpenSSL check_and_install_lib \"libssl-dev\" \"openssl\" Behavior:\n# If library is found: [INFO] libusb-1.0 is already installed # If library is not found: [INFO] libusb-1.0 not found, installing libusb-1.0-0-dev... [SUCCESS] libusb-1.0-0-dev installed successfully Real-world example:\n# Checking multiple libraries before building from source check_and_install_lib \"libusb-1.0-0-dev\" \"libusb-1.0\" check_and_install_lib \"libfftw3-dev\" \"fftw3\" check_and_install_lib \"libpython3-dev\" \"python3\" # Now safe to build cd my-project mkdir build \u0026\u0026 cd build cmake .. make -j$(nproc) When to use:\nBefore building software from source Creating conditional builds based on available libraries Avoiding redundant package installations Validating build prerequisites","cmake_clone_and_build-repo-url-build-dir-branch-reset-commit-method-cmake-args#\u003ccode\u003ecmake_clone_and_build \u0026lt;repo-url\u0026gt; \u0026lt;build-dir\u0026gt; \u0026lt;branch\u0026gt; \u0026lt;reset-commit\u0026gt; \u0026lt;method\u0026gt; [cmake-args...]\u003c/code\u003e":"All-in-one function that clones a repository and builds it using CMake in a single command.\nParameters:\nrepo-url: Git repository URL build-dir: Build directory path relative to repository root branch: Branch/tag to checkout (use \"\" for default) reset-commit: Specific commit/tag to reset to (use \"\" to skip) method: Installation method name for logging [cmake-args...]: Additional CMake arguments Usage:\n# Simple build with default settings cmake_clone_and_build \\ \"https://github.com/osmocom/rtl-sdr.git\" \\ \"build\" \\ \"\" \\ \"\" \\ \"rtlsdr_install\" # Build specific version with custom options cmake_clone_and_build \\ \"https://github.com/gnuradio/gnuradio.git\" \\ \"build\" \\ \"v3.10.5.0\" \\ \"v3.10.5.0\" \\ \"gnuradio_install\" \\ -DENABLE_GR_QTGUI=ON \\ -DENABLE_PYTHON=ON \\ -DPYTHON_EXECUTABLE=/usr/bin/python3 # Build with custom install prefix cmake_clone_and_build \\ \"https://github.com/mossmann/hackrf.git\" \\ \"host/build\" \\ \"master\" \\ \"\" \\ \"hackrf_install\" \\ -DCMAKE_INSTALL_PREFIX=/opt/hackrf Process Flow:\nClones repository (or pulls if exists) Checkouts specified branch Resets to specific commit if specified Initializes submodules Creates build directory Runs CMake with provided arguments Compiles with make -j$(nproc) Installs with make install Runs ldconfig Logs to metadata database Real-world examples:\nYAML Recipe - Simple SDR Library:\nbase_image: \"ubuntu:24.04\" tag: \"rtlsdr:latest\" packages: - cmake - build-essential - libusb-1.0-0-dev run_commands: - \"cmake_clone_and_build 'https://github.com/osmocom/rtl-sdr.git' 'build' 'master' '' 'rtlsdr_install' -DINSTALL_UDEV_RULES=ON -DDETACH_KERNEL_DRIVER=ON\" YAML Recipe - Complex Build with Multiple Options:\nbase_image: \"ubuntu:24.04\" tag: \"gnuradio:3.10\" packages: - cmake - g++ - libboost-all-dev - python3-dev - swig run_commands: - | cmake_clone_and_build \\ 'https://github.com/gnuradio/gnuradio.git' \\ 'build' \\ 'v3.10' \\ '' \\ 'gnuradio_install' \\ -DCMAKE_BUILD_TYPE=Release \\ -DENABLE_GR_QTGUI=ON \\ -DENABLE_GR_UHD=ON \\ -DENABLE_PYTHON=ON \\ -DPYTHON_EXECUTABLE=/usr/bin/python3 Bash - Example 1: Simple SDR Library\ncmake_clone_and_build \\ \"https://github.com/osmocom/rtl-sdr.git\" \\ \"build\" \\ \"master\" \\ \"\" \\ \"rtlsdr_install\" \\ -DINSTALL_UDEV_RULES=ON \\ -DDETACH_KERNEL_DRIVER=ON Bash - Example 2: Complex Build with Multiple Options\ncmake_clone_and_build \\ \"https://github.com/gnuradio/gnuradio.git\" \\ \"build\" \\ \"v3.10\" \\ \"\" \\ \"gnuradio_install\" \\ -DCMAKE_BUILD_TYPE=Release \\ -DENABLE_GR_QTGUI=ON \\ -DENABLE_GR_UHD=ON \\ -DENABLE_GR_AUDIO=ON \\ -DENABLE_GR_BLOCKS=ON \\ -DENABLE_GR_FFT=ON \\ -DENABLE_GR_FILTER=ON \\ -DENABLE_PYTHON=ON \\ -DPYTHON_EXECUTABLE=/usr/bin/python3 \\ -DENABLE_DOXYGEN=OFF \\ -DENABLE_SPHINX=OFF Bash - Example 3: Building Specific Tagged Release\n# Build exactly SDR++ version 1.1.0 cmake_clone_and_build \\ \"https://github.com/AlexandreRouma/SDRPlusPlus.git\" \\ \"build\" \\ \"1.1.0\" \\ \"1.1.0\" \\ \"sdrpp_install\" \\ -DOPT_BUILD_AIRSPY_SOURCE=ON \\ -DOPT_BUILD_AIRSPYHF_SOURCE=ON \\ -DOPT_BUILD_HACKRF_SOURCE=ON \\ -DOPT_BUILD_RTL_SDR_SOURCE=ON When to use:\nBuilding from source in a single command Reproducible builds with specific versions Complex CMake configurations Automated container image creation","colorecho-message#\u003ccode\u003ecolorecho \u0026lt;message\u0026gt;\u003c/code\u003e":"Prints a blue-colored informational message to stdout.\nUsage:\ncolorecho \"Starting installation process...\" colorecho \"Configuration phase complete\" Output:\n[INFO] Starting installation process... When to use:\nProgress updates during long operations Neutral informational messages Step indicators in complex builds","common-issues#Common Issues":"Issue: ‚ÄúCommand failed after 5 attempts‚Äù\n# Solution: Check network connectivity ping -c 3 github.com # Or use a mirror installfromnet \"git clone https://mirror.example.com/repo.git\" Issue: ‚ÄúLibrary not found by pkg-config‚Äù\n# Solution: Update pkg-config path export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH ldconfig # Then retry check_and_install_lib \"mylib-dev\" \"mylib\" Issue: ‚ÄúCMake configuration failed‚Äù\n# Solution: Install missing dependencies first install_dependencies \"cmake g++ libboost-all-dev\" # Check CMake version cmake --version # Should be 3.16+ # Then retry build cmake_clone_and_build [...] üí° Pro Tip: All helper functions are defined in images/scripts/common.sh. You can extend them or create new ones for your specific needs!","complete-build-workflow---bash-script#Complete Build Workflow - Bash Script":"# Complete installation workflow colorecho \"Installing HackRF support...\" # Install system dependencies install_dependencies \"libusb-1.0-0-dev libfftw3-dev\" # Install Python dependencies pip3install numpy pyusb # Clone and build cmake_clone_and_build \\ \"https://github.com/mossmann/hackrf.git\" \\ \"host/build\" \\ \"master\" \\ \"\" \\ \"hackrf_install\" \\ -DINSTALL_UDEV_RULES=ON goodecho \"HackRF installation complete!\"","complete-build-workflow---yaml-recipe#Complete Build Workflow - YAML Recipe":"# hackrf-tools.yaml - Complete HackRF installation base_image: \"ubuntu:24.04\" tag: \"hackrf:latest\" # System packages packages: - libusb-1.0-0-dev - libfftw3-dev - build-essential - cmake - git # Python packages python_packages: - numpy - pyusb # Build from source run_commands: - \"colorecho 'Installing HackRF support...'\" - \"cmake_clone_and_build 'https://github.com/mossmann/hackrf.git' 'host/build' 'master' '' 'hackrf_install' -DINSTALL_UDEV_RULES=ON\" - \"goodecho 'HackRF installation complete!'\" Build it with:\nrfswift build -r hackrf-tools.yaml","conditional-builds#Conditional Builds":"# Build different components based on architecture if [ \"$(uname -m)\" = \"aarch64\" ]; then colorecho \"Building for ARM64\" cmake_clone_and_build \\ \"https://github.com/example/arm-optimized.git\" \\ \"build\" \\ \"arm64\" \\ \"\" \\ \"arm_build\" \\ -DARM_NEON=ON else colorecho \"Building for x86_64\" cmake_clone_and_build \\ \"https://github.com/example/x86-optimized.git\" \\ \"build\" \\ \"master\" \\ \"\" \\ \"x86_build\" \\ -DAVX2=ON fi","criticalecho-message#\u003ccode\u003ecriticalecho \u0026lt;message\u0026gt;\u003c/code\u003e":"Prints a red-colored error message to stderr and exits with code 1.\nUsage:\nif [ ! -f \"required_file.txt\" ]; then criticalecho \"Required file not found!\" fi Output:\n[ERROR] Required file not found! When to use:\nUnrecoverable errors that should stop the build Missing critical dependencies Failed validation checks Important: criticalecho will terminate the build process. Use criticalecho-noexit if you need to log errors without stopping execution.","criticalecho-noexit-message#\u003ccode\u003ecriticalecho-noexit \u0026lt;message\u0026gt;\u003c/code\u003e":"Prints a red-colored error message to stderr without exiting.\nUsage:\nif ! some_optional_operation; then criticalecho-noexit \"Optional feature installation failed, continuing...\" fi Output:\n[ERROR] Optional feature installation failed, continuing... When to use:\nNon-critical errors that allow continued execution Warning about missing optional features Logging errors while attempting fallback solutions","custom-retry-logic#Custom Retry Logic":"# Wrap any command with custom retry logic retry_custom() { local max_attempts=10 local delay=5 local command=\"$1\" for i in $(seq 1 $max_attempts); do if eval \"$command\"; then return 0 fi colorecho \"Attempt $i failed, retrying in ${delay}s...\" sleep $delay done criticalecho \"Command failed after $max_attempts attempts\" } # Usage retry_custom \"wget https://unstable-mirror.example.com/file.tar.gz\"","dockerfile-integration-traditional#Dockerfile Integration (Traditional)":"For advanced users who prefer Dockerfiles:\nFROM ubuntu:24.04 # Copy helper scripts COPY scripts/common.sh /tmp/ RUN chmod +x /tmp/common.sh \u0026\u0026 \\ . /tmp/common.sh \u0026\u0026 \\ install_dependencies \"build-essential cmake git\" \u0026\u0026 \\ cmake_clone_and_build \\ \"https://github.com/osmocom/rtl-sdr.git\" \\ \"build\" \\ \"master\" \\ \"\" \\ \"rtlsdr_install\" \\ -DINSTALL_UDEV_RULES=ON \u0026\u0026 \\ rm -rf /tmp/*","error-handling#Error Handling":"# Check prerequisites before proceeding check_and_install_lib \"libusb-1.0-0-dev\" \"libusb-1.0\" || { criticalecho \"Failed to install libusb\" } # Optional feature installation if ! pip3install optional-package 2\u003e/dev/null; then criticalecho-noexit \"Optional package not available\" fi","gitinstall-repo-url-method-branch#\u003ccode\u003egitinstall \u0026lt;repo-url\u0026gt; \u0026lt;method\u0026gt; \u0026lt;branch\u0026gt;\u003c/code\u003e":"Clones or updates a Git repository with automatic tracking and metadata logging.\nParameters:\nrepo-url: Full HTTPS or SSH URL to Git repository method: Installation method name (used for logging/tracking) branch: Git branch, tag, or commit to checkout (optional, defaults to default branch) Usage:\n# Clone default branch gitinstall \"https://github.com/osmocom/rtl-sdr.git\" \"rtlsdr_install\" # Clone specific branch gitinstall \"https://github.com/mossmann/hackrf.git\" \"hackrf_install\" \"master\" # Clone specific tag gitinstall \"https://github.com/gnuradio/gnuradio.git\" \"gnuradio_install\" \"v3.10.5.0\" Features:\nAutomatically initializes and updates submodules Logs repository metadata to /var/lib/db/rfswift_github.lst Records: method name, repository URL, commit hash, branch, clone date If repository exists, pulls latest changes instead of re-cloning Handles shallow clones and full clones appropriately Metadata Logging: The function creates an entry in /var/lib/db/rfswift_github.lst:\nrtlsdr_install|https://github.com/osmocom/rtl-sdr.git|a1b2c3d4e5f6|master|2024-01-12 Real-world examples:\nExample 1: Installing RTL-SDR\ngitinstall \"https://github.com/osmocom/rtl-sdr.git\" \"rtlsdr_install\" cd rtl-sdr mkdir build \u0026\u0026 cd build cmake ../ -DINSTALL_UDEV_RULES=ON -DDETACH_KERNEL_DRIVER=ON make -j$(nproc) make install ldconfig Example 2: GNU Radio OOT Module\ngitinstall \"https://github.com/osmocom/gr-osmosdr.git\" \"gr_osmosdr_install\" \"master\" cd gr-osmosdr mkdir build \u0026\u0026 cd build cmake .. make -j$(nproc) make install ldconfig Example 3: Multiple Related Repositories\n# Install entire SDR suite gitinstall \"https://github.com/osmocom/rtl-sdr.git\" \"rtlsdr_install\" gitinstall \"https://github.com/mossmann/hackrf.git\" \"hackrf_install\" gitinstall \"https://github.com/greatscottgadgets/ubertooth.git\" \"ubertooth_install\" # Build each one for repo in rtl-sdr hackrf ubertooth; do cd $repo mkdir -p build \u0026\u0026 cd build cmake .. make -j$(nproc) make install cd ../.. done ldconfig When to use:\nCloning source code for compilation Tracking which repositories are in the container Keeping source code for future reference Enabling reproducible builds","goodecho-message#\u003ccode\u003egoodecho \u0026lt;message\u0026gt;\u003c/code\u003e":"Prints a green-colored success message to stdout.\nUsage:\ngoodecho \"Installation completed successfully!\" goodecho \"All tests passed\" Output:\n[SUCCESS] Installation completed successfully! When to use:\nConfirmation of successful operations Completion messages Positive status updates","grclone_and_build-repo-url-subdir-method--b-branch-cmake-args#\u003ccode\u003egrclone_and_build \u0026lt;repo-url\u0026gt; \u0026lt;subdir\u0026gt; \u0026lt;method\u0026gt; [-b branch] [cmake-args...]\u003c/code\u003e":"Simplified wrapper optimized for GNU Radio Out-of-Tree (OOT) modules.\nParameters:\nrepo-url: Git repository URL subdir: Subdirectory containing the source (usually same as repo name) method: Installation method name for logging -b branch: Optional branch flag (if omitted, uses default branch) [cmake-args...]: Additional CMake arguments Usage:\n# Simple GNU Radio module grclone_and_build \\ \"https://github.com/osmocom/gr-osmosdr.git\" \\ \"gr-osmosdr\" \\ \"gr_osmosdr_install\" # With specific branch grclone_and_build \\ \"https://github.com/osmocom/gr-gsm.git\" \\ \"gr-gsm\" \\ \"gr_gsm_install\" \\ -b master # With custom CMake options grclone_and_build \\ \"https://github.com/greatscottgadgets/gr-bluetooth.git\" \\ \"gr-bluetooth\" \\ \"gr_bluetooth_install\" \\ -DENABLE_DOXYGEN=OFF \\ -DENABLE_TESTING=OFF Real-world examples:\nExample 1: Building Multiple GNU Radio Modules\n# Build common GNU Radio OOT modules grclone_and_build \\ \"https://github.com/osmocom/gr-osmosdr.git\" \\ \"gr-osmosdr\" \\ \"gr_osmosdr_install\" grclone_and_build \\ \"https://github.com/osmocom/gr-gsm.git\" \\ \"gr-gsm\" \\ \"gr_gsm_install\" grclone_and_build \\ \"https://github.com/ptrkrysik/gr-lte.git\" \\ \"gr-lte\" \\ \"gr_lte_install\" Example 2: Building with Dependencies Check\n# Ensure GNU Radio is installed first if ! pkg-config --exists gnuradio-runtime; then criticalecho \"GNU Radio must be installed first!\" fi # Now build OOT modules grclone_and_build \\ \"https://github.com/osmocom/gr-iqbal.git\" \\ \"gr-iqbal\" \\ \"gr_iqbal_install\" grclone_and_build \\ \"https://github.com/osmocom/gr-fosphor.git\" \\ \"gr-fosphor\" \\ \"gr_fosphor_install\" \\ -DENABLE_GLFW=ON \\ -DENABLE_QT=ON When to use:\nInstalling GNU Radio OOT modules Building SDR-related GNU Radio blocks Creating RF signal processing containers Extending GNU Radio capabilities","install_dependencies-packages#\u003ccode\u003einstall_dependencies \u0026quot;\u0026lt;packages\u0026gt;\u0026quot;\u003c/code\u003e":"Installs Debian/Ubuntu packages using apt-fast (a parallel apt wrapper) with automatic retry logic.\nParameters:\npackages: Space-separated list of package names (must be quoted) Usage:\nIn YAML recipes (recommended):\nbase_image: \"ubuntu:24.04\" tag: \"gnuradio-image:latest\" packages: - python3-numpy - python3-scipy - g++ - cmake - libusb-1.0-0-dev - libfftw3-dev - libboost-all-dev In Bash/Dockerfiles:\n# Single package install_dependencies \"python3-numpy\" # Multiple packages install_dependencies \"python3-numpy python3-scipy g++ cmake\" # Development libraries install_dependencies \"libusb-1.0-0-dev libfftw3-dev libboost-all-dev\" Features:\nAutomatically runs apt-get update if needed Uses apt-fast for parallel downloads (faster than standard apt) Retries on network failures Logs installed packages for tracking Real-world example:\nYAML Recipe - Complete GNU Radio Environment:\nbase_image: \"ubuntu:24.04\" tag: \"gnuradio:latest\" packages: - git - cmake - g++ - libboost-all-dev - libgmp-dev - swig - python3-numpy - python3-mako - python3-sphinx - python3-lxml - doxygen - libfftw3-dev - libsdl1.2-dev - libgsl-dev - libqwt-qt5-dev - libqt5opengl5-dev - python3-pyqt5 - liblog4cpp5-dev - libzmq3-dev - python3-yaml - python3-click - python3-click-plugins - python3-zmq - python3-scipy - python3-gi - python3-gi-cairo - gobject-introspection - gir1.2-gtk-3.0 run_commands: - \"echo 'GNU Radio dependencies installed'\" Bash - Installing dependencies for GNU Radio:\n# Installing dependencies for GNU Radio install_dependencies \"git cmake g++ libboost-all-dev libgmp-dev \\ swig python3-numpy python3-mako python3-sphinx python3-lxml \\ doxygen libfftw3-dev libsdl1.2-dev libgsl-dev libqwt-qt5-dev \\ libqt5opengl5-dev python3-pyqt5 liblog4cpp5-dev libzmq3-dev \\ python3-yaml python3-click python3-click-plugins python3-zmq \\ python3-scipy python3-gi python3-gi-cairo gobject-introspection \\ gir1.2-gtk-3.0\" When to use:\nInstalling system libraries Setting up build environments Adding runtime dependencies Installing development tools","installfromnet-command#\u003ccode\u003einstallfromnet \u0026lt;command\u0026gt;\u003c/code\u003e":"Executes a shell command up to 5 times with 15-second intervals between attempts. Essential for handling network instability during builds.\nParameters:\ncommand: Any shell command (wrapped in quotes if it contains spaces) Usage:\n# Simple download installfromnet \"wget http://example.com/tool.tar.gz\" # Git clone installfromnet \"git clone https://github.com/user/repo.git\" # Complex command with pipes installfromnet \"curl -L https://example.com/install.sh | bash\" In YAML recipes:\nbase_image: \"ubuntu:24.04\" tag: \"my-custom-image:latest\" run_commands: - \"installfromnet 'wget http://example.com/tool.tar.gz'\" - \"installfromnet 'git clone https://github.com/user/repo.git'\" In Dockerfiles:\nRUN . /tmp/common.sh \u0026\u0026 \\ installfromnet \"wget http://example.com/tool.tar.gz\" \u0026\u0026 \\ tar xzf tool.tar.gz Behavior:\nAttempt 1: Executes immediately Attempts 2-5: Wait 15 seconds between each retry Success: Continues to next command All attempts fail: Build fails with error message Real-world example:\n# Building RTL-SDR using the cmake_clone_and_build helper # This automatically handles download retries, build, and installation cmake_clone_and_build \\ \"https://github.com/osmocom/rtl-sdr.git\" \\ \"build\" \\ \"v0.6.0\" \\ \"v0.6.0\" \\ \"rtlsdr_install\" \\ -DINSTALL_UDEV_RULES=ON \\ -DDETACH_KERNEL_DRIVER=ON # Much simpler than manual download/build/install! When to use:\nAny network operation (wget, curl, git clone) Downloading from mirrors that might be temporarily unavailable Building from source that requires fetching remote dependencies","layer-optimization#Layer Optimization":"YAML (Automatic Optimization):\n# YAML recipes automatically optimize layers base_image: \"ubuntu:24.04\" tag: \"optimized:latest\" packages: - pkg1 - pkg2 - pkg3 python_packages: - package1 - package2 run_commands: - \"cmake_clone_and_build [...]\" # Cleanup is handled automatically Dockerfile (Manual Optimization):\n# Good: Single RUN command with multiple operations RUN . /tmp/common.sh \u0026\u0026 \\ install_dependencies \"pkg1 pkg2 pkg3\" \u0026\u0026 \\ pip3install package1 package2 \u0026\u0026 \\ cmake_clone_and_build [...] \u0026\u0026 \\ rm -rf /tmp/* /var/lib/apt/lists/* # Bad: Multiple RUN commands (creates more layers) RUN install_dependencies \"pkg1\" RUN pip3install package1 RUN cmake_clone_and_build [...]","metadata-queries#Metadata Queries":"# List all installed GitHub repositories cat /var/lib/db/rfswift_github.lst # Find specific installation grep \"rtlsdr_install\" /var/lib/db/rfswift_github.lst # Extract commit hash awk -F'|' '/rtlsdr_install/ {print $3}' /var/lib/db/rfswift_github.lst","pip3install-args#\u003ccode\u003epip3install \u0026lt;args\u0026gt;\u003c/code\u003e":"Installs Python packages using pip3 with automatic retry logic and proper error handling.\nParameters:\nargs: Any valid pip install arguments Usage:\nIn YAML recipes (recommended):\nbase_image: \"ubuntu:24.04\" tag: \"sdr-tools:latest\" python_packages: - numpy - scipy - matplotlib - pyrtlsdr - \"gnuradio==3.10.5.0\" # Specific version In Bash/Dockerfiles:\n# Single package pip3install numpy # Specific version pip3install \"scipy==1.9.0\" # From requirements file pip3install -r requirements.txt # From git repository pip3install git+https://github.com/user/python-package.git # With extras pip3install \"matplotlib[all]\" # Editable install pip3install -e . Features:\nRetries on network failures (up to 5 attempts) Uses --break-system-packages flag for container environments Logs installed packages Handles timeout errors gracefully Real-world examples:\nExample 1: Data Science Stack\npip3install numpy pip3install scipy pip3install matplotlib pip3install pandas pip3install scikit-learn Example 2: RF Signal Processing\npip3install numpy scipy pip3install gnuradio pip3install pyrtlsdr pip3install pySoapySDR Example 3: Requirements File\n# Create requirements.txt cat \u003e requirements.txt \u003c\u003c EOF numpy\u003e=1.21.0 scipy\u003e=1.7.0 matplotlib\u003e=3.4.0 pyserial\u003e=3.5 EOF # Install all at once pip3install -r requirements.txt Example 4: Installing from GitHub\n# Install latest development version pip3install git+https://github.com/mossmann/hackrf.git@master#subdirectory=host/libhackrf/python # Install specific commit pip3install git+https://github.com/osmocom/pyosmo-sdr@a1b2c3d When to use:\nInstalling Python dependencies for tools Setting up Python-based SDR software Installing signal processing libraries Adding scripting capabilities to containers Best Practice: For reproducible builds, always specify package versions in production images:\npip3install \"numpy==1.24.0\" \"scipy==1.10.0\"","rf-swift-helper-functions-reference#RF Swift Helper Functions Reference":"RF Swift Helper Functions ReferenceThis page documents the Bash helper functions used in the RF Swift container build system. These utilities simplify logging, dependency management, source code builds, and network operations.\nMost helpers implement retry logic and consistent logging to ensure resilience and ease of use when building custom images or tools.\nNew! These helper functions can now be used in both YAML recipe files and traditional Dockerfiles, making custom image creation easier than ever!","use-dockerfiles-when#Use Dockerfiles When:":"‚öôÔ∏è You need fine-grained control over build process ‚öôÔ∏è You‚Äôre implementing complex multi-stage builds ‚öôÔ∏è You need custom base image configurations ‚öôÔ∏è You‚Äôre integrating with existing Docker workflows ‚öôÔ∏è You need advanced Docker features (HEALTHCHECK, STOPSIGNAL, etc.) Example:\nFROM ubuntu:24.04 AS builder RUN . /tmp/common.sh \u0026\u0026 build_tools... FROM ubuntu:24.04 COPY --from=builder /usr/local /usr/local Recommendation: Start with YAML recipes for most use cases. Switch to Dockerfiles only when you need advanced features not supported by YAML.","use-yaml-recipes-when#Use YAML Recipes When:":"‚úÖ You want simple, readable configurations ‚úÖ You‚Äôre building standard SDR/RF tool containers ‚úÖ You need quick prototyping ‚úÖ You want automatic layer optimization ‚úÖ You‚Äôre sharing configurations with the community ‚úÖ You need cross-platform builds automatically configured Example:\nbase_image: \"ubuntu:24.04\" tag: \"my-sdr:latest\" packages: - rtl-sdr - hackrf python_packages: - numpy - scipy run_commands: - \"echo 'Build complete!'\"","yaml-recipe-integration-recommended#YAML Recipe Integration (Recommended)":"The easiest way to use helper functions is through YAML recipes:\nbase_image: \"ubuntu:24.04\" tag: \"rtlsdr:latest\" packages: - build-essential - cmake - git run_commands: - \"install_dependencies 'libusb-1.0-0-dev'\" - \"cmake_clone_and_build 'https://github.com/osmocom/rtl-sdr.git' 'build' 'master' '' 'rtlsdr_install' -DINSTALL_UDEV_RULES=ON\" Build with:\nrfswift build -r my-image.yaml"},"title":"Helper Functions Reference"},"/docs/development/compiling-rfswift/":{"data":{"build-using-installation-scripts#Build Using Installation Scripts":"RF Swift provides platform-specific scripts to handle the entire build process:","building-rf-swift-from-source#Building RF Swift from Source":"Building RF Swift from SourceThis guide explains how to compile RF Swift from source code, allowing you to customize the binary, contribute to development, or build for specific architectures.","clone-the-repository#Clone the Repository":"First, clone the RF Swift source code from the official repository:\ngit clone https://github.com/PentHertz/RF-Swift.git cd RF-Swift","compilation-process#Compilation Process":"","compile-the-binary#Compile the Binary":"Navigate to the cloned repository and compile the binary:\ncd RF-Swift go build -o rfswift For cross-compilation (building for a different architecture):\n# For ARM64 (e.g., Raspberry Pi) GOOS=linux GOARCH=arm64 go build -o rfswift_arm64 # For Windows GOOS=windows GOARCH=amd64 go build -o rfswift.exe # For macOS GOOS=darwin GOARCH=amd64 go build -o rfswift_macos","configure-your-installation#Configure Your Installation":"During installation, you‚Äôll be prompted with several configuration options:\nDo you want to create an alias for the binary? (yes/no): yes Creating an alias allows you to run RF Swift from any directory using the rfswift command.\nAfter compilation completes, you‚Äôll be asked whether to build or pull container images:\nDocker is already installed. Moving on. Docker Buildx is already installed. Moving on. Docker Compose v2 is already installed. Moving on. [+] Installing Go golang is already installed in /usr/local/go/bin. Moving on. [+] Building RF Swift Go Project RF Swift Go Project built successfully. Do you want to build a Docker container, pull an existing image, or exit? 1) Build Docker container 2) Pull Docker image 3) Exit Choose an option (1, 2, or 3): You can choose to:\nBuild a custom container image (option 1) Pull an existing pre-built image from the repository (option 2) Exit and handle images later (option 3) You can always build or pull images later using the RF Swift command-line interface.","create-and-run-a-container#Create and Run a Container":"To create and run a container using an image:\n# With sudo (Linux without Docker Desktop) sudo rfswift run -i penthertz/rfswift_noble:sdr_full -n my_sdr_container # Without sudo (macOS, Windows, or Linux with Docker Desktop) rfswift run -i penthertz/rfswift_noble:sdr_full -n my_sdr_container","dependency-version-conflicts#Dependency Version Conflicts":"# Force use of specific versions in go.mod go mod edit -require=github.com/some/dependency@v1.2.3 go mod tidy","docker-permissions#Docker Permissions":"# Add your user to the docker group sudo usermod -aG docker $USER # Log out and back in for changes to take effect","go-module-issues#Go Module Issues":"# Reset the Go module cache go clean -modcache # Try building again go build -o rfswift","install-dependencies#Install Dependencies":"First, ensure you have all required dependencies:\n# Ubuntu/Debian sudo apt update sudo apt install -y git golang-go docker.io # Fedora/CentOS/RHEL sudo dnf install -y git golang docker # Arch Linux sudo pacman -S git go docker # macOS (using Homebrew) brew install go docker","install-the-binary#Install the Binary":"Move the compiled binary to a location in your PATH:\n# Linux/macOS sudo mv rfswift /usr/local/bin/ sudo chmod +x /usr/local/bin/rfswift # Or for local user only mv rfswift ~/bin/ chmod +x ~/bin/rfswift","linuxmacos#Linux/macOS":"Use the install.sh script which handles all dependencies and compilation:\n./install.sh The script will:\nCheck for and install required dependencies (Docker, BuildX, Go) Compile the RF Swift binary for your architecture Offer to create a system-wide alias for the rfswift command Provide options for building or pulling container images","manual-compilation#Manual Compilation":"If you prefer to handle the compilation process manually or need more control over the build, you can follow these steps:","next-steps#Next Steps":"Now that you have successfully compiled RF Swift, you can:\nBuild Custom ImagesCreate your own specialized container images with custom tools Getting StartedLearn how to use RF Swift with pre-built images User GuideExplore the complete RF Swift documentation","prerequisites#Prerequisites":"Before you begin, ensure your system has sufficient resources:\nAt least 2GB of RAM At least 4GB of free disk space Internet connection (for downloading dependencies) Administrator/root access for installation","resume-existing-containers#Resume Existing Containers":"To resume work with previously created containers:\nrfswift exec -c my_sdr_container","running-rf-swift#Running RF Swift":"After compiling RF Swift, you can start using it to manage containers:","special-platform-steam-deck#Special Platform: Steam Deck":"The Linux installation script includes special handling for Steam Deck:\n./install.sh [+] Checking Docker installation Are you installing on a Steam Deck? (yes/no): yes Selecting ‚Äúyes‚Äù will:\nUnlock Steam OS from read-only mode Configure Steam Deck-specific settings Install appropriate dependencies for the Steam Deck hardware","test-your-compilation#Test Your Compilation":"Once compiled, verify that your RF Swift binary works correctly:\n# If you created an alias rfswift --version # Or using the direct path ./rfswift --version This should display the version information and confirm the binary is functioning properly.","troubleshooting-compilation-issues#Troubleshooting Compilation Issues":"If you encounter issues during compilation:","windows#Windows":"For Windows systems, use the build-windows.bat script:\nbuild-windows.bat This script will set up the required dependencies and compile the RF Swift binary for Windows."},"title":"Compiling RF Swift from Source"},"/docs/development/yaml-recipe-guide/":{"data":{"-advanced-techniques#üéØ Advanced Techniques":"","-best-practices#‚úÖ Best Practices":"","-building-your-recipe#üõ†Ô∏è Building Your Recipe":"","-choosing-a-base-image#üé® Choosing a Base Image":"","-complete-examples#üìö Complete Examples":"","-custom-commands-run_commands#üîß Custom Commands (run_commands)":"The run_commands section executes bash commands during the build:","-package-management#üì¶ Package Management":"","-quick-start#üöÄ Quick Start":"","-recipe-library#üìñ Recipe Library":"","-troubleshooting#üêõ Troubleshooting":"","-yaml-recipe-structure#üìã YAML Recipe Structure":"","basic-build#Basic Build":"# Build with default settings rfswift build -r my-recipe.yaml # Build without cache (fresh build) rfswift build -r my-recipe.yaml --no-cache # Override tag from command line rfswift build -r my-recipe.yaml -t custom-tag:latest","build-options#Build Options":"rfswift build [options] Options: -r, --recipe string Path to YAML recipe file (default \"rfswift-recipe.yaml\") -t, --tag string Override tag from recipe --no-cache Build without using cache -h, --help Help for build command","build-process#Build Process":"When you run rfswift build -r recipe.yaml, RF Swift:\nValidates the YAML structure Generates an optimized Dockerfile Prepares the build context Executes the Docker build Tags the resulting image Cleans up temporary files","choosing-the-right-base#Choosing the Right Base":"Use Ubuntu 24.04 when:\n‚úÖ You want the latest packages and kernel support ‚úÖ Building general-purpose SDR containers ‚úÖ You need wide hardware compatibility ‚úÖ You‚Äôre new to RF Swift development Use Ubuntu 22.04 when:\n‚úÖ You need proven stability ‚úÖ Working with enterprise environments ‚úÖ Long-term support is critical Use Debian when:\n‚úÖ You prefer Debian‚Äôs package stability ‚úÖ You need minimal overhead beyond Ubuntu ‚úÖ Working in Debian-based infrastructure Use Alpine when:\n‚úÖ Image size is critical (\u003c50MB base) ‚ö†Ô∏è Warning: Limited RF library support, manual compilation often needed Architecture Note: Ensure your base image supports your target architecture (amd64, arm64, or riscv64). Use multi-arch images like ubuntu:24.04 which support multiple architectures.","common-issues#Common Issues":"Issue: ‚ÄúPackage not found‚Äù\n# Problem: Package name incorrect or not available packages: - rtl-sdr-tools # Wrong name # Solution: Use correct package name packages: - rtl-sdr Issue: ‚ÄúPython package install fails‚Äù\n# Problem: Missing system dependencies python_packages: - matplotlib # Needs system libraries # Solution: Install system dependencies first packages: - python3-dev - libfreetype6-dev - libpng-dev python_packages: - matplotlib Issue: ‚ÄúCommand not found in run_commands‚Äù\n# Problem: Helper functions not available run_commands: - \"cmake_clone_and_build ...\" # Fails # Solution: They're automatically available - check syntax run_commands: - | cmake_clone_and_build \\ 'https://...' \\ 'build' \\ 'master' \\ '' \\ 'install_name'","complete-field-reference#Complete Field Reference":"# Base configuration (required) base_image: \"ubuntu:24.04\" # Base Docker image tag: \"my-image:latest\" # Tag for the resulting image # Package management (optional) packages: # APT packages to install - package1 - package2-dev - package3 python_packages: # Python packages via pip - numpy - scipy==1.10.0 # Can specify versions - git+https://github.com/user/repo.git # From git # Custom commands (optional) run_commands: # Bash commands to execute - \"echo 'Starting build...'\" - \"mkdir -p /opt/tools\" - | cmake_clone_and_build \\ 'https://github.com/osmocom/rtl-sdr.git' \\ 'build' \\ 'master' \\ '' \\ 'rtlsdr_install' # Build context (optional) context: \".\" # Build context directory (default: \".\")","conditional-builds#Conditional Builds":"base_image: \"ubuntu:24.04\" tag: \"arch-specific:latest\" run_commands: # Build different components based on architecture - | if [ \"$(uname -m)\" = \"aarch64\" ]; then colorecho \"Building for ARM64...\" # ARM-specific optimizations else colorecho \"Building for x86_64...\" # x86-specific optimizations fi","debugging-builds#Debugging Builds":"# Build with verbose output docker build --progress=plain -t test:debug . # Check generated Dockerfile # (RF Swift generates it in /tmp during build) # Interactive debugging rfswift run -i ubuntu:24.04 -n debug # Manually test commands from recipe","documentation#Documentation":"Add comments to your recipes:\n# SDR Analysis Container v1.2 # Author: Your Name # Purpose: General purpose SDR analysis with RTL-SDR and HackRF support # Last updated: 2024-01-12 base_image: \"ubuntu:24.04\" tag: \"sdr-analysis:v1.2\" # Core SDR packages - tested with RTL-SDR V3 and HackRF One packages: - rtl-sdr - hackrf # Python stack for signal processing python_packages: - numpy\u003e=1.24.0 # Required for scipy - scipy\u003e=1.10.0 # Signal processing","environment-variables#Environment Variables":"base_image: \"ubuntu:24.04\" tag: \"custom-env:latest\" run_commands: # Set environment variables - \"echo 'export PATH=/opt/tools/bin:$PATH' \u003e\u003e /root/.bashrc\" - \"echo 'export LD_LIBRARY_PATH=/opt/tools/lib:$LD_LIBRARY_PATH' \u003e\u003e /root/.bashrc\" - \"echo 'export PYTHONPATH=/opt/tools/python:$PYTHONPATH' \u003e\u003e /root/.bashrc\"","example-1-simple-sdr-image#Example 1: Simple SDR Image":"Basic SDR tools for learning and experimentation:\nbase_image: \"ubuntu:24.04\" tag: \"sdr-beginner:latest\" packages: - rtl-sdr - gqrx-sdr - dump1090-mutability - multimon-ng python_packages: - numpy - matplotlib run_commands: - \"echo 'SDR tools ready!'\" Build: rfswift build -r sdr-beginner.yaml","example-2-gnu-radio-development-environment#Example 2: GNU Radio Development Environment":"Complete GNU Radio setup with OOT modules:\nbase_image: \"ubuntu:24.04\" tag: \"gnuradio-dev:3.10\" packages: # GNU Radio dependencies - git - cmake - g++ - libboost-all-dev - libgmp-dev - swig - python3-numpy - python3-mako - python3-sphinx - python3-lxml - doxygen - libfftw3-dev - libsdl1.2-dev - libgsl-dev - libqwt-qt5-dev - libqt5opengl5-dev - python3-pyqt5 - liblog4cpp5-dev - libzmq3-dev # Additional tools - vim - git - pkg-config python_packages: - numpy - scipy - matplotlib run_commands: # Build GNU Radio from source - \"colorecho 'Building GNU Radio 3.10...'\" - | cmake_clone_and_build \\ 'https://github.com/gnuradio/gnuradio.git' \\ 'build' \\ 'v3.10.9.2' \\ 'v3.10.9.2' \\ 'gnuradio_install' \\ -DCMAKE_BUILD_TYPE=Release \\ -DENABLE_GR_QTGUI=ON \\ -DENABLE_PYTHON=ON # Build gr-osmosdr - \"colorecho 'Building gr-osmosdr...'\" - | grclone_and_build \\ 'https://github.com/osmocom/gr-osmosdr.git' \\ 'gr-osmosdr' \\ 'gr_osmosdr_install' - \"goodecho 'GNU Radio environment ready!'\"","example-3-multi-sdr-hardware-support#Example 3: Multi-SDR Hardware Support":"Support for multiple SDR devices:\nbase_image: \"ubuntu:24.04\" tag: \"multi-sdr:latest\" packages: # Build essentials - build-essential - cmake - git - pkg-config - libusb-1.0-0-dev # Libraries - libfftw3-dev - libsoapysdr-dev # Pre-built tools - gqrx-sdr python_packages: - numpy - scipy - pyrtlsdr run_commands: # RTL-SDR - \"colorecho 'Installing RTL-SDR support...'\" - | cmake_clone_and_build \\ 'https://github.com/osmocom/rtl-sdr.git' \\ 'build' \\ 'master' \\ '' \\ 'rtlsdr_install' \\ -DINSTALL_UDEV_RULES=ON \\ -DDETACH_KERNEL_DRIVER=ON # HackRF - \"colorecho 'Installing HackRF support...'\" - | cmake_clone_and_build \\ 'https://github.com/mossmann/hackrf.git' \\ 'host/build' \\ 'master' \\ '' \\ 'hackrf_install' \\ -DINSTALL_UDEV_RULES=ON # Airspy - \"colorecho 'Installing Airspy support...'\" - | cmake_clone_and_build \\ 'https://github.com/airspy/airspyone_host.git' \\ 'build' \\ 'master' \\ '' \\ 'airspy_install' \\ -DINSTALL_UDEV_RULES=ON # LimeSDR (via SoapySDR) - \"colorecho 'Installing LimeSDR support...'\" - | cmake_clone_and_build \\ 'https://github.com/myriadrf/LimeSuite.git' \\ 'builddir' \\ 'master' \\ '' \\ 'limesdr_install' - \"goodecho 'All SDR devices supported!'\"","example-4-bluetooth-analysis-tools#Example 4: Bluetooth Analysis Tools":"Specialized Bluetooth security container:\nbase_image: \"ubuntu:24.04\" tag: \"bluetooth-tools:latest\" packages: # Bluetooth stack - bluez - bluez-tools - bluetooth - libbluetooth-dev # Build tools - build-essential - cmake - git - libusb-1.0-0-dev # Analysis tools - wireshark-common - tcpdump python_packages: - pybluez - scapy run_commands: # Ubertooth tools - \"colorecho 'Installing Ubertooth...'\" - | cmake_clone_and_build \\ 'https://github.com/greatscottgadgets/ubertooth.git' \\ 'host/build' \\ 'master' \\ '' \\ 'ubertooth_install' # Install additional Python tools - \"pip3install crackle\" - \"goodecho 'Bluetooth tools ready!'\"","example-5-rf-hacking-suite#Example 5: RF Hacking Suite":"Complete RF security assessment toolkit:\nbase_image: \"penthertz/rfswift_noble:core\" tag: \"rf-hacking:latest\" packages: # SDR tools - gqrx-sdr - inspectrum - urh # RF utilities - kalibrate-rtl - multimon-ng - dump1090-mutability # Analysis - wireshark - audacity python_packages: - numpy - scipy - matplotlib - jupyter - rfcat run_commands: # Universal Radio Hacker with dependencies - \"colorecho 'Setting up Universal Radio Hacker...'\" - \"pip3install pyqt5 numpy psutil cython\" # Install YardStick One tools - \"colorecho 'Installing RfCat for YardStick One...'\" - \"pip3install git+https://github.com/atlas0fd00m/rfcat.git\" # Create workspace - \"mkdir -p /root/rf-projects\" - \"goodecho 'RF Hacking suite ready!'\"","field-descriptions#Field Descriptions":"Field Type Required Description base_image String ‚úÖ Yes Base Docker image (e.g., ubuntu:24.04) tag String ‚úÖ Yes Name and tag for resulting image packages List ‚¨ú No APT/system packages to install python_packages List ‚¨ú No Python packages to install via pip run_commands List ‚¨ú No Custom bash commands to execute context String ‚¨ú No Build context directory (default: .)","multi-line-commands#Multi-line Commands":"Use YAML‚Äôs pipe (|) syntax for complex commands:\nrun_commands: - | echo \"Installing custom tool...\" cd /opt git clone https://github.com/user/tool.git cd tool make make install","multi-stage-builds-using-run_commands#Multi-stage Builds (Using run_commands)":"base_image: \"ubuntu:24.04\" tag: \"optimized-sdr:latest\" packages: - build-essential - cmake - libusb-1.0-0-dev run_commands: # Build in /tmp for cleanup - \"cd /tmp\" # Build RTL-SDR - | cmake_clone_and_build \\ 'https://github.com/osmocom/rtl-sdr.git' \\ 'build' \\ 'master' \\ '' \\ 'rtlsdr_install' # Cleanup to reduce image size - \"rm -rf /tmp/*\" - \"apt-get clean\" - \"rm -rf /var/lib/apt/lists/*\"","official-rf-swift-base-images#Official RF Swift Base Images":"Start from RF Swift‚Äôs optimized base images for best results:\n# Core RF Swift base (recommended) base_image: \"penthertz/rfswift_noble:core\" # Ubuntu Noble (24.04) - Latest LTS base_image: \"penthertz/rfswift_noble:base\" # Ubuntu Jammy (22.04) - Stable LTS base_image: \"ubuntu:22.04\"","organization#Organization":"# Good: Organized and commented base_image: \"ubuntu:24.04\" tag: \"my-sdr:v1.0\" packages: # Build dependencies - build-essential - cmake # SDR libraries - libusb-1.0-0-dev - libfftw3-dev # SDR tools - rtl-sdr - gqrx-sdr python_packages: # Scientific computing - numpy - scipy # SDR-specific - pyrtlsdr run_commands: - \"colorecho 'Build starting...'\" - \"goodecho 'Build complete!'\"","python-packages-pip#Python Packages (pip)":"The python_packages section installs Python packages:\npython_packages: # Basic scientific stack - numpy - scipy - matplotlib # Specific versions - \"pandas==2.0.0\" - \"scikit-learn\u003e=1.3.0\" # From git repositories - \"git+https://github.com/pyrtlsdr/pyrtlsdr.git\" - \"git+https://github.com/mossmann/hackrf.git@master#subdirectory=host/libhackrf/python\" # With extras - \"matplotlib[all]\" - \"jupyter[notebook]\" Version Specifications:\npython_packages: - \"package\" # Latest version - \"package==1.0.0\" # Exact version - \"package\u003e=1.0.0\" # Minimum version - \"package\u003e=1.0,\u003c2.0\" # Version range","share-on-github#Share on GitHub":"git init git add . git commit -m ‚ÄúInitial recipe collection‚Äù git remote add origin https://github.com/yourusername/rf-swift-recipes.git git push -u origin main\n### Community Recipes Browse community recipes: - [Official RF Swift Recipes](https://github.com/PentHertz/RF-Swift-Recipes) - Share your recipes on Discord - Contribute to the recipe library --- ## üîó Related Documentation Helper FunctionsComplete reference for all helper functions Compile RF SwiftBuild the RF Swift binary from source Official ImagesBrowse pre-built RF Swift images --- üí° Pro Tip: Start with a simple recipe and iterate. Build, test, refine. YAML recipes make experimentation fast and easy! ü§ù Contribute: Share your recipes with the community! Submit them to the RF Swift Recipe Repository or share on Discord.","sharing-recipes#Sharing Recipes":"Share your recipes with the community:\n# Create a recipe repository mkdir rf-swift-recipes cd rf-swift-recipes # Organize by category mkdir -p sdr bluetooth wifi automotive # Add README with usage instructions cat \u003e README.md \u003c\u003c 'EOF' # RF Swift Recipe Collection ## SDR Recipes - `sdr/rtlsdr-basic.yaml` - Basic RTL-SDR setup - `sdr/multi-hardware.yaml` - Multiple SDR support ## Usage ```bash rfswift build -r sdr/rtlsdr-basic.yaml EOF","simple-commands#Simple Commands":"run_commands: - \"echo 'Build starting...'\" - \"mkdir -p /opt/tools\" - \"useradd -m rfuser\" - \"chmod 755 /opt/tools\"","standard-base-images#Standard Base Images":"For building from scratch:\n# Ubuntu (recommended for RF tools) base_image: \"ubuntu:24.04\" # Noble Numbat (latest LTS) base_image: \"ubuntu:22.04\" # Jammy Jellyfish (stable) base_image: \"ubuntu:20.04\" # Focal Fossa (older but stable) # Debian (alternative) base_image: \"debian:bookworm\" # Debian 12 (latest stable) base_image: \"debian:bullseye\" # Debian 11 # Fedora (for cutting-edge packages) base_image: \"fedora:39\" # Alpine (for minimal images) base_image: \"alpine:3.19\" # Warning: May lack some RF libraries","system-packages-apt#System Packages (APT)":"The packages section installs system packages using apt:\npackages: # Development tools - build-essential - cmake - git - pkg-config # Libraries - libusb-1.0-0-dev - libfftw3-dev - libsoapysdr-dev # SDR tools - rtl-sdr - hackrf - gqrx-sdr - gnuradio # Utilities - wget - curl - vim Best Practices:\nGroup related packages together with comments Use -dev packages for libraries you‚Äôll compile against Include all build dependencies before compilation steps","testing#Testing":"# Build locally rfswift build -r test-recipe.yaml -t test:dev # Test the image rfswift run -i test:dev -n test-container # Verify tools work rfswift exec -c test-container","using-helper-functions#Using Helper Functions":"RF Swift provides powerful helper functions:\nrun_commands: # Colored output - \"colorecho 'Starting RTL-SDR installation...'\" # Install with retry logic - \"installfromnet 'git clone https://github.com/osmocom/rtl-sdr.git'\" # Build from source with CMake - | cmake_clone_and_build \\ 'https://github.com/osmocom/rtl-sdr.git' \\ 'build' \\ 'master' \\ '' \\ 'rtlsdr_install' \\ -DINSTALL_UDEV_RULES=ON # GNU Radio OOT modules - | grclone_and_build \\ 'https://github.com/osmocom/gr-osmosdr.git' \\ 'gr-osmosdr' \\ 'gr_osmosdr_install' # Success message - \"goodecho 'Installation complete!'\" See the Helper Functions Reference for complete documentation.","validation#Validation":"Before building, validate your YAML:\n# Check YAML syntax python3 -c \"import yaml; yaml.safe_load(open('recipe.yaml'))\" # Dry-run (validate without building) rfswift build -r recipe.yaml --dry-run # Coming soon","version-control#Version Control":"# Store recipes in git git add recipes/ git commit -m \"Add SDR recipe v1.0\" git tag recipe-sdr-v1.0 # Share with team git push origin main --tags","version-pinning-for-reproducibility#Version Pinning for Reproducibility":"base_image: \"ubuntu:24.04\" tag: \"reproducible-sdr:v1.0.0\" packages: - rtl-sdr=0.6.0-1 - hackrf=2021.03.1-2 python_packages: - \"numpy==1.24.3\" - \"scipy==1.10.1\" - \"matplotlib==3.7.1\" run_commands: # Pin specific git commits - | cmake_clone_and_build \\ 'https://github.com/osmocom/rtl-sdr.git' \\ 'build' \\ 'master' \\ 'a1b2c3d4e5f6' # Specific commit 'rtlsdr_install'","yaml-recipe-guide-for-rf-swift#YAML Recipe Guide for RF Swift":"YAML Recipe Guide for RF SwiftYAML recipes provide a simplified, readable way to build custom RF Swift container images without writing complex Dockerfiles. This guide covers everything you need to know about creating, customizing, and building images with YAML recipes.\nWhy YAML Recipes? They eliminate the complexity of Dockerfiles while providing all the power you need for RF and hardware security tool containers. Perfect for quick prototyping and sharing configurations!","your-first-yaml-recipe#Your First YAML Recipe":"Create a file named my-sdr.yaml:\nbase_image: \"ubuntu:24.04\" tag: \"my-sdr:latest\" packages: - rtl-sdr - gqrx-sdr - hackrf python_packages: - numpy - scipy run_commands: - \"echo 'SDR tools installed successfully!'\" Build it:\nrfswift build -r my-sdr.yaml That‚Äôs it! You now have a custom SDR container image."},"title":"YAML Recipe Guide"},"/docs/getting-started/":{"data":{"common-issues-with-the-one-line-installer#Common Issues with the One-Line Installer":"If you encounter issues with the one-line installer:\nPermission Denied: Ensure you have sudo privileges for Linux/macOS installation Docker Service Not Starting: Try restarting your system after installation Shell Alias Not Working: Open a new terminal window or manually source your shell configuration file GitHub API Rate Limiting: If you see an error about GitHub API limits, wait a few minutes and try again","creating-an-alias-linuxmacos#Creating an Alias (Linux/macOS)":"This part can be considered if you manually downloaded the binary.\nFor convenience, you can create an alias to run RF Swift from anywhere. If you didn‚Äôt use the install.sh script (which creates this automatically), you can add an alias manually:\necho \"alias rfswift='$(pwd)/rfswift'\" \u003e\u003e \"$HOME/.$(basename $SHELL)rc\" source \"$HOME/.$(basename $SHELL)rc\" Replace $(pwd)/rfswift with the full path to your RF Swift binary.","getting-started-with-rf-swift-#Getting Started with RF Swift üöÄ":"Getting Started with RF Swift üöÄThis guide will help you get started with RF Swift by covering system requirements, installation steps, and next actions. First we will need to setup the environment.","installation#Installation":"RF Swift now offers a streamlined one-line installer that automatically installs all dependencies (including Docker) and configures your system for optimal performance.\nOur new installer takes care of everything for you in a single command! It will:\nInstall Docker if it‚Äôs not already present Download and install the latest RF Swift release Configure your system for USB, audio, and GUI support Create a convenient shell alias for easy access Set up proper permissions and configurations Linux/macOS (curl)Linux/macOS (wget)Windows curl -fsSL \"https://raw.githubusercontent.com/PentHertz/RF-Swift/refs/heads/main/get_rfswift.sh\" | sh After installation, simply run: rfswift\nwget -qO- \"https://raw.githubusercontent.com/PentHertz/RF-Swift/refs/heads/main/get_rfswift.sh\" | sh After installation, simply run: rfswift\nSee our installation documentation for Windows installation instructions.","linux-manual-installation#Linux Manual Installation":"On Linux, Docker, BuildX, and Go can be directly installed with the install.sh script included in the repository. Essential Components\nDocker: Required to run RF Swift containers wget -qO- \"https://raw.githubusercontent.com/PentHertz/RF-Swift/refs/heads/main/get_rfswift.sh\" | sh xhost: Required for GUI application support (install via your distribution‚Äôs package manager) PulseAudio: Required for audio support (install via your distribution‚Äôs package manager) Optional Components\nGo Compiler: Required if you want to build RF Swift from source BuildX: Required for cross-architecture compilation asciinema: Required for recording sessions Repository Installation\n# Clone the repository git clone https://github.com/PentHertz/RF-Swift.git cd RF-Swift # Run the installation script to automatically install all dependencies ./install.sh The install.sh script will:\nInstall Docker if not already present Set up BuildX for cross-architecture support Install Go compiler if needed Configure xhost for GUI application access Set up PulseAudio for sound Configure user permissions for Docker Download and install the latest RF Swift binary Running Docker Without Sudo\nTo avoid using sudo for every Docker command, add your user to the docker group:\nsudo usermod -aG docker $USER newgrp docker You may need to log out and back in for the changes to take effect. Verify it works by running docker ps without sudo.","macos-manual-installation#macOS Manual Installation":"macOS support will be fully implemented soon. Currently, some features may have limited functionality. Current Status\nContainer functionality works without USB forwarding For full functionality including USB device support, running in a Linux VM is recommended Required Software\nDocker Desktop for macOS XQuartz for X11 forwarding (optional) Known Limitations\nUSB device forwarding is not currently supported natively Some specialized RF tools may have compatibility issues","manual-installation#Manual Installation":"If you prefer to have more control over the installation process, you can install the components separately.","next-steps#Next Steps":"After installation, you can dive right into:\nQuick StartRunning RF Swift with pre-built images and binary Developing and ContributingCompile binary and build images from sources, contribute to the project","troubleshooting#Troubleshooting":"If you encounter issues during installation or usage:\nCheck the GitHub Issues page for known problems Verify your Docker installation is working correctly with docker run hello-world Ensure you have the required permissions (e.g., user is in the docker group on Linux) Join our Discord community for direct assistance","windows-manual-installation#Windows Manual Installation":"Required Software\nDocker Desktop to run containers usbipd to bind USB devices to the host For Audio Support\nFor programs requiring PulseAudio:\nFollow the setup guide on Linux Uprising Use the updated binaries available at pgaskin.net/pulseaudio-win32 Make sure Docker Desktop runs in WSL2 mode for optimal performance and compatibility. Installation Steps\nInstall Docker Desktop and ensure WSL2 integration is enabled Install usbipd for USB device support Set up PulseAudio if audio functionality is needed Download the latest RF Swift binary from the releases page"},"title":"Getting Started"},"/docs/guide/":{"data":{"":"This section covers topics related on how to run RF Swift and use the different softwares installed default images.\nRunning RF Swift Configurations Container images Included tools Host actions Sharing files"},"title":"üìñ Guide"},"/docs/guide/configurations/":{"data":{"adding-bindings-to-existing-containers#Adding Bindings to Existing Containers":"To add a new binding to a running or stopped container:\nrfswift bindings add -c -t [-s ] Parameters:\n-c, --container: Container name or ID (required) -t, --target: Path inside the container (required) -s, --source: Path on the host (optional, defaults to same as target) Examples:\n# Add a simple directory binding rfswift bindings add -c my_sdr_container -s /home/user/data -t /data # Add a device binding rfswift bindings add -c my_bt_container -s /dev/bluetooth -t /dev/bluetooth # When source and target are identical rfswift bindings add -c my_container -t /dev/ttyUSB0","audio-section#Audio Section":"Parameter Description Example pulse_server PulseAudio/PipeWire server address tcp:localhost:34567","available-flags#Available Flags":"Flags: -b, --bind string Extra bindings (separate with commas) -w, --bindedports string Ports to bind between host and container -a, --capabilities string Extra capabilities (separate with commas) -g, --cgroups string Extra cgroup rules (separate with commas) -e, --command string Command to execute (default: '/bin/bash') -s, --devices string Extra device mappings (separate with commas) -d, --display string Set X Display (default: \"DISPLAY=:0\") -z, --exposedports string Ports to expose -x, --extrahosts string Set extra hosts (default: 'pluto.local:192.168.1.2') -h, --help Help for run command -i, --image string Image to use (default: 'myrfswift:latest') -n, --name string Container name -t, --network string Network mode (default: 'host') -u, --privileged int Set privilege level (1: privileged, 0: unprivileged) -p, --pulseserver string PulseAudio server address (default: \"tcp:127.0.0.1:34567\") -m, --seccomp string Set Seccomp profile (default: 'default') Global Flags: -q, --disconnect Don't query updates (disconnected mode)","best-practices#Best Practices":"Base Configuration: Set your common preferences in the config.ini file Special Cases: Use command-line flags for one-time or specialized settings Security First: Keep the privileged = false setting when possible and only add specific capabilities as needed Dynamic Adjustments: Use the bindings feature for on-the-fly modifications Device Access: Be selective about device mappings; only share what is needed","bindings-command-overview#Bindings Command Overview":"rfswift bindings This command has two subcommands:\nadd: Add a binding to an existing container rm: Remove a binding from an existing container","changing-repository#Changing repository":"RF Swift Ubuntu Noble (version 24.04) images are in the way, and you can also test them using the penthertz/rfswift_noble: prefix. In case you want to use Noble images with a short tag name, modify you RF Swift profile config.ini file as follows:\n[general] imagename = myrfswift:latest repotag = penthertz/rfswift_noble ...","command-line-configuration#Command-Line Configuration":"You can override any configuration setting when running a container using command-line flags with the run command:\nrfswift run [flags]","common-configuration-scenarios#Common Configuration Scenarios":"","configuration-file-location#Configuration File Location":"RF Swift looks for a profile configuration file in a platform-specific location:\nLinuxWindowsmacOS /home/username/.config/rfswift/config.ini C:\\Users\\username\\AppData\\Roaming\\rfswift\\config.ini /Users/username/.config/rfswift/config.ini If this file doesn‚Äôt exist when you first run RF Swift, you‚Äôll be prompted to create one with default settings.","configuration-file-structure#Configuration File Structure":"The config.ini file is organized into sections for different aspects of RF Swift‚Äôs behavior:\n[general] imagename = myrfswift:latest repotag = penthertz/rfswift [container] shell = /bin/zsh bindings = network = host exposedports = portbindings = x11forward = /tmp/.X11-unix:/tmp/.X11-unix xdisplay = \"DISPLAY=:0\" extrahost = pluto.local:192.168.2.1 extraenv = devices = /dev/bus/usb:/dev/bus/usb,/dev/snd:/dev/snd,/dev/dri:/dev/dri,/dev/input:/dev/input,/dev/vhci:/dev/vhci,/dev/console:/dev/console,/dev/vcsa:/dev/vcsa,/dev/tty:/dev/tty,/dev/tty0:/dev/tty0,/dev/tty1:/dev/tty1,/dev/tty2:/dev/tty2,/dev/uinput:/dev/uinput privileged = false caps = seccomp = cgroups = c 189:* rwm,c 166:* rwm,c 188:* rwm [audio] pulse_server = tcp:localhost:34567","configuration-sections-explained#Configuration Sections Explained":"","container-section#Container Section":"Parameter Description Example shell Default shell inside containers /bin/zsh bindings Host directories to share with containers /home/user/data:/data network Network mode for containers host, bridge, none exposedports Ports exposed from the container 8080, 443 portbindings Host-to-container port mappings 8080:80/tcp x11forward X11 binding for GUI applications /tmp/.X11-unix:/tmp/.X11-unix xdisplay X11 display environment variable \"DISPLAY=:0\" extrahost Custom host-to-IP mappings pluto.local:192.168.2.1 extraenv Additional environment variables VAR1=value1,VAR2=value2 devices Device mappings for hardware access /dev/bus/usb:/dev/bus/usb privileged Run containers in privileged mode false caps Linux capabilities to add NET_ADMIN,SYS_PTRACE seccomp Seccomp profile for syscall filtering /path/to/profile.json cgroups Control group rules for device access c 189:* rwm,c 166:* rwm","docker-api-version-compatibility#Docker API Version Compatibility":"If you encounter a Docker API version mismatch error:\nError response from daemon: client version 1.47 is too new. Maximum supported API version is 1.45 You can set the API version to match your Docker engine:\nsudo DOCKER_API_VERSION=1.45 rfswift bindings add -c my_container -s /tmp -t /root/myshare For persistent configuration, add this to your shell profile:\n# Add to ~/.bashrc, ~/.zshrc, etc. export DOCKER_API_VERSION=1.45","dynamic-container-modification-with-bindings#Dynamic Container Modification with Bindings":"RF Swift offers a unique feature that Docker doesn‚Äôt provide natively: the ability to modify bindings for existing containers. This eliminates the need to recreate containers when you need to add or remove bindings.","examples#Examples":"# Run with custom image and name rfswift run -i penthertz/rfswift_noble:sdr_full -n my_sdr_container # Share a host directory with the container rfswift run -i penthertz/rfswift_noble:sdr_full -b /home/user/captures:/data/captures # Add network capabilities for Wi-Fi tools rfswift run -i penthertz/rfswift_noble:wifi -a NET_ADMIN # Use bridge network with port mapping rfswift run -i penthertz/rfswift_noble:sdr_full -t bridge -w 8080:80/tcp # Specify a custom shell rfswift run -i penthertz/rfswift_noble:sdr_full -e /bin/bash","examples-1#Examples":"# Run a container without checking for updates rfswift -q run -i sdr_full -n quick_analysis # List local images in disconnected mode rfswift --disconnect images local # Execute a command in a container without update checks rfswift -q exec -c my_container The quiet/disconnected mode can be combined with any RF Swift command and its respective options.\nUsing quiet mode doesn‚Äôt affect RF Swift‚Äôs functionality‚Äîit only disables the automatic update checks. Consider periodically checking for updates manually with rfswift update to ensure you have the latest features and security improvements.","general-section#General Section":"Parameter Description Example imagename Default image used when running containers without -i myrfswift:latest repotag Default repository for RF Swift images penthertz/rfswift RF Swift images by default are built in Jammy version of Ubuntu, but are available in Beta version with Noble build. If you want to try Ubuntu Noble versions, please change repotag to penthertz/rfswift_noble.","offline-device-analysis#Offline Device Analysis":"# Create a container with no network rfswift run -i penthertz/rfswift_noble:reversing -n firmware_analysis \\ -t none \\ -b ~/firmware:/firmware","profile-configuration#Profile Configuration":"","quiet-mode--disconnected-mode#Quiet Mode / Disconnected Mode":"RF Swift includes a global flag that allows you to run in ‚Äúdisconnected mode,‚Äù which prevents the tool from checking for updates or requiring internet connectivity:\nrfswift -q [command] # or rfswift --disconnect [command]","removing-bindings-from-containers#Removing Bindings from Containers":"To remove an existing binding:\nrfswift bindings rm -c -t [-s ] Example:\n# Remove a binding rfswift bindings rm -c my_container -t /data","rf-swift-configuration#RF Swift Configuration":"RF Swift ConfigurationRF Swift provides flexible configuration options to customize your environment. You can configure settings through a profile configuration file for persistent preferences or via command-line arguments for one-time adjustments.","sdr-development-environment#SDR Development Environment":"rfswift run -i penthertz/rfswift_noble:sdr_full -n sdr_dev \\ -b ~/sdr_projects:/projects \\ -s /dev/ttyUSB0:/dev/ttyUSB0","when-to-use-quiet-mode#When to Use Quiet Mode":"This mode is particularly useful in several scenarios:\nAir-gapped Environments: When working in secure environments without internet access Bandwidth-limited Situations: When working with limited connectivity (field operations, remote locations) Automated Scripts: When running RF Swift as part of automated workflows where update checks are not desired Rapid Execution: When you need immediate tool execution without the delay of update checking","wi-fi-security-testing#Wi-Fi Security Testing":"rfswift run -i penthertz/rfswift_noble:wifi -n wifi_testing \\ -a NET_ADMIN,NET_RAW \\ -b ~/wifi_captures:/captures"},"title":"Configurations"},"/docs/guide/container-management/":{"data":{"":"","-comparison-with-traditional-docker#üìä Comparison with Traditional Docker":"Operation Traditional Docker RF Swift Add device Stop, remove, recreate container rfswift bindings add Add volume Stop, remove, recreate container rfswift bindings add Add capability Stop, remove, recreate container rfswift capabilities add Modify cgroups Stop, remove, recreate container rfswift cgroups add Add port Stop, remove, recreate container rfswift ports bind Time to modify 2-5 minutes 5-10 seconds Data preservation Manual backup/restore Automatic Risk of data loss High Low üí° Pro Tip: Use rfswift last to quickly find container names, then pipe operations together for rapid configuration changes during assessments! Remember: All dynamic management commands require stopping and restarting the container. Save your work before making changes!","-dynamic-capability-management#üß¢ Dynamic Capability Management":"Linux capabilities provide fine-grained control over privileged operations. RF Swift allows you to add or remove capabilities from running containers.","-dynamic-cgroup-management#üß© Dynamic Cgroup Management":"Control groups (cgroups) restrict container access to specific device types. RF Swift allows dynamic modification of cgroup rules.","-dynamic-device-and-volume-bindings#üîå Dynamic Device and Volume Bindings":"The bindings command allows you to add or remove device and volume bindings to running containers without interruption.","-dynamic-port-management#üåê Dynamic Port Management":"RF Swift allows you to manage container ports dynamically, supporting both exposed ports (container-to-container) and bound ports (host-to-container).","-real-world-workflows#üéØ Real-World Workflows":"","-security-best-practices#üõ°Ô∏è Security Best Practices":"","-troubleshooting#üîç Troubleshooting":"","adding-capabilities#Adding Capabilities":"# Add single capability rfswift capabilities add -c wifi_container -a NET_ADMIN # Add multiple capabilities rfswift capabilities add -c pentest_container -a NET_ADMIN,NET_RAW,SYS_PTRACE Real-world examples:\n# Enable Wi-Fi monitoring mode rfswift capabilities add -c wifi_tools -a NET_ADMIN,NET_RAW # Enable Bluetooth scanning rfswift capabilities add -c bluetooth_scanner -a NET_ADMIN # Enable debugging tools rfswift capabilities add -c reversing_container -a SYS_PTRACE # Enable raw I/O for hardware access rfswift capabilities add -c hardware_tools -a SYS_RAWIO # Enable low port binding for testing rfswift capabilities add -c web_server -a NET_BIND_SERVICE","adding-cgroup-rules#Adding Cgroup Rules":"# Add single rule rfswift cgroups add -c my_container -g \"c 189:* rwm\" # Add multiple rules rfswift cgroups add -c my_container -g \"c 189:* rwm,c 166:* rwm,c 188:* rwm\" Real-world examples:\n# Grant access to RTL-SDR (USB serial) rfswift cgroups add -c sdr_container -g \"c 189:* rwm\" # Grant access to Proxmark3 (ACM device) rfswift cgroups add -c rfid_container -g \"c 166:* rwm\" # Grant access to FTDI USB serial converters rfswift cgroups add -c hardware_tools -g \"c 188:* rwm\" # Grant access to ALSA audio devices rfswift cgroups add -c audio_analysis -g \"c 116:* rwm\" # Grant GPU access for OpenCL rfswift cgroups add -c gpu_container -g \"c 226:* rwm\" # Grant access to Video4Linux (webcams) rfswift cgroups add -c video_capture -g \"c 81:* rwm\" # Comprehensive hardware access rfswift cgroups add -c hardware_lab -g \"c 189:* rwm,c 166:* rwm,c 188:* rwm,c 116:* rwm,c 226:* rwm\"","adding-device-bindings#Adding Device Bindings":"Syntax for devices:\n# Full syntax with source and target rfswift bindings add -c CONTAINER -d -s /dev/ttyUSB0 -t /dev/ttyUSB0 # Shortcut when source and target are identical rfswift bindings add -c CONTAINER -d -t /dev/ttyUSB0 Real-world examples:\n# Add a specific RTL-SDR device rfswift bindings add -c sdr_container -d -t /dev/rtlsdr0 # Add all USB devices rfswift bindings add -c sdr_container -d -t /dev/bus/usb # Add USB serial device rfswift bindings add -c my_container -d -s /dev/ttyUSB0 -t /dev/ttyUSB0 # Example with a Proxmark3 on /dev/ttyACM0 rfswift bindings add -c rfid_container -d -t /dev/ttyACM0","adding-volume-bindings#Adding Volume Bindings":"Syntax for volumes:\n# Using -b flag (recommended) rfswift bindings add -c CONTAINER -b /host/path:/container/path # Using -s and -t flags rfswift bindings add -c CONTAINER -s /host/path -t /container/path Real-world examples:\n# Mount project directory rfswift bindings add -c my_container -b ~/projects:/root/projects # Mount captures directory rfswift bindings add -c pentest_container -b ~/captures:/root/captures # Mount tool configuration rfswift bindings add -c sdr_container -b ~/.config/gqrx:/root/.config/gqrx # Mount shared data directory rfswift bindings add -c analysis_container -b /data/samples:/root/samples # Mount shared data directory in RO mode (read-only would need Docker API) rfswift bindings add -c analysis_container -b /data/samples:/root/samples:ro # Mount USB drive for data exfiltration rfswift bindings add -c assessment_container -b /media/usb:/mnt/usb","binding-ports#Binding Ports":"Publish container ports to host:\n# Bind with automatic host port rfswift ports bind -c web_server -p 8080:80/tcp # Bind to specific host IP rfswift ports bind -c api_server -p 127.0.0.1:8080:80/tcp # Bind UDP port rfswift ports bind -c dns_server -p 5353:53/udp # Bind to all interfaces rfswift ports bind -c http_server -p 0.0.0.0:8080:80/tcp Real-world examples:\n# Web server for assessment results rfswift ports bind -c pentest_container -p 8080:80/tcp # API server for tool integration rfswift ports bind -c automation -p 127.0.0.1:5000:5000/tcp # Database for analysis results rfswift ports bind -c analysis -p 127.0.0.1:5432:5432/tcp # Jupyter notebook for RF analysis rfswift ports bind -c jupyter_sdr -p 8888:8888/tcp # SSH for remote access rfswift ports bind -c remote_lab -p 2222:22/tcp # VNC for remote GUI rfswift ports bind -c gui_tools -p 5900:5900/tcp # Multiple service ports rfswift ports bind -c full_stack -p 80:80/tcp rfswift ports bind -c full_stack -p 443:443/tcp rfswift ports bind -c full_stack -p 3306:3306/tcp","capability-not-taking-effect#Capability Not Taking Effect":"Problem: Added capability but operation still fails.\nSolution:\n# 1. Check if you need multiple capabilities rfswift capabilities add -c my_container -a NET_ADMIN,NET_RAW # 2. Some operations may need privileged mode rfswift run -i image -n new_container -u 1 # Recreate if necessary","cgroup-rule-format#Cgroup Rule Format":"Rules follow the pattern: type major:minor permissions\nComponents:\ntype: c (character device) or b (block device) major:minor: Device numbers (use * for wildcard) permissions: r (read), w (write), m (mknod - create device files) Common device major numbers:\nMajor Devices Example Use 189 USB serial (ttyUSB*) RTL-SDR, HackRF, GPS receivers 166 ACM devices (ttyACM*) Proxmark3, Arduino 188 USB serial converters FTDI adapters, CH340 116 ALSA audio Audio capture, SDR audio 226 DRI (GPU) OpenCL, GPU acceleration 81 Video4Linux Webcams, video capture 180 USB devices General USB access 89 I2C devices Hardware interfaces 13 Input devices Keyboards, mice, gamepads Find device major numbers:\nls -l /dev/ttyUSB0 crw-rw---- 1 root dialout 188, 0 Jan 12 10:30 /dev/ttyUSB0 # ^^^ major number","command-overview#Command Overview":"rfswift bindings [command] Available Commands: add Add device or volume binding to a container rm Remove device or volume binding from a container (aliases: rm) Flags: -c, --container string Container name or ID -d, --device Manage devices (not volumes) -s, --source string Source path (host) -t, --target string Target path (container)","command-overview-1#Command Overview":"rfswift capabilities [command] Available Commands: add Add capabilities to a container rm Remove capabilities from a container (aliases: rm) Flags: -c, --container string Container name or ID -a, --capabilities string Capabilities to add/remove (comma-separated)","command-overview-2#Command Overview":"rfswift cgroups [command] Available Commands: add Add cgroup rules to a container rm Remove cgroup rules from a container (aliases: rm) Flags: -c, --container string Container name or ID -g, --cgroups string Cgroup rules (comma-separated)","command-overview-3#Command Overview":"rfswift ports [command] Available Commands: bind Bind a port between host and container expose Expose a container port unbind Remove a port binding unexpose Remove an exposed port Flags: -c, --container string Container name or ID -p, --port string Port specification","common-capabilities#Common Capabilities":"Capability Use Case Risk Level NET_ADMIN Network configuration, Wi-Fi/Bluetooth tools Medium NET_RAW Raw socket access, packet crafting Medium SYS_PTRACE Process debugging, memory inspection High SYS_ADMIN Mount operations, system administration Very High DAC_OVERRIDE Bypass file permission checks High CHOWN Change file ownership Medium SETUID/SETGID Change process UID/GID High NET_BIND_SERVICE Bind to ports \u003c 1024 Low SYS_MODULE Load kernel modules Very High SYS_RAWIO Raw I/O operations High","container-wont-restart-after-changes#Container Won\u0026rsquo;t Restart After Changes":"Problem: Container fails to restart after adding bindings.\nSolution:\n# 1. Check container status docker ps -a | grep my_container # 2. View container logs docker logs my_container # 3. Remove problematic binding rfswift bindings rm -c my_container -t /problematic/path # 4. Try manual restart docker start my_container","device-not-accessible-after-binding#Device Not Accessible After Binding":"Problem: Device binding added but tool can‚Äôt access it.\nSolution:\n# 1. Check if cgroup rule allows device type rfswift cgroups list -c my_container # 2. Add missing cgroup rule rfswift cgroups add -c my_container -g \"c 189:* rwm\" # 3. Verify device exists in container rfswift exec -c my_container ls -l /dev/your_device","dynamic-container-management#Dynamic Container Management":"One of RF Swift‚Äôs most powerful features is the ability to modify running containers without recreation. This page covers dynamic management of bindings, capabilities, cgroups, and ports - allowing you to adapt containers to changing assessment needs in real-time.\nWhat Makes This Powerful: Traditional Docker requires destroying and recreating containers to change most settings. RF Swift‚Äôs dynamic management saves time and preserves your work environment while adapting to new requirements.","exposing-ports#Exposing Ports":"Make ports available for inter-container communication:\n# Expose single port rfswift ports expose -c web_server -p 8080 # Expose multiple ports (add one at a time) rfswift ports expose -c api_server -p 3000 rfswift ports expose -c api_server -p 3001 rfswift ports expose -c api_server -p 3002","hot-plugging-workflow#Hot-Plugging Workflow":"RF Swift excels at handling devices that are plugged in after container creation:\n# 1. Start container without device rfswift run -i sdr_full -n sdr_work # 2. Plug in RTL-SDR device # (Device appears as /dev/rtlsdr0) # 3. Add device to running container rfswift bindings add -c sdr_work -d -t /dev/rtlsdr0 # 4. Use the device immediately rfswift exec -c sdr_work rtl_test -t # 5. When done, you can also remove the device binding rfswift bindings rm -c sdr_work -d -t /dev/rtlsdr0 # 6. Physically unplug the device Container Recreation: Adding or removing bindings requires RF Swift to stop the container, modify its configuration, and restart it. Any processes running in the container will be interrupted. Save your work before modifying bindings!","identifying-required-cgroups#Identifying Required Cgroups":"When a tool fails to access a device:\n# 1. Check device information on host ls -l /dev/your_device crw-rw---- 1 root dialout 189, 0 Jan 12 10:30 /dev/your_device # ^^^ major number: 189 # 2. Add corresponding cgroup rule rfswift cgroups add -c your_container -g \"c 189:* rwm\" # 3. Add device binding rfswift bindings add -c your_container -d -t /dev/your_device # 4. Test access rfswift exec -c your_container ls -l /dev/your_device Cgroups vs Device Bindings: Cgroups control which types of devices a container can access, while device bindings make specific devices available. You need both: cgroups allow access to the device class, and bindings expose the actual device.","listing-capabilities#Listing Capabilities":"View current capabilities:\nrfswift capabilities list -c my_container Current Capabilities: NET_ADMIN NET_RAW","network-isolation#Network Isolation":"# Start with network isolation rfswift run -i tools -n isolated -t none # Add specific ports only when needed rfswift ports expose -c isolated -p 8080 # Bind to localhost only for host access rfswift ports bind -c isolated -p 127.0.0.1:8080:8080/tcp","permanent-device-binding#Permanent device binding":"If you need to plug and unplug devices and do not want to stop the container everytime, use the volume binding feature instead of device bindings in Linux (without -d).","permission-denied-inside-container#Permission Denied Inside Container":"Problem: Can‚Äôt access device even with binding and cgroup.\nSolution:\n# 1. Check host device permissions ls -l /dev/your_device # 2. Add user to required group on host sudo usermod -aG dialout $USER # 3. Restart container docker restart my_container # 4. Or run container as privileged (less secure) rfswift capabilities add -c my_container -a DAC_OVERRIDE","port-already-in-use#Port Already in Use":"Problem: Can‚Äôt bind port because it‚Äôs already in use.\nSolution:\n# 1. Check what's using the port sudo lsof -i :8080 # 2. Use a different host port rfswift ports bind -c my_container -p 8081:80/tcp # 3. Or stop the conflicting service sudo systemctl stop service_name rfswift ports bind -c my_container -p 8080:80/tcp","port-concepts#Port Concepts":"Exposed Ports (expose):\nMake ports available to other containers on the same network Don‚Äôt publish to host Used for container-to-container communication Bound Ports (bind):\nPublish container ports to host Format: host_port:container_port/protocol Optional host IP: host_ip:host_port:container_port/protocol","port-management-workflow#Port Management Workflow":"Typical workflow for adding web interface to analysis container:\n# 1. Start container without ports rfswift run -i analysis -n data_analysis # 2. Run analysis, realize you need web interface # (inside container, start jupyter notebook) # 3. Exit container and bind port exit rfswift ports bind -c data_analysis -p 8888:8888/tcp # 4. Access from host browser # Open http://localhost:8888 # 5. When done, unbind port for security rfswift ports unbind -c data_analysis -p 8888:8888/tcp Security Consideration: Binding ports to 0.0.0.0 makes services accessible from any network interface. Use 127.0.0.1 to restrict access to localhost only, especially for sensitive services.","principle-of-least-privilege#Principle of Least Privilege":"# Bad: Start with everything rfswift run -i image -n container -u 1 -a ALL # Good: Add only what's needed, when needed rfswift run -i image -n container -u 0 # ... later, when needed: rfswift capabilities add -c container -a NET_ADMIN # ... when done: rfswift capabilities rm -c container -a NET_ADMIN","removing-bindings#Removing Bindings":"Remove device bindings:\n# Remove by target path rfswift bindings remove -c my_container -d -t /dev/ttyUSB0 # Alternative: use rm alias rfswift bindings rm -c my_container -d -t /dev/ttyUSB0 Remove volume bindings:\n# Remove by target path rfswift bindings remove -c my_container -t /root/projects # Remove multiple bindings rfswift bindings rm -c my_container -t /root/captures rfswift bindings rm -c my_container -t /root/samples","removing-capabilities#Removing Capabilities":"Remove capabilities when they‚Äôre no longer needed:\n# Remove single capability rfswift capabilities remove -c wifi_container -a NET_ADMIN # Remove multiple capabilities rfswift capabilities rm -c pentest_container -a NET_ADMIN,NET_RAW","removing-cgroup-rules#Removing Cgroup Rules":"Remove specific cgroup rules:\n# Remove single rule rfswift cgroups remove -c my_container -g \"c 189:* rwm\" # Remove multiple rules rfswift cgroups rm -c my_container -g \"c 189:* rwm,c 166:* rwm\"","removing-ports#Removing Ports":"Unexpose ports:\nrfswift ports unexpose -c web_server -p 8080 Unbind ports:\n# Unbind by host port rfswift ports unbind -c web_server -p 8080:80/tcp # Unbind from specific IP rfswift ports unbind -c api_server -p 127.0.0.1:5000:5000/tcp","security-best-practice-temporary-capabilities#Security Best Practice: Temporary Capabilities":"Use capabilities only when needed and remove them immediately:\n# Add capability for specific task rfswift capabilities add -c assessment -a NET_ADMIN # Enter container and perform task rfswift exec -c assessment # ... perform network configuration ... # exit # Remove capability after task completes rfswift capabilities rm -c assessment -a NET_ADMIN Security Risk: Capabilities like SYS_ADMIN and SYS_MODULE are nearly equivalent to full root access. Only add them when absolutely necessary and remove them immediately after use.","temporary-privilege-escalation#Temporary Privilege Escalation":"# Workflow for sensitive operations # 1. Add capability rfswift capabilities add -c assessment -a SYS_PTRACE # 2. Perform task rfswift exec -c assessment # ... do debugging work ... exit # 3. Remove capability immediately rfswift capabilities rm -c assessment -a SYS_PTRACE","workflow-1-multi-sdr-assessment#Workflow 1: Multi-SDR Assessment":"Handle multiple SDR devices during a site survey:\n# Day 1: Start with RTL-SDR only rfswift run -i sdr_full -n site_survey rfswift bindings add -c site_survey -d -t /dev/rtlsdr0 # Day 2: Client provides HackRF for specific test rfswift bindings add -c site_survey -d -t /dev/hackrf rfswift cgroups add -c site_survey -g \"c 189:* rwm\" # If not already present # Day 3: Need to analyze with Airspy rfswift bindings add -c site_survey -d -t /dev/airspy0 # Day 4: Return HackRF, continue with others rfswift bindings rm -c site_survey -d -t /dev/hackrf # Cleanup: List all active bindings rfswift bindings list -c site_survey","workflow-2-secure-wireless-assessment#Workflow 2: Secure Wireless Assessment":"Progressive security hardening for Wi-Fi assessment:\n# Start with minimal privileges rfswift run -i wifi -n wifi_assess -u 0 -t bridge # Need monitor mode - add NET_ADMIN temporarily rfswift capabilities add -c wifi_assess -a NET_ADMIN,NET_RAW # Perform monitoring rfswift exec -c wifi_assess airmon-ng start wlan0 airodump-ng wlan0mon # ... perform capture ... exit # Remove capabilities after capture rfswift capabilities rm -c wifi_assess -a NET_ADMIN,NET_RAW # Add web server for reporting rfswift ports bind -c wifi_assess -p 127.0.0.1:8080:80/tcp # Share results directory rfswift bindings add -c wifi_assess -b ~/client-results:/root/results","workflow-3-hardware-reverse-engineering#Workflow 3: Hardware Reverse Engineering":"Iterative device exploration:\n# Start with basic tools rfswift run -i hardware -n rev_eng -u 0 # Connect device, add binding rfswift bindings add -c rev_eng -d -t /dev/ttyUSB0 rfswift cgroups add -c rev_eng -g \"c 188:* rwm\" # Need JTAG - add more devices rfswift bindings add -c rev_eng -d -t /dev/ttyACM0 rfswift cgroups add -c rev_eng -g \"c 166:* rwm\" # Need debugging capabilities rfswift capabilities add -c rev_eng -a SYS_PTRACE # Need shared workspace with host rfswift bindings add -c rev_eng -b ~/projects/device-re:/root/work # Export results over network rfswift ports bind -c rev_eng -p 2222:22/tcp # Security: Remove capabilities when done rfswift capabilities rm -c rev_eng -a SYS_PTRACE","workflow-4-bluetooth-security-assessment#Workflow 4: Bluetooth Security Assessment":"Complete Bluetooth engagement workflow:\n# Initial setup rfswift run -i bluetooth -n bt_assess -u 0 -t bridge # Add Bluetooth capabilities rfswift capabilities add -c bt_assess -a NET_ADMIN,NET_RAW # Add Ubertooth device when it arrives rfswift bindings add -c bt_assess -d -t /dev/ttyACM0 rfswift cgroups add -c bt_assess -g \"c 166:* rwm\" # Add second Bluetooth adapter rfswift bindings add -c bt_assess -d -t /dev/ttyACM1 # Share capture directory rfswift bindings add -c bt_assess -b ~/bt-captures:/root/captures # Set up web interface for results rfswift ports bind -c bt_assess -p 127.0.0.1:8000:8000/tcp # When assessment complete, remove sensitive capabilities rfswift capabilities rm -c bt_assess -a NET_ADMIN,NET_RAW","workflow-5-teaching-lab-environment#Workflow 5: Teaching Lab Environment":"Classroom setup with controlled progression:\n# Week 1: Basic SDR concepts (no hardware) rfswift run -i sdr_light -n student_lab # Week 2: Add RTL-SDR access rfswift bindings add -c student_lab -d -t /dev/rtlsdr0 rfswift cgroups add -c student_lab -g \"c 189:* rwm\" # Week 3: Add audio for AM/FM demodulation rfswift cgroups add -c student_lab -g \"c 116:* rwm\" # Week 4: Share project directories rfswift bindings add -c student_lab -b ~/student-projects:/root/projects # Week 5: Enable web access for visualization rfswift ports bind -c student_lab -p 8080:8080/tcp # End of semester: Review configuration rfswift bindings list -c student_lab rfswift capabilities list -c student_lab rfswift cgroups list -c student_lab rfswift ports list -c student_lab"},"title":"Dynamic Container Management"},"/docs/guide/host-actions/":{"data":{"attaching-usb-devices#Attaching USB Devices":"To share a device with containers, use the attach command with administrator privileges:\n# Run PowerShell as Administrator rfswift winusb attach -i 1-2 Where 1-2 is the BusID of your device from the list command.\nYou can verify the attachment was successful by running list again - the device should show as ‚ÄúAttached‚Äù rather than ‚ÄúNot shared‚Äù.","audio-command-options#Audio Command Options":"The host audio command provides options to manage PulseAudio/PipeWire:\nrfswift host audio This displays available subcommands:\nManage pulseaudio server Usage: rfswift host audio [command] Available Commands: enable Enable connection unload Unload TCP module from Pulseaudio server Flags: -h, --help help for audio","audio-configuration#Audio Configuration":"","automatic-sdr-device-detection#Automatic SDR Device Detection":"For common SDR devices, RF Swift can automatically detect and attach them:\n# Run PowerShell as Administrator rfswift winusb attach-all-sdrs This identifies common SDR devices by their vendor and product IDs and attaches them all at once.","common-device-examples#Common Device Examples":"","custom-audio-configuration#Custom Audio Configuration":"You can customize the listening address and port:\nrfswift host audio enable -s 10.0.0.1:34567 This allows audio forwarding across a network (useful for remote connections or VMs).\nSecurity Note: Opening PulseAudio/PipeWire to network interfaces introduces potential security risks. Only use custom addresses on secure networks and consider using firewalls to restrict access.","detaching-usb-devices#Detaching USB Devices":"When you‚Äôre finished using a device, you can detach it:\n# Run PowerShell as Administrator rfswift winusb detach -i 1-2","device-identification-strategy#Device Identification Strategy":"To easily identify a new device:\nRun rfswift winusb list before connecting your device Connect your device (e.g., RTL-SDR, HackRF, etc.) Run rfswift winusb list again to identify the new entry The newly appeared device is the one you want to share.","diagnosing-audio-issues#Diagnosing Audio Issues":"When audio is not properly configured, you‚Äôll see this warning when running a container:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚ö†Ô∏è Warning ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Warning: Unable to connect to Pulse server at 127.0.0.1:34567 ‚îÇ ‚îÇ To install Pulse server on Linux, follow these steps: ‚îÇ ‚îÇ 1. Update your package manager: sudo apt update (for Debian-based) or sudo yum update (for Red ‚îÇ ‚îÇ Hat-based). ‚îÇ ‚îÇ 2. Install Pulse server: sudo apt install pulse-server (for Debian-based) or sudo yum install ‚îÇ ‚îÇ pulse-server (for Red Hat-based). ‚îÇ ‚îÇ After installation, enable the module with the following command as unprivileged user: ‚îÇ ‚îÇ ./rfswift host audio enable ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò This indicates that PulseAudio/PipeWire is not configured to accept TCP connections on the default address (127.0.0.1:34567).","disabling-audio-forwarding#Disabling Audio Forwarding":"When you no longer need audio forwarding:\nrfswift host audio unload This removes the TCP module from PulseAudio/PipeWire, closing the network port.","enabling-audio-forwarding#Enabling Audio Forwarding":"To enable audio in containers using the default configuration:\nrfswift host audio enable This command:\nLoads the PulseAudio/PipeWire TCP module Configures it to listen on 127.0.0.1:34567 Does not require sudo/administrator privileges You should see confirmation like:\n[+] Successfully loaded module-native-protocol-tcp with index 29","host-actions#Host Actions":"Host ActionsAfter learning how to run, configure, and manage RF Swift containers and images, this section covers important host-level operations that enhance the functionality of your RF tools and containers.","linux-usb-management#Linux USB Management":"On Linux, USB devices are typically accessible to containers through device bindings. You can:\nAdd devices during container creation:\nrfswift run -i sdr_full -n my_sdr -s /dev/ttyUSB0:/dev/ttyUSB0 Add devices to an existing container:\nrfswift bindings add -c my_sdr -s /dev/ttyUSB0:/dev/ttyUSB0 For SDR devices that use USB, ensure the relevant device files are bound:\nRTL-SDR: /dev/bus/usb (generally bound by default) Serial devices: /dev/ttyUSB0, /dev/ttyACM0, etc. HackRF: Typically accessible through /dev/bus/usb","listing-available-usb-devices#Listing Available USB Devices":"To see all USB devices connected to your system:\nrfswift winusb list This displays information about each device:\nUSB Devices: BusID: 1-2, DeviceID: 0bda:2838, VendorID: Bulk-In, ProductID: Interface, Description: Not shared BusID: 1-3, DeviceID: 8087:0032, VendorID: Intel(R), ProductID: Wireless, Description: Bluetooth(R) Not shared BusID: 1-4, DeviceID: 1532:0270, VendorID: USB, ProductID: Input, Description: Device, Razer Blade 14 Shared BusID: 2-4, DeviceID: 13d3:56d5, VendorID: Integrated, ProductID: Camera, Description: Integrated IR Camera Not shared","managing-pulseaudiopipewire-for-container-sound#Managing PulseAudio/PipeWire for Container Sound":"Many RF tools like GQRX, SDR++, and SDRAngel produce audio output that requires proper configuration to be heard on your host system. RF Swift provides commands to manage the PulseAudio/PipeWire server for this purpose.","next-steps#Next Steps":"Continue to the file sharing section to learn how to exchange data between your host and containers:\nFile SharingLearn how to share files and directories between host and containers.","rtl-sdr-setup#RTL-SDR Setup":"After connecting an RTL-SDR device:\nOn Windows:\n# Identify device (typically has vendor ID 0bda) rfswift winusb list # Attach device (replace 1-2 with your device's BusID) rfswift winusb attach -i 1-2 On Linux:\n# Check if device is recognized lsusb | grep RTL # Run container with default USB bindings rfswift run -i sdr_full -n rtlsdr_container","troubleshooting-audio-issues#Troubleshooting Audio Issues":"If you continue to experience audio problems after enabling the server:\nVerify PulseAudio is running:\npulseaudio --check Restart PulseAudio if needed:\npulseaudio -k pulseaudio --start Check your container‚Äôs PULSE_SERVER environment variable:\nrfswift exec -c my_container echo $PULSE_SERVER It should show tcp:127.0.0.1:34567 (or your custom address)","usb-device-management#USB Device Management":"RF Swift provides platform-specific methods for managing USB devices, which is critical for SDR hardware.","using-sdr-tools-with-attached-devices#Using SDR Tools with Attached Devices":"Once your SDR device is properly attached, you can use tools like SDRAngel:\n# Inside your container sdrangel Running SDR Angel on Windows with RTL-SDR attached","windows-usb-management#Windows USB Management":"On Windows, RF Swift includes the winusb command to simplify USB device sharing between the host and containers.\nPrerequisites:\nusbipd must be installed Docker Desktop must be running Administrator privileges are required for attachment operations"},"title":"Host Actions"},"/docs/guide/list-of-images/":{"data":{"core-image-categories#Core Image Categories":"Category Description Example Images SDR Software-defined radio tools sdr_light, sdr_full, sdr_full_nvidiagpu_amd64 Telecom Mobile network analysis telecom_utils, telecom_2Gto3G, telecom_4G_5GNSA, telecom_5G Short-range Bluetooth, Wi-Fi and RFID bluetooth, wifi, rfid Hardware Hardware security tools hardware, reversing Automotive Vehicle communications automotive Base images Foundation for other images corebuild, sdrsa_devices","disk-space-considerations#Disk Space Considerations":"RF Swift images vary in size based on included tools:\nImage Type Typical Size Range Examples Base images 2-5 GB corebuild Specialized tools 5-10 GB bluetooth, wifi, reversing Comprehensive suites 10-20 GB sdr_full, telecom_5G Important Note on Actual Disk Usage: The sizes displayed by rfswift images local show the virtual size of each image. However, due to Docker‚Äôs layer-based architecture and the hierarchical structure of RF Swift images, the actual disk space used is often significantly less than the sum of all image sizes.\nFor example, if you have both sdr_light (9GB) and sdr_full (16GB) images:\nThe displayed total might suggest 25GB of usage The actual disk usage might be closer to 17GB since both images share common base layers This layer sharing happens automatically and is one of the key benefits of RF Swift‚Äôs hierarchical image design. When you pull multiple related images (like those in the same branch of the hierarchy diagram), you‚Äôre only downloading and storing the unique layers for each image.\nTo manage disk space efficiently:\nUse specialized images rather than all-inclusive ones when possible Leverage the image hierarchy - related images share layers and consume less space Remove unused images with rfswift delete -c image:tag Clean up unused containers with rfswift remove -c container_name Consider creating custom images with only the tools you need","image-hierarchy#Image Hierarchy":"RF Swift images are structured in a layered hierarchy, with specialized images building on more general base images:\ngraph TD; A[corebuild]--\u003eB[sdrsa_devices]; A--\u003eC[rfid]; A--\u003eD[automotive]; A--\u003eE[reversing]; A--\u003eF[sdrsa_devices_antsdr]; A--\u003eG[sdrsa_devices_rtlsdrv4]; B[sdrsa_devices]--\u003eH[sdr_light]; B[sdrsa_devices]--\u003eI[bluetooth]; B[sdrsa_devices]--\u003eL[telecom_utils]; B[sdrsa_devices]--\u003eR[hardware]; B[sdrsa_devices]--\u003eS[network]; S[network]--\u003eJ[wifi]; L--\u003eM[telecom_2Gto3G]; L--\u003eN[telecom_4G_5GNSA]; L--\u003eO[telecom_5G]; H--\u003eK[sdr_full] This hierarchy provides several benefits:\nLayer reuse: Reduces overall disk space when using multiple images Consistency: Common tools are identical across related images Specialization: Higher-level images include more specialized tools Base for customization: You can build your own images starting from any level","image-management-commands#Image Management Commands":"RF Swift offers the images command group to interact with both remote and local images:\nrfswift images --help Key subcommands include:\nremote: List available images from the repository local: List downloaded images on your system","listing-available-images#Listing Available Images":"To view all available images for your architecture from the official repository:\nrfswift images remote This command displays a table of available images with important details:\nüíø Official Images ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Tag ‚îÇ Pushed Date ‚îÇ Image ‚îÇ Architecture ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ sdr_full_nvidiagpu_amd64 ‚îÇ 2025-03-24T17:37:59Z ‚îÇ penthertz/rfswift_noble:sdr_full_nvidiagpu_amd64 ‚îÇ amd64 ‚îÇ ‚îÇ hardware ‚îÇ 2025-03-24T17:33:21Z ‚îÇ penthertz/rfswift_noble:hardware ‚îÇ amd64 ‚îÇ ‚îÇ sdr_full_intelgpu_amd64 ‚îÇ 2025-03-24T17:09:38Z ‚îÇ penthertz/rfswift_noble:sdr_full_intelgpu_amd64 ‚îÇ amd64 ‚îÇ ‚îÇ sdr_full ‚îÇ 2025-03-24T16:43:07Z ‚îÇ penthertz/rfswift_noble:sdr_full ‚îÇ amd64 ‚îÇ ‚îÇ telecom_5G ‚îÇ 2025-03-24T16:36:22Z ‚îÇ penthertz/rfswift_noble:telecom_5G ‚îÇ amd64 ‚îÇ ...","listing-local-images#Listing Local Images":"To see images you‚Äôve already downloaded or created:\nrfswift images local This shows details about local images, including their status:\nüì¶ RF Swift Images ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Repository ‚îÇ Tag ‚îÇ Image ID ‚îÇ Created ‚îÇ Size ‚îÇ Status ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ myrfswift ‚îÇ latest ‚îÇ sha256:0bdb2 ‚îÇ 2024-09-01T00:56:27+02:00 ‚îÇ 16635.22 MB ‚îÇ Custom ‚îÇ ‚îÇ penthertz/rfswiftdev ‚îÇ sdr_full_amd64 ‚îÇ sha256:0bdb2 ‚îÇ 2024-09-01T00:56:27+02:00 ‚îÇ 16635.22 MB ‚îÇ Up to date ‚îÇ ‚îÇ penthertz/rfswiftdev ‚îÇ sdr_light_amd64 ‚îÇ sha256:476c0 ‚îÇ 2024-09-01T00:34:55+02:00 ‚îÇ 9617.12 MB ‚îÇ Up to date ‚îÇ ‚îÇ penthertz/rfswift ‚îÇ sdr_full ‚îÇ sha256:50ce1 ‚îÇ 2024-08-02T14:45:46+02:00 ‚îÇ 10383.56 MB ‚îÇ Custom ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Image Status Indicators:\nUp to date: Image matches the latest version in the repository Update available: A newer version exists in the repository Custom: Image has been modified locally (through tagging or container commits)","managing-local-images#Managing Local Images":"","next-steps#Next Steps":"Explore these sections to learn more about available tools and configuration options:\nList of ToolsDetailed inventory of tools included in each image. ConfigurationsManage profiles and settings for RF Swift.","pulling-images#Pulling Images":"To download an image from the repository:\nrfswift images pull -i sdr_light Options:\n-i, --image: Image tag to download (required) -t, --tag: Local tag to apply to the pulled image (optional) -r, --repository: Alternate repository source (optional) Example with custom tag:\nrfswift images pull -i sdr_full -t my_sdr:v1","recommended-images#Recommended Images":"Tag Supported OS x86_64/amd64 arm64/v8 riscv64 Description corebuild - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Base image including prerequisites for compiling tools and libraries for applications needing GUI and some other necessary tools sdrsa_devices - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Contains all drivers of devices included in sdrsa_devices.docker sdrsa_devices_antsdr - Linux - Windows ‚úÖ ‚úÖ ‚úÖ Contains all drivers of devices included in sdrsa_devices.docker but replacing official UHD drivers by ANTSDR ones sdrsa_devices_rtlsdrv4 - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Contains all drivers of devices included in sdrsa_devices.docker but replacing default RTL-SDR drivers to support v4 version for the RTL-SDR blog sdr_light - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Light image built for SDR uses with limited number of tools used in sdr_light.docker file sdr_light_intelgpu - Linux - Windows ‚úÖ ‚ùå ‚ùå same as sdr_light but with Intel GPU driver and gr-fosphor sdr_light_nvidiagpu - Linux - Windows ‚úÖ ‚ùå ‚ùå same as sdr_light but with NVidia GPU driver and gr-fosphor sdr_full - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Full image including all SDR tools used in sdr_full.docker file wifi_basic - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Wi-Fi image for security tests using tools included in wifi_basic.docker wifi_full - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Wi-Fi image for security tests using tools included in wifi_full.docker rfid - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ RFID image for security tests using tools included in rfid.docker reversing - Linux - Windows - macOS ‚úÖ ‚úÖ ‚ùå (not yet) Reversing image for security tests using tools included in reversing.docker automotive - Linux - Windows - macOS ‚úÖ ‚úÖ ‚ùå (not yet) Automotive image for security tests using tools included in automotive.docker bluetooth - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Bluetooth classic and LE image for security tests using tools in bluetooth.docker telecom_utils - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Telecom image for security tests using tools included in telecom_utils.docker telecom_2Gto3G - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Telecom image for security tests using tools included in telecom_2Gto3G.docker telecom_4G_5GNSA - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Telecom image for security tests using tools included in telecom_4G_5GNSA.docker telecom_5G - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Telecom image for security tests using tools included in telecom_4G_5GNSA.docker network - Linux - Windows - macOS ‚úÖ ‚úÖ ‚ùå (not yet) Image for reversing security tests using tools included in reversing.docker hardware - Linux - Windows - macOS ‚úÖ ‚úÖ ‚úÖ Image for hardware security tests using tools included in hardware.docker","remote-image-repository#Remote Image Repository":"","rf-swift-container-images#RF Swift Container Images":"RF Swift Container ImagesRF Swift provides a comprehensive set of container images to support various radio frequency and hardware security workflows. This guide explains how to manage these images and understand the available options.","saving-and-loading-images#Saving and Loading Images":"For offline use or transfer between systems:\n# Export an image to a file rfswift images save -i sdr_light -o sdr_light.tar.gz # Import an image from a file rfswift images load -i sdr_light.tar.gz","understanding-image-tags#Understanding Image Tags":"The image naming system follows a consistent pattern:\nGeneric tags (e.g., sdr_full, bluetooth) work across supported architectures with multi-architecture builds Architecture-specific tags (e.g., sdr_light_amd64, bluetooth_arm64) target single architectures Specialized hardware tags (e.g., sdr_full_nvidiagpu_amd64) include optimizations for specific hardware When in doubt, use the generic tags (without architecture suffix) as RF Swift will automatically select the correct version for your system. Use architecture-specific tags only when you need a particular variant.","updating-images#Updating Images":"To update an image that shows ‚ÄúUpdate available‚Äù:\nrfswift images pull -i sdr_full RF Swift will automatically download the latest version."},"title":"Container Images"},"/docs/guide/list-of-tools/":{"data":{"2g3g-analysis-tools#2G/3G Analysis Tools":"Tools for GSM, UMTS, and related technologies:\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default YateBTS Complete 2G/GSM base station with Yate softswitch yate | yatebts | mbts ‚úÖ ‚úÖ ‚úÖ yatebts_blade2_soft_install ‚úÖ OpenBTS Open source GSM base station OpenBTS | transceiver ‚úÖ ‚ùå ‚ùå openbts_uhd_soft_install ‚úÖ OpenBTS UMTS Open source 3G UMTS base station OpenBTS-UMTS ‚úÖ ‚ùå ‚ùå openbts_umts_soft_install ‚úÖ OsmoCom BTS Suite Complete 2G network infrastructure suite osmo-bts | osmo-bsc | osmo-msc | osmo-hlr | osmo-mgw | osmo-sgsn | osmo-ggsn ‚úÖ ‚úÖ ‚úÖ osmobts_suite_soft_install ‚úÖ Architecture Limitations:\nYateBTS: Requires Qt5 dependencies, may have limited multi-arch support OpenBTS/OpenBTS-UMTS: x86_64 only due to build dependencies OsmoCom suite: Builds on all architectures but requires significant system resources Tool Locations:\n/telecom/2G/ - 2G base stations and tools /telecom/3G/ - 3G/UMTS tools /telecom/SIM/ - SIM card programming tools Configuration files in /root/config/osmobts/","4g5g-analysis-tools#4G/5G Analysis Tools":"Tools for LTE and 5G-NSA:\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default srsRAN 4G Complete LTE stack (eNB EPC UE) srsenb | srsepc | srsue ‚úÖ ‚úÖ ‚úÖ srsran4G_5GNSA_soft_install ‚úÖ Open5GS Open source 5G Core and EPC open5gs-amfd | open5gs-smfd | open5gs-upfd | open5gs-mmed | open5gs-sgwud | open5gs-hssd | open5gs-pcrfd ‚úÖ ‚úÖ ‚úÖ Open5GS_soft_install ‚úÖ Open5GS Web UI Subscriber management web interface Node.js web UI on port 3000 ‚úÖ ‚úÖ ‚úÖ Open5GS_soft_install ‚úÖ srsRAN 4G: Complete LTE stack including:\nsrsENB: LTE eNodeB (base station) srsEPC: Evolved Packet Core srsUE: UE simulator","5g-analysis-tools#5G Analysis Tools":"Tools for 5G standalone (SA) and core networks:\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default srsRAN Project 5G SA gNB implementation gnb ‚úÖ ‚úÖ ‚úÖ srsran5GSA_soft_install ‚úÖ srsRAN Project (bladeRF) 5G SA gNB with bladeRF support gnb ‚úÖ ‚úÖ ‚úÖ srsran5GSA_bladerf_soft_install ‚ùå (alternative) Open5GS Open source 5G Core network open5gs-amfd | open5gs-smfd | open5gs-upfd | open5gs-ausfd | open5gs-udmd | open5gs-pcfd | open5gs-nrfd | open5gs-scpd | open5gs-bsfd | open5gs-udrd ‚úÖ ‚úÖ ‚úÖ Open5GS_soft_install ‚úÖ Open5GS (nohttp2) Open5GS without HTTP/2 support Same as Open5GS ‚úÖ ‚úÖ ‚úÖ Open5GS_nohttp2_soft_install ‚ùå (alternative) Open5GS (0caps) Open5GS with null cipher support Same as Open5GS ‚úÖ ‚úÖ ‚úÖ Open5GS_0caps_soft_install ‚ùå (alternative) Open5GS Web UI Subscriber management web interface Node.js web UI on port 3000 ‚úÖ ‚úÖ ‚úÖ Open5GS_soft_install ‚úÖ UERANSIM 5G UE and RAN simulator nr-ue | nr-gnb | nr-cli | nr-binder ‚úÖ ‚úÖ ‚úÖ UERANSIM_soft_install ‚úÖ UERANSIM (null cipher) UERANSIM with null cipher support Same as UERANSIM ‚úÖ ‚úÖ ‚úÖ UERANSIM_nullciph_soft_install ‚ùå (alternative) 5Greplay 5G traffic replay and testing 5greplay ‚úÖ ‚úÖ ‚úÖ 5greplay_soft_install ‚úÖ MongoDB Requirement: Open5GS requires MongoDB for subscriber database. The container includes:\nMongoDB 6.0 from official repository Web UI for subscriber management (Node.js based) Database directory at /data/db/ To start all Open5GS components: Open5Gs_deployall","additional-sdr-software#Additional SDR Software":"Tool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default CyberEther Real-time SDR signal analyzer with GPU acceleration cyberether ‚úÖ ‚úÖ ‚úÖ cyberther_soft_install ‚úÖ SigDigger Advanced signal analyzer for reverse engineering SigDigger ‚úÖ ‚úÖ ‚úÖ sigdigger_soft_install ‚úÖ QSSTV Slow-scan television (SSTV) transceiver qsstv ‚úÖ ‚úÖ ‚úÖ qsstv_soft_install ‚úÖ nfc-laboratory NFC protocol analyzer and emulator nfc-laboratory ‚úÖ ‚úÖ ‚úÖ nfclaboratory_soft_install ‚úÖ ice9-bluetooth Bluetooth Classic sniffer ice9-bluetooth ‚úÖ ‚ùå ‚ùå ice9_bluetooth_soft_install ‚úÖ Meshtastic SDR Meshtastic mesh network SDR tools meshtastic-sdr ‚úÖ ‚úÖ ‚úÖ meshtastic_sdr_soft_install ‚úÖ GPS-SDR-SIM GPS signal simulator gps-sdr-sim ‚úÖ ‚úÖ ‚úÖ gps_sdr_sim_soft_install ‚úÖ Gpredict Real-time satellite tracking and orbit prediction gpredict ‚úÖ ‚úÖ ‚úÖ gpredict_sdr_soft_install ‚úÖ V2Verifier V2X message verification tool v2verifier ‚úÖ ‚úÖ ‚úÖ v2verifier_sdr_soft_install ‚úÖ wavingZ Z-Wave protocol analyzer wavingz ‚úÖ ‚úÖ ‚úÖ wavingz_sdr_soft_install ‚úÖ PySpecSDR Python spectrum analyzer pyspecsdr ‚úÖ ‚úÖ ‚úÖ pyspecsdr_sdr_soft_install ‚úÖ AIS Catcher Automatic Identification System decoder aiscatcher ‚úÖ ‚úÖ ‚úÖ AIScatcher_soft_install ‚úÖ TetraKit TETRA digital radio toolkit tetrakit ‚úÖ ‚úÖ ‚úÖ tetrakit_soft_install ‚úÖ TetraKit Player TETRA voice player tetrakit-player ‚úÖ ‚úÖ ‚úÖ tetrakitplayer_soft_install ‚úÖ TETRA Suite Complete TETRA decoder (osmo-tetra telive) osmo-tetra | telive ‚úÖ ‚úÖ ‚úÖ tetra_suite_install ‚úÖ OP25 APCO Project 25 decoder op25 ‚úÖ ‚úÖ ‚úÖ op25_soft_install ‚úÖ Trunk Recorder Multi-channel trunked radio recorder trunk-recorder ‚úÖ ‚úÖ ‚úÖ trunkrecorder_soft_install ‚úÖ SatDump Universal satellite data processing software satdump | satdump-ui ‚úÖ ‚úÖ ‚úÖ satdump_sdr_soft_install ‚úÖ SDRangel Multi-platform SDR software with extensive plugins sdrangel ‚úÖ ‚úÖ ‚úÖ sdrangel_soft_fromsource_install ‚úÖ ML and DL Libraries Machine learning libraries for signal processing (numpy pandas scikit-learn tensorflow) Python ML/DL modules ‚úÖ ‚úÖ ‚úÖ ml_and_dl_soft_install ‚úÖ GPU Drivers - NVIDIA NVIDIA GPU compute drivers for acceleration nvidia-smi | nvidia-settings ‚úÖ ‚úÖ ‚úÖ install_GPU_nvidia ‚úÖ GPU Drivers - Intel Intel GPU compute drivers intel-gpu-tools ‚úÖ ‚úÖ ‚úÖ install_GPU_Intel ‚úÖ GPU Drivers - Radeon (up to 5000) AMD Radeon GPU drivers for older cards rocm-smi ‚úÖ ‚úÖ ‚úÖ install_GPU_Radeon_until5000 ‚úÖ GPU Drivers - Radeon (latest) AMD Radeon GPU drivers for latest cards rocm-smi ‚úÖ ‚úÖ ‚úÖ install_GPU_latest_Radeon ‚úÖ gr-fosphor GPU-accelerated FFT and display for GNU Radio GNU Radio fosphor blocks ‚úÖ ‚ùì ‚ùì grfosphor_grmod_install ‚úÖ (GPU images only) Major Software Suites:\nSDR++: Modern cross-platform SDR software with plugin support SDRAngel: Advanced SDR software with extensive plugin ecosystem GQRX: Popular SDR receiver powered by GNU Radio SigDigger: Signal analysis and reverse engineering tool URH: Universal Radio Hacker for wireless protocol analysis (with HydraSDR fork enhancements)","architecture-specific-notes#Architecture-Specific Notes":"","arm64--aarch64#ARM64 / aarch64":"Most tools fully supported Some GUI applications require AppImage extraction Limited SA software support (no SignalHound Spike/VSG60) Python tools may need building from source","automotive-security#Automotive Security":"The automotive image contains tools for vehicle network analysis and communication:\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default can-utils Linux SocketCAN userspace utilities candump | cansend | canplayer | cangen | cansniffer | cansequence ‚úÖ ‚úÖ ‚úÖ canutils_soft_install ‚úÖ CANtact CANtact hardware support utilities cantact ‚úÖ ‚úÖ ‚úÖ cantact_soft_install ‚úÖ Caring Caribou CAN bus security and penetration testing caringcaribou ‚úÖ ‚úÖ ‚úÖ caringcaribou_soft_install ‚úÖ SavvyCAN Cross-platform CAN bus reverse engineering SavvyCAN ‚úÖ ‚úÖ ‚úÖ savvycan_soft_install ‚úÖ Gallia Extendable automotive penetration testing framework gallia ‚úÖ ‚úÖ ‚úÖ gallia_soft_install ‚úÖ V2GInjector Vehicle-to-Grid (V2G) protocol testing v2ginjector ‚úÖ ‚úÖ ‚úÖ v2ginjector_soft_install ‚úÖ Tool Locations:\n/automotive/ - Main automotive tools directory CAN/LIN/FlexRay tools Vehicle protocol analyzers","bluetooth-analysis#Bluetooth Analysis":"The bluetooth image contains specialized tools for Bluetooth protocol analysis and security testing:\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default hcitools Bluetooth HCI layer tools for device configuration and management hciattach | hciconfig | hcidump | hcitool ‚úÖ ‚úÖ ‚úÖ blueztools_soft_install ‚úÖ bluez tools BlueZ Bluetooth protocol stack utilities bluetoothctl | bluetoothd | btmon ‚úÖ ‚úÖ ‚úÖ blueztools_soft_install ‚úÖ mirage Modular framework for BLE security auditing with Python 3.10 venv mirage ‚úÖ ‚úÖ ‚úÖ mirage_soft_install ‚úÖ Sniffle TI CC13x2/CC26x2 BLE sniffer with OpenDroneID support /rftools/bluetooth/Sniffle/ ‚úÖ ‚úÖ ‚úÖ sniffle_soft_install ‚úÖ bluing Python-based Bluetooth Low Energy scanner and analyzer /rftools/bluetooth/bluing/bluing/bin/ ‚úÖ ‚úÖ ‚úÖ bluing_soft_install ‚úÖ bdaddr Tool to change Bluetooth device address /rftools/bluetooth/bdaddr/bdaddr ‚úÖ ‚úÖ ‚úÖ bdaddr_soft_install ‚úÖ WHAD Wireless Hacking Devices protocol framework whadup | wplay | wsniff | wfilter | wextract | wdump | wshark | wanalyze | winject | wserver | wble-central | wble-periph | wble-proxy | wble-spawn | wble-connect | wuni-scan | wuni-mouse | wuni-keyboard ‚úÖ ‚úÖ ‚úÖ whad_soft_install ‚úÖ esp32_bluetooth_classic_sniffer ESP32-based Bluetooth Classic sniffer with Python CLI BTSnifferBREDR ‚úÖ ‚úÖ ‚úÖ esp32_bluetooth_classic_sniffer_soft_install ‚úÖ bettercap Swiss Army knife for WiFi Bluetooth and network attacks bettercap ‚úÖ ‚úÖ ‚úÖ bettercap_soft_install ‚ùå (install manually) Kismet Wireless network detector and packet sniffer with BT support kismet ‚úÖ ‚úÖ ‚úÖ kismet_soft_install ‚ùå (install manually) BlueKit Bluetooth security assessment toolkit bluekit ‚úÖ ‚úÖ ‚úÖ bluekit_soft_install ‚ùå (install manually) Required Capability: Bluetooth tools require the NET_ADMIN capability to function properly. Always include this capability when running the container:\nrfswift run -i bluetooth -n bt_tools -a NET_ADMIN Without this capability, many Bluetooth tools will fail with permission errors when attempting to configure network interfaces.\nPython Virtual Environments: Some Bluetooth tools run in isolated Python environments:\nMirage: Uses Python 3.10 venv at /opt/mirage-env/, accessed via wrapper script at /usr/sbin/mirage Bluing: Uses Python 3.10 venv at /rftools/bluetooth/bluing/, run with bluing_run script Tool Locations:\n/rftools/bluetooth/ - Main Bluetooth tools directory /rftools/bluetooth/firmwares/ - Firmware for various BLE sniffers (Btlejack, Injectable NRF52840, Sniffle)","common-device-troubleshooting#Common Device Troubleshooting":"","core-sdr-devices-support#Core SDR Devices Support":"The sdrsa_devices image serves as the foundation for many RF Swift images, providing essential drivers and utilities for software-defined radio hardware.\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default UHD tools and libs USRP Hardware Driver - Universal driver for Ettus Research USRP devices uhd_adc_self_cal | uhd_fft | uhd_rx_cfile | uhd_cal_rx_iq_balance | uhd_find_devices | uhd_rx_nogui | uhd_cal_tx_dc_offset | uhd_image_loader | uhd_siggen | uhd_cal_tx_iq_balance | uhd_images_downloader | uhd_siggen_gui | uhd_config_info | uhd_modes.py | uhd_usrp_probe ‚úÖ ‚úÖ ‚úÖ uhd_devices_install ‚úÖ RTL-SDR tools and libs RTL-SDR driver and tools for RTL2832U-based DVB-T receivers rtl_biast | rtl_fm | rtl_sdr | rtl_test | rtl_adsb | rtl_eeprom | rtl_power | rtl_tcp ‚úÖ ‚úÖ ‚úÖ rtlsdr_devices_install ‚úÖ RTL-SDR v4 tools Enhanced RTL-SDR Blog v4 driver with improved performance rtl_biast | rtl_fm | rtl_sdr | rtl_test | rtl_adsb | rtl_eeprom | rtl_power | rtl_tcp ‚úÖ ‚úÖ ‚úÖ rtlsdrv4_devices_install ‚ùå (optional alternative) libiio and libad9361 Industrial I/O and AD9361 library for PlutoSDR and similar devices iio_adi_xflow_check | iio_attr | iio_genxml | iio_info | iio_readdev | iio_reg | iio_stresstest | iio_writedev ‚úÖ ‚úÖ ‚úÖ ad_devices_install ‚úÖ Nuand bladeRF tools bladeRF SDR tools and libraries built from source bladeRF-cli | bladeRF-fsk ‚úÖ ‚úÖ ‚úÖ nuand_devices_fromsource_install ‚úÖ HackRF tools and lib HackRF One SDR platform tools and libraries hackrf_clock | hackrf_debug | hackrf_operacake | hackrf_sweep | hackrf_cpldjtag | hackrf_info | hackrf_spiflash | hackrf_transfer ‚úÖ ‚úÖ ‚úÖ hackrf_devices_install ‚úÖ Airspy tools and lib Airspy R2/Mini and HF+ SDR receivers airspy_gpio | airspy_rx | airspyhf_info | airspy_gpiodir | airspy_si5351c | airspyhf_lib_version | airspy_info | airspy_spiflash | airspyhf_rx | airspy_lib_version | airspyhf_calibrate | airspy_r820t | airspyhf_gpio ‚úÖ ‚úÖ ‚úÖ airspy_devices_install ‚úÖ LimeSDR tools and lib LimeSDR and LimeSDR Mini SDR platform LimeQuickTest | LimeSuiteGUI | LimeUtil ‚úÖ ‚úÖ ‚úÖ limesdr_devices_install ‚úÖ Funcube tools and lib Funcube Dongle and Dongle Pro SDR receivers qthid-fcd-controller ‚úÖ ‚úÖ ‚úÖ funcube_devices_install ‚úÖ XTRX tools and lib XTRX mini-PCIe SDR platform xtrx_fft ‚úÖ ‚úÖ ‚úÖ xtrx_devices_install ‚úÖ OsmoFL2K tools and lib FL2000-based VGA adapter as SDR transmitter fl2k_file | fl2k_tcp | fl2k_fm | fl2k_test ‚úÖ ‚úÖ ‚úÖ osmofl2k_devices_install ‚úÖ SignalHound Spike Spectrum analyzer software for SignalHound BB and SM series Spike ‚úÖ ‚ùå ‚ùå signalhound_spike_sa_device ‚úÖ SignalHound VSG60 Signal generator software for VSG60 vector signal generator vsg60 ‚úÖ ‚ùå ‚ùå signalhound_vsg60_sa_device ‚úÖ Harogic Devices SAStudio4 spectrum analyzer software for Harogic HTRA devices sastudio ‚úÖ ‚úÖ ‚ùå harogic_sa_device ‚úÖ RFNM RFNM SDR platform library and drivers librfnm ‚úÖ ‚úÖ ‚úÖ rfnm_devices_install ‚úÖ LibreSDR B2x0 Open-source FPGA images for USRP B2x0 series libresdr_swapfpga ‚úÖ ‚úÖ ‚úÖ libresdr_b2x0_devices_install ‚úÖ pocketVNA Vector Network Analyzer software for pocketVNA device pocketVNA ‚úÖ ‚ùå ‚ùå pocketvna_sa_device ‚ùå (install manually) LiteX M2SDR LiteX-based M2SDR platform with SoapySDR drivers SoapySDR drivers ‚úÖ ‚úÖ ‚úÖ litexm2sdr_devices_install ‚úÖ HydraSDR/RFOne tools HydraSDR RFOne SDR platform tools and libraries hydrasdr_gpio | hydrasdr_calibrate | hydrasdr_gpiodir | hydrasdr_lib_version | hydrasdr_reset | hydrasdr_set_rf_port | hydrasdr_spiflash | hydrasdr_info | hydrasdr_r82x | hydrasdr_rx | hydrasdr_si5351c ‚úÖ ‚úÖ ‚úÖ hydrasdr_rfone_install ‚úÖ kalibrate-hydrasdr GSM frequency calibration tool for HydraSDR kal ‚úÖ ‚úÖ ‚úÖ kalibrate_hydrasdr_device ‚úÖ USDR Library waveLab USDR software-defined radio library libusdr ‚úÖ ‚úÖ ‚úÖ usdr_lib_install ‚úÖ ANTSDR UHD MicroPhase ANTSDR variant of UHD for ANTSDR devices Same as UHD tools ‚úÖ ‚úÖ ‚úÖ antsdr_uhd_devices_install ‚ùå (optional alternative to UHD) SoapySDR modules Additional SoapySDR device modules (osmosdr rtlsdr bladerf hackrf uhd mirisdr rfspace) Various SoapySDR modules ‚úÖ ‚úÖ ‚úÖ install_soapy_modules ‚ùå (install manually) SoapyPlutoSDR SoapySDR module for PlutoSDR devices SoapySDR PlutoSDR support ‚úÖ ‚úÖ ‚úÖ install_soapyPlutoSDR_modules ‚ùå (install manually) Device-Specific Notes:\nUHD vs ANTSDR: Choose either standard UHD or ANTSDR variant during build (mutually exclusive) RTL-SDR versions: Standard rtl-sdr or rtlsdrv4 blog version (mutually exclusive) Manual installation tools: SoapySDR modules, SoapyPlutoSDR, and pocketVNA require manual installation after container creation","creating-tool-aliases#Creating Tool Aliases":"For frequently used tools with complex options, consider creating aliases in your container:\necho 'alias rtlpower-optimized=\"rtl_power -f 88M:108M:25k -g 50 -i 10 -e 1h power.csv\"' \u003e\u003e ~/.zshrc source ~/.zshrc","finding-available-tools#Finding Available Tools":"To discover which tools are available in your current container:\n# List all executable commands in standard paths find /usr/bin /usr/local/bin -type f -executable | sort # List RF tools in the dedicated directory ls -la /rftools # List tools in other specialized directories ls -la /hardware ls -la /automotive ls -la /reverse ls -la /telecom # Search for a specific tool across all locations find /usr/bin /usr/local/bin /rftools /hardware /automotive /reverse /telecom -name \"*sdr*\" -type f -executable","gnu-radio-out-of-tree-modules#GNU Radio Out-Of-Tree Modules":"These modules extend GNU Radio‚Äôs capabilities for specific protocols and signal types:\nTool(s) Description amd64 aarch64 riscv64 Installation function Installed by default gr-osmosdr Common source/sink blocks for various SDR hardware ‚úÖ ‚úÖ ‚úÖ common_sources_and_sinks ‚úÖ gr-gsm GSM/GPRS/EDGE baseband processor for GNU Radio ‚úÖ ‚úÖ ‚úÖ grgsm_grmod_install ‚úÖ gr-lora LoRa PHY implementation for GNU Radio ‚úÖ ‚úÖ ‚úÖ grlora_grmod_install ‚úÖ gr-lora_sdr Alternative LoRa SDR implementation with better decoding ‚úÖ ‚úÖ ‚úÖ grlorasdr_grmod_install ‚úÖ gr-iridium Iridium satellite communication decoder ‚úÖ ‚úÖ ‚úÖ griridium_grmod_install ‚úÖ gr-inspector Signal analysis and classification toolkit ‚úÖ ‚úÖ ‚úÖ grinspector_grmod_install ‚úÖ gr-uaslink Unmanned Aerial System datalink decoder ‚úÖ ‚úÖ ‚úÖ gruaslink_grmod_install ‚úÖ gr-X10 X10 home automation protocol decoder ‚úÖ ‚úÖ ‚úÖ grX10_grmod_install ‚úÖ gr-gfdm Generalized Frequency Division Multiplexing implementation ‚úÖ ‚úÖ ‚úÖ grgfdm_grmod_install ‚úÖ gr-aaronia_rtsa Aaronia real-time spectrum analyzer support ‚úÖ ‚úÖ ‚úÖ graaronia_rtsa_grmod_install ‚úÖ gr-ccsds CCSDS (space communications) protocol support ‚ùå ‚ùå ‚ùå grccsds_move_rtsa_grmod_install ‚ùå (broken - strtod_l issue) gr-ais Automatic Identification System (AIS) decoder ‚úÖ ‚úÖ ‚úÖ grais_grmod_install ‚úÖ gr-aistx AIS transmitter blocks ‚úÖ ‚úÖ ‚úÖ graistx_grmod_install ‚úÖ gr-air-modes Mode S/ADS-B aircraft transponder decoder ‚úÖ ‚úÖ ‚úÖ grairmodes_grmod_install ‚úÖ gr-dvbs2 DVB-S2 digital video broadcasting decoder ‚úÖ ‚úÖ ‚úÖ grdvbs2_grmod_install ‚úÖ gr-tempest TEMPEST electromagnetic emanations receiver ‚úÖ ‚úÖ ‚úÖ grtempest_grmod_install ‚úÖ deep-tempest Deep learning-based TEMPEST for screen reconstruction ‚ùå ‚ùå ‚ùå deeptempest_grmod_install ‚ùå (see sdr_deeptemptest_beta image) gr-dab Digital Audio Broadcasting (DAB/DAB+) decoder ‚úÖ ‚úÖ ‚úÖ grdab_grmod_install ‚úÖ gr-dect2 DECT (cordless phone) protocol decoder ‚úÖ ‚úÖ ‚úÖ grdect2_grmod_install ‚úÖ gr-foo Miscellaneous GNU Radio blocks and utilities ‚úÖ ‚úÖ ‚úÖ grfoo_grmod_install ‚úÖ gr-ieee802-11 WiFi (802.11a/g/p) transceiver implementation ‚úÖ ‚úÖ ‚úÖ grieee802-11_grmod_install ‚úÖ gr-ieee802-11ah WiFi HaLow (802.11ah) sub-1GHz implementation ‚úÖ ‚úÖ ‚úÖ grieee802-11ah_grmod_install ‚úÖ gr-ieee80211 (gr-wifi) Alternative WiFi implementation ‚úÖ ‚úÖ ‚úÖ grieee80211-grwifi_grmod_install ‚úÖ gr-ieee802-15-4 ZigBee and 802.15.4 PHY/MAC implementation ‚úÖ ‚úÖ ‚úÖ grieee802154_grmod_install ‚úÖ gr-rds Radio Data System (RDS) encoder/decoder ‚úÖ ‚úÖ ‚úÖ grrds_grmod_install ‚úÖ gr-droneid DJI DroneID and RemoteID decoder ‚úÖ ‚úÖ ‚úÖ grdroineid_grmod_install ‚úÖ gr-satellites Satellite telemetry decoder (100+ satellites) ‚úÖ ‚úÖ ‚úÖ grsatellites_grmod_install ‚úÖ gr-adsb ADS-B aircraft transponder decoder ‚úÖ ‚úÖ ‚úÖ gradsb_grmod_install ‚úÖ gr-keyfob Car key fob signal analyzer ‚úÖ ‚úÖ ‚úÖ grkeyfob_grmod_install ‚úÖ gr-radar Radar signal processing toolkit ‚úÖ ‚úÖ ‚úÖ grradar_grmod_install ‚úÖ gr-nordic Nordic Semiconductor protocol decoder (nRF24L01+) ‚úÖ ‚úÖ ‚úÖ grnordic_grmod_install ‚úÖ gr-paint Spectrum painting and waterfall annotation ‚úÖ ‚úÖ ‚úÖ grpaint_grmod_install ‚úÖ gr-pdu_utils Protocol Data Unit utilities from Sandia ‚úÖ ‚úÖ ‚úÖ grpdu_utils_grmod_install ‚úÖ gr-sandia_utils Sandia National Labs signal processing blocks ‚úÖ ‚úÖ ‚úÖ grsandia_utils_grmod_install ‚úÖ gr-timing_utils Timing and synchronization utilities from Sandia ‚úÖ ‚úÖ ‚úÖ grtiming_utils_grmod_install ‚úÖ gr-fhss_utils Frequency Hopping Spread Spectrum utilities ‚úÖ ‚úÖ ‚úÖ grfhss_utils_grmod_install ‚úÖ gr-zwave_poore Z-Wave home automation protocol decoder ‚úÖ ‚úÖ ‚úÖ grzwavepoore_grmod_install ‚úÖ gr-mixalot POCSAG pager protocol encoder ‚úÖ ‚úÖ ‚úÖ grmixalot_grmod_install ‚úÖ gr-reveng CRC and checksum reverse engineering ‚úÖ ‚úÖ ‚úÖ grreveng_grmod_install ‚úÖ gr-DCF77_Receiver DCF77 time signal receiver ‚úÖ ‚úÖ ‚úÖ gr_DCF77_Receiver_grmod_install ‚úÖ gr-j2497 MIL-STD-1553 and MIL-STD-1397 decoder ‚úÖ ‚úÖ ‚úÖ grj2497_grmod_install ‚úÖ gr-m17 M17 digital voice protocol implementation ‚úÖ ‚úÖ ‚úÖ grm17_grmod_install ‚úÖ gr-grnet Network socket blocks for GNU Radio ‚úÖ ‚úÖ ‚ùå grgrnet_grmod_install ‚úÖ gr-aoa Angle of Arrival estimation ‚úÖ ‚úÖ ‚úÖ graoa_grmod_install ‚úÖ gr-correctiq IQ correction algorithms for SDR devices ‚úÖ ‚úÖ ‚úÖ grcorrectiq_grmod_install ‚úÖ gr-dsd Digital Speech Decoder (P25 DMR NXDN) ‚úÖ ‚úÖ ‚úÖ grdsd_grmod_install ‚úÖ gr-nrsc5 HD Radio (NRSC-5) decoder ‚úÖ ‚úÖ ‚úÖ grnrsc5_grmod_install ‚úÖ gr-ntsc-rc NTSC video signal processing ‚úÖ ‚úÖ ‚úÖ grntscrc_grmod_install ‚úÖ gr-nfc NFC (Near Field Communication) PHY ‚úÖ ‚úÖ ‚úÖ grnfc_grmod_install ‚úÖ gr-fosphor GPU-accelerated spectrum analyzer (requires GPU) ‚úÖ ‚ùì ‚ùì grfosphor_grmod_install ‚úÖ (GPU images only) gr-mer Modulation Error Ratio measurement ‚úÖ ‚úÖ ‚úÖ grmer_grmod_install ‚úÖ gr-flarm FLARM aircraft collision avoidance decoder ‚úÖ ‚úÖ ‚úÖ grflarm_grmod_install ‚úÖ gr-guiextra Additional GUI widgets and displays ‚úÖ ‚úÖ ‚úÖ grguiextra_grmod_install ‚úÖ gr-rftap RF tap blocks for protocol analysis ‚úÖ ‚úÖ ‚úÖ grrftap_grmod_install ‚úÖ gr-radio_astro Radio astronomy signal processing ‚úÖ ‚úÖ ‚úÖ grradioastro_grmod_install ‚úÖ gr-cessb Controlled Envelope Single Sideband modulation ‚úÖ ‚úÖ ‚úÖ grcessb_grmod_install ‚úÖ gr-signal-hound Signal Hound device support for GNU Radio ‚úÖ ‚úÖ ‚ùå grsignalhound_Receiver_grmod_install ‚ùå (install manually) gr-bladerf bladeRF device support for GNU Radio ‚úÖ ‚úÖ ‚úÖ grbladerf_grmod_install ‚ùå (install manually) gr-htra Harogic HTRA device support for GNU Radio ‚úÖ ‚ùå ‚ùå grhtra_grmod_install ‚ùå (install manually) SoapyRFNM SoapySDR support for RFNM devices ‚úÖ ‚úÖ ‚ùå soapyrfnm_grmod_install ‚ùå (install manually) SoapyHarogic SoapySDR support for Harogic devices ‚úÖ ‚úÖ ‚ùå soapyharogic_grmod_install ‚ùå (install manually) SoapyHydraSDR SoapySDR support for HydraSDR RFOne ‚úÖ ‚úÖ ‚úÖ hydrasdr_rfone_soapy_install ‚ùå (install manually) Known Issues:\ngr-ccsds: Currently broken due to strtod_l dependency issues deep-tempest: Available in separate sdr_deeptempest_beta image due to specific dependencies gr-fosphor: Only included in GPU-enabled builds (requires OpenCL/CUDA) gr-signal-hound: Requires manual installation (architecture-specific)","hardware-reverse-engineering#Hardware Reverse Engineering":"The reversing image provides tools for firmware analysis and hardware reverse engineering:\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default Kaitai Struct Declarative binary format parser kaitai-struct-compiler | ksc ‚úÖ ‚úÖ ‚úÖ kataistruct_soft_install ‚úÖ Unicorn Engine Lightweight multi-architecture CPU emulator Python unicorn module ‚úÖ ‚ùå ‚ùå unicorn_soft_install ‚úÖ Keystone Engine Lightweight multi-architecture assembler Python keystone module ‚úÖ ‚ùå ‚ùå keystone_soft_install ‚úÖ Radare2 Reverse engineering framework r2 | rabin2 | radare2 | rafind2 | ragg2 | rahash2 | rarun2 | rasm2 | rax2 ‚úÖ ‚úÖ ‚úÖ radare2_soft_install ‚úÖ Ghidra NSA reverse engineering suite ghidra | ghidraRun ‚úÖ ‚úÖ ‚úÖ ghidra_soft_install ‚úÖ Sasquatch Modified unsquashfs for non-standard SquashFS images sasquatch ‚úÖ ‚úÖ ‚úÖ sasquatch_soft_install ‚úÖ Unblob Accurate recursive extraction of firmware unblob ‚úÖ ‚úÖ ‚úÖ unblob_soft_install ‚úÖ Binwalk Firmware analysis and extraction binwalk ‚úÖ ‚úÖ ‚úÖ binwalk_soft_install ‚úÖ Binwalk v3 Rust-based binwalk rewrite binwalk ‚úÖ ‚úÖ ‚úÖ binwalkv3_soft_install ‚úÖ QNX6 Extractor QNX6 filesystem extractor qnx6extractor ‚úÖ ‚úÖ ‚úÖ qnx6extractor_soft_install ‚úÖ LLVM Compiler infrastructure for static analysis clang | clang++ | llvm-* | opt ‚úÖ ‚úÖ ‚ùå LLVM_install ‚úÖ AFL American Fuzzy Lop fuzzer afl-fuzz | afl-gcc | afl-g++ | afl-clang | afl-clang++ ‚úÖ ‚úÖ ‚ùå AFL_install ‚úÖ Honggfuzz Security-oriented fuzzer honggfuzz ‚úÖ ‚úÖ ‚ùå honggfuzz_install ‚úÖ Semgrep Static analysis for finding bugs semgrep ‚úÖ ‚úÖ ‚úÖ semgrep_install ‚úÖ Cppcheck Static analysis for C/C++ code cppcheck ‚úÖ ‚úÖ ‚úÖ cppcheck_install ‚úÖ Clang Static Analyzer C/C++/Objective-C static analyzer scan-build | scan-view ‚úÖ ‚úÖ ‚úÖ clang_static_analyzer_install ‚úÖ Joern Code analysis platform for C/C++ joern | joern-parse | joern-export | joern-flow | joern-lookup ‚úÖ ‚úÖ ‚úÖ joernsast_install ‚úÖ AppleDB Rust Apple device database in Rust appledb ‚úÖ ‚úÖ ‚úÖ appledb_rs_soft_install ‚ùå (commented out) Cutter Qt-based reverse engineering platform cutter ‚úÖ ‚úÖ ‚úÖ cutter_soft_install ‚úÖ ImHex Hex editor for reverse engineers imhex ‚úÖ ‚úÖ ‚úÖ imhex_soft_install ‚úÖ Qiling Advanced binary emulation framework Python qiling module ‚úÖ ‚ùå ‚ùå qiling_soft_install ‚ùå (debconf issues) EMBA Embedded firmware analyzer emba ‚úÖ ‚úÖ ‚úÖ emba_soft_install ‚ùå (takes long time) Bytecaster Bytecode analyzer bytecaster ‚úÖ ‚úÖ ‚úÖ bytecaster_soft_install ‚ùå (install manually) Architecture-Specific Tools:\nGhidra: Java-based, works on all architectures Radare2/Cutter: x86_64 only due to Qt dependencies Unicorn/Keystone: x86_64 only (ARM64 builds broken) Binwalk v3: Requires Rust 1.82+, uses cargo for installation Tool Locations:\n/reverse/ - Reverse engineering tools and projects Ghidra at /reverse/ghidra_X.X.X_PUBLIC/ ImHex: x86_64 uses .deb, ARM64 uses AppImage extraction","hardware-security#Hardware Security":"The hardware image focuses on general hardware security testing and analysis:\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default AVRDUDE AVR microcontroller programmer avrdude ‚úÖ ‚úÖ ‚úÖ avrdude_install ‚úÖ DSView Logic analyzer software for DSLogic DSView ‚úÖ ‚úÖ ‚úÖ dsview_install ‚úÖ PulseView Sigrok logic analyzer frontend pulseview ‚úÖ ‚úÖ ‚úÖ pulseview_install ‚úÖ Arduino IDE Integrated development environment for Arduino arduino | arduino-cli ‚úÖ ‚úÖ ‚úÖ arduino_ide_install ‚úÖ Logic 2 (Saleae) Logic analyzer software for Saleae devices logic2 | Logic ‚úÖ ‚ùå ‚ùå logic2_saleae_install ‚úÖ Flashrom Flash chip programmer flashrom ‚úÖ ‚úÖ ‚úÖ flashrom_install ‚úÖ dsl2sigrok Convert DSLogic VCD to Sigrok format dsl2sigrok ‚úÖ ‚úÖ ‚úÖ dsl2sigrok_install ‚úÖ SeerGDB Lightweight GUI frontend to GDB seergdb ‚úÖ ‚úÖ ‚úÖ seergdb_install ‚úÖ OpenOCD On-Chip Debugger for embedded devices openocd ‚úÖ ‚úÖ ‚úÖ openocd_install ‚úÖ dfu-util Device Firmware Upgrade utilities dfu-util | dfu-prefix | dfu-suffix ‚úÖ ‚úÖ ‚úÖ dfu_util_install ‚úÖ openFPGALoader Universal FPGA programming utility openFPGALoader ‚úÖ ‚úÖ ‚úÖ openFPGALoader_install ‚úÖ MTKClient MediaTek bootloader client mtkclient | mtk ‚úÖ ‚úÖ ‚úÖ mtkclient_install ‚úÖ esptool ESP8266/ESP32 ROM bootloader utility esptool.py | espefuse.py | espsecure.py ‚úÖ ‚úÖ ‚úÖ esptool_install ‚úÖ ngscopeclient Next-generation oscilloscope software ngscopeclient ‚úÖ ‚úÖ ‚úÖ ngscopeclient_install ‚úÖ GPU Drivers - NVIDIA NVIDIA GPU compute drivers nvidia-smi | nvidia-settings ‚úÖ ‚úÖ ‚úÖ install_GPU_nvidia ‚úÖ GPU Drivers - Intel Intel GPU compute drivers intel-gpu-tools ‚úÖ ‚úÖ ‚úÖ install_GPU_Intel ‚úÖ GPU Drivers - Radeon (up to 5000) AMD Radeon GPU drivers for older cards rocm-smi ‚úÖ ‚úÖ ‚úÖ install_GPU_Radeon_until5000 ‚úÖ GPU Drivers - Radeon (latest) AMD Radeon GPU drivers for latest cards rocm-smi ‚úÖ ‚úÖ ‚úÖ install_GPU_latest_Radeon ‚úÖ HydraNFC Trace Plugin Sigrok plugin for HydraNFC traces Sigrok HydraNFC decoder ‚úÖ ‚úÖ ‚úÖ hydranfc_trace_plugin_install ‚úÖ Logic Analyzer Software:\nLogic 2 (Saleae): x86_64 only, uses --no-sandbox flag automatically PulseView/Sigrok: Built from source with ARM64 libsigrokdecode patch DSView: Built from source for DSLogic devices Tool Locations:\n/hardware/ - Logic analyzers, programmers, and debugging tools Arduino IDE wrapper at /usr/sbin/arduino OpenOCD with extensive debug probe support","image-hierarchy#Image Hierarchy":"Each RF Swift image builds upon a foundation of tools, with specialized images adding domain-specific capabilities. Understanding this hierarchy helps you choose the most appropriate image for your needs:\ngraph TD; A[corebuild]--\u003eB[sdrsa_devices]; A--\u003eC[rfid]; A--\u003eD[automotive]; A--\u003eE[reversing]; A--\u003eF[sdrsa_devices_antsdr]; A--\u003eG[sdrsa_devices_rtlsdrv4]; A--\u003eH[network]; B[sdrsa_devices]--\u003eI[sdr_light]; B[sdrsa_devices]--\u003eJ[bluetooth]; B[sdrsa_devices]--\u003eK[telecom_utils]; B[sdrsa_devices]--\u003eL[hardware]; H[network]--\u003eM[wifi]; I[sdr_light]--\u003eN[sdr_full]; I[sdr_light]--\u003eO[sdr_deeptempest_beta]; K[telecom_utils]--\u003eP[telecom_2Gto3G]; K[telecom_utils]--\u003eQ[telecom_4G_5GNSA]; K[telecom_utils]--\u003eR[telecom_4Gto5G]; K[telecom_utils]--\u003eS[telecom_5G]; K[telecom_utils]--\u003eT[telecom_5G_bladerf];","manual-tool-installation#Manual Tool Installation":"Some tools are not installed by default but can be added after container creation. To install these tools:\nrfswift install -c container_name -i Common manually-installed tools:\nkismet_soft_install - Kismet wireless sniffer bettercap_soft_install - Network attack framework mdk3_soft_install - WiFi DoS testing wifipumpkin3_soft_install - Rogue AP framework install_soapy_modules - Additional SoapySDR device support pocketvna_sa_device - PocketVNA software (x86_64 only)","network-analysis#Network Analysis":"The network image contains general network analysis and security tools:\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default Burp Suite Community Web application security testing burpsuite ‚úÖ ‚úÖ ‚úÖ burpsuite_community_install ‚úÖ Nmap Network discovery and security auditing nmap | ncat | nping | ndiff ‚úÖ ‚úÖ ‚úÖ nmap_soft_install ‚úÖ Wireshark Network protocol analyzer wireshark ‚úÖ ‚úÖ ‚úÖ wireshark_soft_install ‚úÖ Metasploit Penetration testing framework msfconsole | msfvenom | msfdb | msfrpc | msfd ‚úÖ ‚úÖ ‚ùå metasploit_soft_install ‚úÖ Tshark Command-line network protocol analyzer tshark ‚úÖ ‚úÖ ‚úÖ tshark_soft_install ‚úÖ Impacket Python classes for network protocols psexec.py | smbexec.py | wmiexec.py | secretsdump.py | GetNPUsers.py ‚úÖ ‚úÖ ‚úÖ impacket_soft_install ‚úÖ AutoRecon Network reconnaissance automation autorecon ‚úÖ ‚úÖ ‚úÖ autorecon_soft_install ‚úÖ Responder LLMNR NBT-NS and MDNS poisoner responder | Responder.py ‚úÖ ‚úÖ ‚úÖ responder_soft_install ‚úÖ TruffleHog Find secrets in git repositories trufflehog ‚úÖ ‚úÖ ‚úÖ trufflehog_script_install ‚úÖ hping3 Network tool for crafting packets hping3 ‚úÖ ‚úÖ ‚úÖ hping3_soft_install ‚úÖ arping ARP-level ping utility arping ‚úÖ ‚úÖ ‚úÖ arping_soft_install ‚úÖ NetExec Network protocol exploitation (formerly CrackMapExec) nxc | netexec ‚úÖ ‚úÖ ‚úÖ netexec_soft_install ‚úÖ SubEnum Subdomain enumeration tool subenum ‚úÖ ‚úÖ ‚úÖ subenum_soft_install ‚úÖ WebCopilot Web application reconnaissance automation webcopilot ‚úÖ ‚úÖ ‚úÖ webcopilot_soft_install ‚úÖ gowitness Web screenshot and recon tool gowitness ‚úÖ ‚úÖ ‚úÖ gowitnes_soft_install ‚úÖ SIPVicious VoIP security testing suite sipvicious | svmap | svwar | svcrack | svreport | svcrash ‚úÖ ‚úÖ ‚úÖ sipvicious_soft_install ‚úÖ Voipire VoIP attack toolkit voipire ‚úÖ ‚úÖ ‚úÖ voipire_soft_install ‚úÖ SIPpts VoIP penetration testing suite sippts ‚úÖ ‚úÖ ‚úÖ sippts_soft_install ‚úÖ MBTget Modbus security assessment tool mbtget ‚úÖ ‚úÖ ‚úÖ mbtget_soft_install ‚úÖ Kismet Wireless network detector and IDS kismet | kismet_server | kismet_client ‚úÖ ‚úÖ ‚úÖ kismet_soft_install ‚úÖ Bettercap Swiss Army knife for network attacks bettercap ‚úÖ ‚úÖ ‚úÖ bettercap_soft_install ‚úÖ Hashcat Advanced password recovery hashcat ‚úÖ ‚úÖ ‚úÖ hashcat_soft_install ‚úÖ John the Ripper Password cracker john | unshadow | unique ‚úÖ ‚úÖ ‚úÖ john_soft_install ‚úÖ Caido Modern web security proxy caido ‚úÖ ‚úÖ ‚úÖ caido_soft_install ‚úÖ DonPAPI Dump DPAPI secrets remotely donpapi ‚úÖ ‚úÖ ‚úÖ donpapi_soft_install ‚ùå (install manually) BeEF Browser Exploitation Framework beef ‚úÖ ‚úÖ ‚úÖ beef_soft_install ‚ùå (install manually) Major Frameworks:\nMetasploit: Full penetration testing framework (x86_64/aarch64) NetExec: Network protocol exploitation Kismet: Wireless/Bluetooth packet capture and analysis Caido: Modern web security testing platform Burp Suite Community: Multi-architecture support (JAR fallback for non-x86_64)","next-steps#Next Steps":"Continue to the Configurations page to learn how to customize your RF Swift environment:\nConfiguration OptionsCustomize your RF Swift environment for optimal performance.","plutosdr-connection-issues#PlutoSDR Connection Issues":"If the PlutoSDR doesn‚Äôt appear with iio_info -s and you see errors like:\nwith backends: local xml ip usb Unable to create Local IIO context : No such file or directory (2) ERROR: Unable to create Avahi DNS-SD client :Daemon not running Scanning for IIO contexts failed: Text file busy (26) This can be resolved in two ways:\nOn Linux hosts: Ensure avahi-daemon is running on your host system Inside the container: Run the Avahi daemon with: avahi-daemon --no-drop-root --no-rlimits","rf-swift-tool-collection#RF Swift Tool Collection":"RF Swift Tool CollectionRF Swift provides a comprehensive suite of specialized tools for radio frequency and hardware security work. This page catalogs the tools available in each pre-built image.\nüìà RF Swift is in active development. The tool collection is regularly expanded and optimized for all supported architectures. Installation Status Key:\n‚úÖ Installed by default - Tool is included when you build/pull the image ‚ùå Install manually - Tool function exists but must be run manually after container creation ‚ùì Limited support - Tool may have architecture-specific issues","rfid-tools#RFID Tools":"The rfid image focuses on radio-frequency identification analysis and exploitation:\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default proxmark3 RRG/Iceman Proxmark3 firmware and client proxmark3 | pm3 ‚úÖ ‚úÖ ‚úÖ proxmark3_soft_install ‚úÖ libnfc Near Field Communication library and tools nfc-list | nfc-scan-device | nfc-poll | nfc-dep-initiator | nfc-dep-target ‚úÖ ‚úÖ ‚úÖ libnfc_soft_install ‚úÖ nfc-tools Utilities for libnfc nfc-barcode | nfc-read-forum-tag3 | nfc-emulate-forum-tag4 | nfc-mfclassic | nfc-relay-picc | nfc-jewel | nfc-mfultralight ‚úÖ ‚úÖ ‚úÖ libnfc_soft_install ‚úÖ mfoc MIFARE Classic Offline Cracker mfoc ‚úÖ ‚úÖ ‚úÖ mfoc_soft_install ‚úÖ mfcuk MIFARE Classic Universal toolKit mfcuk ‚úÖ ‚úÖ ‚úÖ mfcuk_soft_install ‚úÖ mfdread MIFARE dump reader and parser /rftools/rfid/mfdread/mfdread.py ‚úÖ ‚úÖ ‚úÖ mfread_soft_install ‚úÖ RFIDler Open-source RFID emulator and reader /root/thirdparty/RFIDler/ ‚úÖ ‚ùå ‚ùå rfidler_soft_install ‚úÖ miLazyCracker Automated MIFARE Classic cracking with DarkSide attack /rftools/rfid/miLazyCracker/ ‚úÖ ‚úÖ ‚úÖ miLazyCracker_soft_install ‚úÖ RFID Device Requirements: When using RFID tools, you need to ensure that your RFID reader device (typically appearing as /dev/ttyACM0) is properly bound to the container:\n# When creating a new container rfswift run -i rfid -n rfid_tools -s /dev/ttyACM0:/dev/ttyACM0 # Or with an existing container rfswift bindings add -c rfid_tools -d -t /dev/ttyACM0 # or without -d if you want to unplug and replug it when container is running","risc-v64#RISC-V64":"Growing support, most core SDR tools work Some tools installed from source due to package availability Limited pre-built binary support Python packages may require longer build times","rtl-sdr-kernel-module-conflicts#RTL-SDR Kernel Module Conflicts":"If your RTL-SDR device is unavailable when using tools like nfc-spy, the DVB-T kernel module may have claimed it. Blacklist the module with:\necho \"blacklist dvb_usb_rtl28xxu\" | sudo tee /etc/modprobe.d/blacklist-dvb_usb_rtl28xxu.conf You‚Äôll need to restart your host system after adding this blacklist entry.","sdr-full-environment#SDR Full Environment":"The sdr_full image builds on sdr_light to provide a comprehensive SDR development and analysis environment, including GNU Radio and specialized plugins.","sdr-light-tools#SDR Light Tools":"The sdr_light image includes essential software-defined radio tools for signal capture, analysis, and basic decoding.\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default GNU Radio Open-source SDR toolkit and signal processing framework gnuradio-companion | gnuradio-config-info | gr_modtool | gr_plot_* | grcc ‚úÖ ‚úÖ ‚úÖ gnuradio_soft_install ‚úÖ gr-osmosdr Common source/sink blocks for SDR hardware Part of GNU Radio ‚úÖ ‚úÖ ‚úÖ common_sources_and_sinks ‚úÖ SoapySDR modules Device abstraction layer for SDR hardware SoapySDRUtil | SoapySDRServer ‚úÖ ‚úÖ ‚úÖ install_soapy_modules ‚úÖ SoapyPlutoSDR PlutoSDR support for SoapySDR SoapySDR PlutoSDR module ‚úÖ ‚úÖ ‚úÖ install_soapyPlutoSDR_modules ‚úÖ KC908 Spectrum Analyzer DEEPACE KC908 spectrum analyzer software KC908 ‚úÖ ‚ùå ‚ùå kc908_sa_device ‚úÖ SoapyRFNM RFNM device support for SoapySDR SoapySDR RFNM module ‚úÖ ‚úÖ ‚ùå soapyrfnm_grmod_install ‚úÖ SoapyHydraSDR HydraSDR RFOne support for SoapySDR SoapySDR HydraSDR module ‚úÖ ‚úÖ ‚úÖ hydrasdr_rfone_soapy_install ‚úÖ SoapyHarogic Harogic device support for SoapySDR SoapySDR Harogic module ‚úÖ ‚úÖ ‚ùå soapyharogic_grmod_install ‚úÖ gr-bladerf bladeRF GNU Radio blocks GNU Radio bladeRF blocks ‚úÖ ‚úÖ ‚úÖ grbladerf_grmod_install ‚úÖ gr-signal-hound Signal Hound device GNU Radio support GNU Radio Signal Hound blocks ‚úÖ ‚úÖ ‚ùå grsignalhound_Receiver_grmod_install ‚úÖ gr-htra Harogic HTRA GNU Radio blocks GNU Radio HTRA blocks ‚úÖ ‚ùå ‚ùå grhtra_grmod_install ‚úÖ GQRX Software-defined radio receiver powered by GNU Radio gqrx ‚úÖ ‚úÖ ‚úÖ gqrx_soft_install ‚úÖ multimon-ng Digital decoder for multiple radio transmission modes multimon-ng ‚úÖ ‚úÖ ‚úÖ multimon_ng_soft_install ‚úÖ Universal Radio Hacker (URH) Wireless protocol investigation and reverse engineering urh ‚úÖ ‚úÖ ‚úÖ urh_soft_install ‚úÖ Inspectrum Offline radio signal analyzer inspectrum ‚úÖ ‚úÖ ‚úÖ inspectrum_soft_install ‚úÖ rtl_433 Generic data receiver for ISM band devices rtl_433 ‚úÖ ‚úÖ ‚úÖ rtl_433_soft_install ‚úÖ retrogram-rtlsdr Retro text-mode spectrogram for rtl-sdr retrogram-rtlsdr ‚úÖ ‚úÖ ‚úÖ retrogram_soapysdr_soft_install ‚úÖ LuaRadio Lightweight real-time SDR framework in Lua luaradio ‚úÖ ‚úÖ ‚úÖ luaradio_sdr_soft_install ‚úÖ dump1090 Mode S ADS-B decoder for aircraft tracking dump1090 ‚úÖ ‚úÖ ‚úÖ dump1090_soft_install ‚úÖ readsb Improved Mode S/ADS-B decoder readsb ‚úÖ ‚úÖ ‚úÖ readsb_soft_install ‚úÖ dumpvdl2 VDL Mode 2 decoder for aircraft ACARS dumpvdl2 ‚úÖ ‚úÖ ‚úÖ dumpvdl2_soft_install ‚úÖ dumphfdl HFDL decoder for HF aircraft communications dumphfdl ‚úÖ ‚úÖ ‚úÖ dumphfdl_soft_install ‚úÖ SDR++ Cross-platform SDR software with modern interface sdrpp ‚úÖ ‚úÖ ‚úÖ sdrpp_soft_fromsource_install ‚úÖ SDR++ Extra Modules Additional demodulators and sources for SDR++ SDR++ plugins ‚úÖ ‚úÖ ‚úÖ sdrpp_extramodules_install ‚úÖ Jupyter Notebook Interactive computing environment for SDR experiments jupyter | jupyter-notebook ‚úÖ ‚úÖ ‚úÖ jupyter_soft_install ‚úÖ Leo Bodnar GPSDO v1 Calibration tool for Leo Bodnar GPS reference v1 leobodnar-gpsdo-v1 ‚úÖ ‚úÖ ‚úÖ leobodnarv1_cal_device ‚úÖ Leo Bodnar GPSDO v2 Calibration tool for Leo Bodnar GPS reference v2 leobodnar-gpsdo-v2 ‚úÖ ‚úÖ ‚úÖ leobodnarv2_cal_device ‚úÖ KCSDI Calibration utilities for KC series devices kcsdi ‚úÖ ‚úÖ ‚úÖ KCSDI_cal_device ‚úÖ NanoVNASaver VNA software for NanoVNA devices NanoVNASaver ‚úÖ ‚úÖ ‚úÖ NanoVNASaver_cal_device ‚úÖ NanoVNA-QT Qt-based software for NanoVNA nanovna-qt ‚úÖ ‚úÖ ‚úÖ NanoVNA_QT_cal_device ‚úÖ GNSSLogger GNSS logging and calibration tool gnsslogger ‚úÖ ‚úÖ ‚úÖ gnsslogger_cal_device ‚úÖ LibreVNA Open-source Vector Network Analyzer software LibreVNA ‚úÖ ‚úÖ ‚úÖ librevna_cal_device_buildx ‚úÖ xnec2c NEC2 antenna modeling software xnec2c ‚úÖ ‚úÖ ‚úÖ xnec2c_cal_device ‚ùå (broken - fix source) GNSS-SDR Global Navigation Satellite Systems software receiver gnss-sdr ‚úÖ ‚úÖ ‚úÖ gnss_sdr_soft_install ‚úÖ Artemis SDR-based RF spectrum monitoring artemis ‚úÖ ‚úÖ ‚úÖ artemis_soft_install ‚úÖ GQRX Scanner Frequency scanner plugin for GQRX gqrx-scanner ‚úÖ ‚úÖ ‚úÖ gqrxscanner_sdr_soft_install ‚úÖ Lotus BUDC Tuner Lotus BUDC tuning device support lotus-budc ‚úÖ ‚úÖ ‚úÖ lotus_budc_tune_device ‚úÖ intercept Signal Intelligence Platform /rftools/sdr/intercept ‚úÖ ‚úÖ ‚úÖ intercept_soft_install ‚ùå Tool Locations: Most SDR tools are installed in standard system paths (/usr/bin, /usr/local/bin), with specialized tools in:\n/rftools/sdr/ - SDR-specific applications /rftools/analysers/ - Spectrum analyzer software /rftools/generators/ - Signal generator software","telecom-utilities#Telecom Utilities":"Foundation tools for cellular network analysis:\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default pycrate Python library for mobile network protocols (2G/3G/4G/5G) Python pycrate module ‚úÖ ‚úÖ ‚úÖ pycrate_soft_install ‚úÖ CryptoMobile Mobile network cryptographic functions (Milenage TUAK Kasumi) Python CryptoMobile module ‚úÖ ‚úÖ ‚úÖ cryptomobile_soft_install ‚úÖ PySIM SIM card management and programming pySim-shell.py | pySim-read.py | pySim-prog.py ‚úÖ ‚úÖ ‚úÖ pysim_soft_install ‚úÖ pySCTP Python bindings for SCTP protocol Python pysctp module ‚úÖ ‚úÖ ‚úÖ pysctp_soft_install ‚úÖ sysmo-usim-tool SIM card programming for Sysmocom cards sysmo-usim-tool ‚úÖ ‚úÖ ‚úÖ sysmoUSIM_soft_install ‚úÖ SCAT Signaling collection and analysis toolkit scat | signalcat ‚úÖ ‚úÖ ‚úÖ SCAT_soft_install ‚úÖ SigPloit Signaling exploitation framework sigploit ‚úÖ ‚úÖ ‚úÖ SigPloit_soft_install ‚úÖ PyHSS Python Home Subscriber Server pyhss ‚úÖ ‚úÖ ‚úÖ pyhss_soft_install ‚úÖ Bromelia Python Diameter protocol stack Python bromelia module ‚úÖ ‚úÖ ‚úÖ bromelia_soft_install ‚úÖ jSS7 Java SS7 protocol stack jSS7 tools ‚úÖ ‚ùå ‚ùå jss7_soft_install ‚úÖ Py5sig 5G NAS security tool py5sig ‚úÖ ‚úÖ ‚úÖ py5sig_soft_install ‚ùå (install manually) Modmobmap Mobile network mapping tool modmobmap ‚úÖ ‚úÖ ‚úÖ Modmobmap_soft_install ‚ùå (install manually) Python Libraries:\npycrate: Complete Python cellular protocol stack CryptoMobile: Mobile network cryptography (Milenage, TUAK, Kasumi, etc.) pysctp: Python SCTP bindings for signaling protocols bromelia: Diameter protocol stack for LTE/5G core","telecommunications#Telecommunications":"The telecommunications images are divided into several categories based on mobile network generations:","tool-categories#Tool Categories":"","tool-directory-organization#Tool Directory Organization":"RF Swift organizes tools in specialized directories for easier discovery:\n/rftools/ - Radio frequency analysis tools /rftools/sdr/ - SDR software and utilities /rftools/bluetooth/ - Bluetooth tools and firmwares /rftools/wifi/ - WiFi security tools /rftools/rfid/ - RFID readers and utilities /rftools/calibration/ - VNA and calibration tools /rftools/analysers/ - Spectrum analyzer software /rftools/generators/ - Signal generator software /hardware/ - Hardware security and testing tools /automotive/ - Vehicle communication and analysis tools /reverse/ - Reverse engineering and firmware analysis tools /telecom/ - Telecommunications tools /telecom/2G/ - GSM/2G base stations /telecom/3G/ - UMTS/3G tools /telecom/4G/ - LTE/4G tools /telecom/5G/ - 5G SA/NSA tools /telecom/SIM/ - SIM card tools /security/ - Security testing tools (Caido, etc.) /opt/network/ - Network security tools /opt/crack/ - Password cracking tools /sast/ - Static analysis security testing These directories complement the standard system paths (/usr/bin, /usr/local/bin) and contain specialized tools, scripts, and resources.","tool-documentation#Tool Documentation":"Most tools include built-in help available through the -h or --help flags:\ntool_name --help For more detailed documentation, many tools include man pages:\nman tool_name","tool-usage-tips#Tool Usage Tips":"","wi-fi-security#Wi-Fi Security":"The wifi image provides tools for Wi-Fi network analysis, packet capture, and security assessment:\nTool(s) Description Available commands amd64 aarch64 riscv64 Installation function Installed by default iproute2 Modern network configuration utilities ip | ss | bridge | rtmon ‚úÖ ‚úÖ ‚úÖ common_nettools ‚úÖ hostapd IEEE 802.11 AP and authentication server hostapd ‚úÖ ‚úÖ ‚úÖ common_nettools ‚úÖ dnsmasq Lightweight DNS/DHCP server for rogue AP dnsmasq ‚úÖ ‚úÖ ‚úÖ common_nettools ‚úÖ macchanger MAC address spoofing utility macchanger ‚úÖ ‚úÖ ‚úÖ common_nettools ‚úÖ tshark Command-line network protocol analyzer tshark ‚úÖ ‚úÖ ‚úÖ common_nettools ‚úÖ aircrack-ng Complete WiFi security auditing suite airbase-ng | aircrack-ng | airdecap-ng | airdecloak-ng | aireplay-ng | airmon-ng | airodump-ng | airodump-ng-oui-update | airolib-ng | airmon-zc | airtun-ng | besside-ng | easside-ng | tkiptun-ng | wesside-ng ‚úÖ ‚úÖ ‚úÖ aircrack_soft_install ‚úÖ hcxdumptool Modern WiFi capture tool for hashcat hcxdumptool ‚úÖ ‚úÖ ‚úÖ hcxdumptool_soft_install ‚úÖ hcxtools Convert captures to hashcat format hcxpcapngtool | hcxhashtool | hcxpsktool | hcxpmktool ‚úÖ ‚úÖ ‚úÖ hcxtools_soft_install ‚úÖ reaver WPS brute-force attack tool reaver | wash ‚úÖ ‚úÖ ‚úÖ reaver_soft_install ‚úÖ bully Alternative WPS brute-force tool bully ‚úÖ ‚úÖ ‚úÖ bully_soft_install ‚úÖ pixiewps WPS Pixie Dust attack implementation pixiewps ‚úÖ ‚úÖ ‚úÖ pixiewps_soft_install ‚úÖ eaphammer Targeted evil twin and credential harvesting /rftools/wifi/eaphammer/ ‚úÖ ‚úÖ ‚úÖ eaphammer_soft_install ‚úÖ airgeddon Multi-tool WiFi security auditing framework /rftools/wifi/airgeddon/airgeddon.sh ‚úÖ ‚úÖ ‚úÖ airgeddon_soft_install ‚úÖ wifite2 Automated WiFi attack tool wifite ‚úÖ ‚úÖ ‚úÖ wifite2_soft_install ‚úÖ sparrow-wifi WiFi and Bluetooth analyzer with SDR support /rftools/wifi/sparrow-wifi/ ‚úÖ ‚úÖ ‚úÖ sparrowwifi_sdr_soft_install ‚úÖ krackattacks-scripts KRACK attack proof-of-concept /rftools/wifi/krackattacks-scripts/ ‚úÖ ‚úÖ ‚úÖ krackattacks_script_soft_install ‚úÖ BeEF Browser Exploitation Framework for phishing beef | /opt/network/beef/beef ‚úÖ ‚úÖ ‚úÖ beef_soft_install ‚úÖ asleap LEAP/PPTP password cracker asleap ‚úÖ ‚úÖ ‚úÖ asleap_soft_install ‚úÖ roguehostapd Modified hostapd for advanced attacks hostapd-mana ‚úÖ ‚úÖ ‚úÖ roguehostapd_soft_install ‚úÖ wifiphisher Automated phishing attack framework wifiphisher ‚úÖ ‚úÖ ‚úÖ wifiphisher_soft_install ‚úÖ hostapd-mana Evil twin AP with credential harvesting hostapd-mana ‚úÖ ‚úÖ ‚úÖ hostapdmana_soft_install ‚úÖ dragonslayer WPA3 dragonfly vulnerability testing /rftools/wifi/wpa3/dragonslayer/ ‚úÖ ‚úÖ ‚úÖ wpa3_dragonslayer_soft_install ‚úÖ dragonforce WPA3 downgrade and DoS attacks /rftools/wifi/wpa3/dragonforce/ ‚úÖ ‚úÖ ‚úÖ wpa3_dragonforce_soft_install ‚úÖ dragondrain-and-time WPA3 resource exhaustion attacks /rftools/wifi/wpa3/dragondrain-and-time/ ‚úÖ ‚úÖ ‚úÖ wpa3_dragondrain_and_time_soft_install ‚úÖ wacker WPA3 SAE timing attacks /rftools/wifi/wpa3/wacker/ ‚úÖ ‚úÖ ‚úÖ wpa3_wacker_soft_install ‚úÖ Pyrit GPU-accelerated WPA/WPA2 cracker pyrit ‚úÖ ‚ùì ‚ùì Pyrit_soft_install ‚ùå (commented out - Python3 issues) mdk3 Wireless denial-of-service testing mdk3 ‚úÖ ‚úÖ ‚úÖ mdk3_soft_install ‚ùå (install manually) wifipumpkin3 Rogue AP framework wifipumpkin3 ‚úÖ ‚úÖ ‚úÖ wifipumpkin3_soft_install ‚ùå (install manually) fernwifi-cracker GUI-based WiFi security testing Fern-Wifi-Cracker ‚úÖ ‚úÖ ‚úÖ fernwificracker_soft_install ‚ùå (install manually) Required Capability: Wi-Fi tools require the NET_ADMIN capability to manipulate wireless interfaces. Always include this capability when running the container:\nrfswift run -i wifi -n wifi_tools -a NET_ADMIN If you see errors about insufficient permissions when using Wi-Fi tools, this capability is likely missing.\nWPA3 Attack Tools: RF Swift includes a complete suite of WPA3 vulnerability testing tools:\ndragonslayer - Dragonfly handshake vulnerabilities dragonforce - Downgrade and DoS attacks dragondrain-and-time - Resource exhaustion wacker - SAE timing attacks All WPA3 tools are located in /rftools/wifi/wpa3/","x86_64--amd64#x86_64 / AMD64":"Broadest tool support All GPU-accelerated tools available SignalHound and specialized SA software supported"},"title":"Included Tools"},"/docs/guide/running-rf-swift/":{"data":{"1-keeping-rf-swift-updated#1. Keeping RF Swift Updated":"RF Swift automatically checks for updates when launched:\n[!] You are running version: 0.4.8 (Obsolete) You can then trigger updates:\nrfswift update [!] Current version: 0.6.5-rc3 Latest version: v0.6.5-rc4 [!] Your current version is obsolete. Please update to version: v0.6.5-rc4 [i] Do you want to update to the latest version? (yes/no): yes [i] Latest release download URL: https://github.com/PentHertz/RF-Swift/releases/download/v0.6.5-rc4/rfswift_Linux_x86_64.tar.gz 4.58 MiB / 4.58 MiB [----------------------------------------------------------------------------------------------------------------------------------------] 100.00%% [+] File downloaded, extracted, and replaced successfully. If you don‚Äôt want to make any requests over the internet, you can also use -q or --disconnect option when using rswift.","2-image-management#2. Image Management":"","3-container-management#3. Container Management":"","4-session-recording-and-playback#4. Session Recording and Playback":"RF Swift provides comprehensive session recording capabilities for documentation, debugging, training, and compliance purposes.","5-device-and-resource-management#5. Device and Resource Management":"","6-network-configuration#6. Network Configuration":"RF Swift supports various network isolation modes:\nMode Description host No network isolation (default) bridge Default Docker network driver with isolation none Complete network isolation overlay Connect multiple Docker daemons ipvlan Full IPv4/IPv6 addressing control macvlan Assign MAC addresses to containers Example of using bridge mode with port mapping:\nrfswift run -i bluetooth -n my_container -t bridge -z 8000 -w 8000:127.0.0.1:80/tcp This command:\nUses the -t bridge option to enable bridge networking Maps container port 8000 to host port 80 on localhost with -w 8000:127.0.0.1:80/tcp Exposes port 8000 to other containers with -z 8000 For Wi-Fi and Bluetooth tools, you may need to add the NET_ADMIN capability: rfswift run -i wifi_tools -n my_container -a NET_ADMIN Be cautious when adding capabilities as they increase security risks if the container is compromised.","advanced-features#Advanced Features":"","advanced-recording-workflows#Advanced Recording Workflows":"Standalone Recording:\nFor situations where you want to record without immediately entering a container:\n# Start recording rfswift log start -o my-session.cast # ... perform your work ... # Stop recording rfswift log stop","audio-support#Audio Support":"RF Swift will warn if audio support is not properly configured:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚ö†Ô∏è Warning ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Warning: Unable to connect to Pulse server at 127.0.0.1:34567 ‚îÇ ... ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Enable audio support (run without sudo):\nrfswift host audio enable [+] Successfully loaded module-native-protocol-tcp with index 29","command-line-security-configuration#Command-Line Security Configuration":"RF Swift allows you to override or extend security settings directly from the command line when running containers. This is particularly useful for one-off tasks or testing configurations before adding them to your config file.\nComplete List of Security-Related Flags:\nrfswift run [options] Security Options: -u, --privileged int Set privilege level (1: privileged, 0: unprivileged) -a, --capabilities string Extra capabilities (separate with commas) -g, --cgroups string Extra cgroup rules (separate with commas) -m, --seccomp string Set Seccomp profile ('default' one used by default) -s, --devices string Extra devices mapping (separate with commas) Network Options: -t, --network string Network mode (default: 'host') -z, --exposedports string Exposed ports -w, --bindedports string Ports to bind between host and container -x, --extrahosts string Set extra hosts (default: 'pluto.local:192.168.1.2') Resource Options: -b, --bind string Extra volume bindings (separate with commas) -d, --display string Set X Display (default \"DISPLAY=:0\") -p, --pulseserver string PULSE SERVER TCP address (default \"tcp:127.0.0.1:34567\") Recording Options: --record Record the container session --record-output string Custom output filename for recording (default: auto-generated) Display Options: --no-x11 Disable X11 forwarding Examples of Command-Line Security Configurations:\nRun with specific privileges and capabilities:\nrfswift run -i penthertz/rfswift_noble:wifi -n wifi_tools -u 0 -a NET_ADMIN,NET_RAW This runs a container in unprivileged mode but adds the NET_ADMIN and NET_RAW capabilities.\nAdd custom cgroup rules and device mappings:\nrfswift run -i penthertz/rfswift_noble:sdr -n rtlsdr -g \"c 226:* rwm\" -s \"/dev/bus/usb:/dev/bus/usb\" This adds permission for device major number 226 and maps a specific RTL-SDR device.\nSet a custom seccomp profile:\nrfswift run -i penthertz/rfswift_noble:security -n forensics -m ~/custom_seccomp.json This applies a custom seccomp profile to the container.\nCombined security settings with recording:\nrfswift run -i penthertz/rfswift_noble:bluetooth -n bt_scanner \\ -t bridge \\ -a NET_ADMIN \\ -g \"c 226:* rwm,c 116:* rwm\" \\ -s \"/dev/bluetooth:/dev/bluetooth\" \\ -u 0 \\ --record --record-output bluetooth-assessment.cast This creates a container with:\nBridge networking mode NET_ADMIN capability Custom cgroup rules for devices with major numbers 226 and 116 Specific Bluetooth device mapping Unprivileged mode Session recording enabled Command-line settings always take precedence over config file settings. When using both, command-line options will extend or override the corresponding settings in your config.ini file.","command-overview#Command Overview":"Let‚Äôs explore the available commands with rfswift --help:\n888~-_ 888~~ ,d88~~\\ ,e, 88~\\ d8 888 \\ 888___ 8888 Y88b e / \" _888__ _d88__ 888 | 888 'Y88b Y88b d8b / 888 888 888 888 / 888 'Y88b, Y888/Y88b/ 888 888 888 888_-~ 888 8888 Y8/ Y8/ 888 888 888 888 ~-_ 888 \\__88P' Y Y 888 888 \"88_/ RF toolbox for HAMs and professionals rfswift is THE toolbox for any HAM \u0026 radiocommunications and hardware professionals Usage: rfswift [flags] rfswift [command] Available Commands: bindings Manage devices and volumes bindings build Build an image from a recipe capabilities Manage container capabilities cgroups Manage container cgroup rules cleanup Clean up containers and images commit Commit a container completion Generate and install completion script delete Delete an rfswift images download Download and save an image to tar.gz exec Exec a command export Export containers or images help Help about any command host Host configuration images RF Swift images management remote/local import Import containers or images install Install function script last Last container run log Record and replay terminal sessions ports Manage container ports remove Remove a container rename Rename a container retag Rename an image run Create and run a program stop Stop a container update Update RF Swift upgrade Upgrade container to a new/latest/another image Flags: -q, --disconnect Don't query updates (disconnected mode) -h, --help help for rfswift Use \"rfswift [command] --help\" for more information about a command. Privilege requirements by platform:\nLinux: sudo is required for most container operations when not using Docker Desktop Windows/macOS: With Docker Desktop or OrbStack, sudo is not necessary Windows: Commands related to USB binding require Administrator privileges","container-architecture-benefits#Container Architecture Benefits":"graph TD; A[Core build]--\u003eB[Image 1]; A--\u003eC[Docker image 2]; B--\u003eD[Container #1 from image 1]; B--\u003eE[Container #2 from image 1]; C--\u003eF[Container from image 2] This architecture provides significant advantages:\nPortability: Move environments between systems easily Isolation: Create separate environments for different tasks Disposability: Create, experiment with, and destroy environments without impact Specialization: Tailored environments for specific assessment needs Efficiency: No need to reinstall entire systems Performance: Less resource-intensive than VMs Time-saving: Quick deployment for last-minute assessment preparations Documentation: Built-in session recording for compliance and reporting RF Swift significantly flattens the Docker learning curve while providing powerful features like dynamic device binding, host resource integration, and session recording that would otherwise require considerable Docker expertise.","container-lifecycle-management#Container Lifecycle Management":"Save container changes as a new image:\nrfswift commit -c my_container -i my_new_image Rename a container:\nrfswift rename -n old_name -d new_name Remove a container:\nrfswift remove -c container_name Delete an image:\nrfswift delete -c penthertz/rfswift_noble:tag_name","container-listing-and-selection#Container Listing and Selection":"If you forget container names, use the last command:\nrfswift last ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚ÑπÔ∏è Up-to-date ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ You are running the latest version: 0.6.0-dev ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ü§ñ Last Run Containers ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Created ‚îÇ Image Tag (ID) ‚îÇ Container Name ‚îÇ Container ID ‚îÇ Command ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ 2025-04-11T16:47:02+02:00 ‚îÇ penthertz/rfswift_noble:hardware ‚îÇ hardware ‚îÇ b6e43a87e1f6 ‚îÇ /bin/zsh ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ 2025-04-11T16:23:43+02:00 ‚îÇ penthertz/rfswift_noble:bluetooth ‚îÇ missionbluetooth ‚îÇ 3d92cb59560f ‚îÇ /bin/zsh ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ 2025-04-11T16:18:22+02:00 ‚îÇ penthertz/rfswift_noble:rfid ‚îÇ missionrfid2 ‚îÇ 50cbccef53f5 ‚îÇ /bin/zsh ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ...","core-workflows#Core Workflows":"","creating-and-running-containers#Creating and Running Containers":"Create a new container from an image:\nrfswift run -i sdr_full -n my_sdr_container Recording Container Sessions:\nRF Swift includes built-in session recording for documentation, debugging, or training purposes:\n# Record with auto-generated filename rfswift run -i sdr_full -n my_sdr_container --record # Record with custom filename rfswift run -i sdr_full -n my_sdr_container --record --record-output my-session.cast During recording, your terminal title will display ‚Äúüî¥ RECORDING - RF Swift‚Äù as a visual reminder.\nSession recordings use the asciinema format (.cast files) which can be replayed, shared, or even uploaded to asciinema.org for embedding in documentation.","customizing-image-tags#Customizing Image Tags":"You can rename image tags for convenience or to match your default configuration:\nrfswift retag -i penthertz/rfswiftdev:sdr_full_amd64 -t myrfswift:latest [+] You are running version: 0.4.9 (Up to date) [+] Image renamed! This allows you to use the default tag in your configuration file:\nLinuxWindowsmacOS cat /home/username/.config/rfswift/config.ini [general] imagename = myrfswift:latest ... type C:\\Users\\username\\AppData\\Roaming\\rfswift\\config.ini [general] imagename = myrfswift:latest ... cat /Users/username/.config/rfswift/config.ini [general] imagename = myrfswift:latest ... With the default tag set, you can simplify the run command:\nrfswift run -n my_container # Equivalent to: rfswift run -i myrfswift:latest -n my_container Changing an image‚Äôs tag makes it a ‚Äúcustom‚Äù image in RF Swift, which means it won‚Äôt receive automatic updates from the official registry.","customizing-security-settings#Customizing Security Settings":"You can customize security settings both in the config file and via command-line parameters:\nAdding Capabilities:\n# Via command line rfswift run -i sdr_full -n my_container -a NET_ADMIN,SYS_PTRACE # Via config.ini caps = NET_ADMIN,SYS_PTRACE Custom Seccomp Profile:\n# Via command line rfswift run -i sdr_full -n my_container -m /path/to/seccomp.json # Via config.ini seccomp = /path/to/seccomp.json Additional Cgroup Rules:\n# Via command line rfswift run -i sdr_full -n my_container -g \"c 226:* rwm\" # Via config.ini cgroups = c 189:* rwm,c 166:* rwm,c 188:* rwm,c 226:* rwm Cgroup rules use the format type major:minor permission where:\ntype is c (character) or b (block) major:minor defines the device number (use * for wildcard) permission is r (read), w (write), m (mknod) For example, c 189:* rwm grants full access to all devices with major number 189.","default-security-configuration#Default Security Configuration":"By default, RF Swift runs containers in unprivileged mode with specific cgroup restrictions:\nUnprivileged Mode: Containers run without full root privileges on the host (privileged = false) Cgroup Restrictions: Controlled device access through character device major numbers: c 189:* rwm: Access to USB serial devices (ttyUSB*) c 166:* rwm: Access to ACM devices (ttyACM*) c 188:* rwm: Access to USB serial converters This provides a reasonable balance between functionality and security for RF applications.","dynamic-device-and-volume-binding#Dynamic Device and Volume Binding":"One of RF Swift‚Äôs most powerful features is the ability to add or remove device bindings to running containers:\n# Add a USB device to an existing container rfswift bindings add -c my_container -d -s /dev/ttyUSB0:/dev/ttyUSB0 # For some destination, use shortcuts with -t only rfswift bindings add -c my_container -d -t /dev/ttyUSB0 # Add a shared folder rfswift bindings add -c my_container -b ~/projects:/root/projects # Remove a binding rfswift bindings rm -c my_container -t /dev/ttyUSB0 [-d] # List current bindings rfswift bindings list -c my_container Don‚Äôt forget the -d switch if you want to deal with devices and not volumes.","host-isolation#Host Isolation":"RF Swift implements host isolation through several security mechanisms configured in your config.ini file:\n[container] privileged = false caps = seccomp = cgroups = c 189:* rwm,c 166:* rwm,c 188:* rwm","important-settings#Important settings":"Important settingsRF Swift provides a streamlined command-line interface to manage containers for RF and hardware security applications. This guide covers essential commands and workflows.\nOn Linux, unless you are using Docker Desktop, you will need to use sudo with the rfswift command for operations that require elevated privileges. To avoid using sudo for every Docker command, add your user to the docker group:\nsudo usermod -aG docker $USER newgrp docker","managing-recordings#Managing Recordings":"List and organize your recorded sessions:\n# List recordings in current directory rfswift log list # List recordings in specific directory rfswift log list --dir ~/recordings # List recordings from assessment project rfswift log list --dir /projects/client-assessment/recordings","next-steps#Next Steps":"Now you can dive right into:\nContainer ManagementManage a running containers with remapping features Container imagesPrebult images","recording-sessions#Recording Sessions":"Record your container sessions automatically:\n# Record during container creation rfswift run -i sdr_full -n my_container --record # Record when entering existing container rfswift exec -c my_container --record # Specify custom output filename rfswift run -i sdr_full -n my_container --record --record-output pentest-session.cast What Gets Recorded:\nAll terminal input and output Command execution and results Tool outputs and GUI application launches Timing information for accurate playback Recording Format:\nSessions are saved as .cast files (asciinema format) Compatible with asciinema.org for sharing Can be replayed at variable speeds Lightweight text-based format","replaying-sessions#Replaying Sessions":"Play back recorded sessions for review or demonstration:\n# Normal speed playback rfswift log replay -i rfswift-exec-mycontainer-20260112-134651.cast # 2x speed playback (useful for long sessions) rfswift log replay -i session.cast -s 2.0 # Slow motion for detailed analysis rfswift log replay -i session.cast -s 0.5","restarting-existing-containers#Restarting Existing Containers":"To restart the most recently used container:\nrfswift exec To restart a specific container by name:\nrfswift exec -c my_sdr_container Recording Exec Sessions:\nYou can also record when entering existing containers:\n# Record with auto-generated filename rfswift exec -c my_sdr_container --record # Record with custom filename and working directory rfswift exec -c my_sdr_container -w /root/projects --record --record-output debug-session.cast","using-rf-tools#Using RF Tools":"Once your container is running, you can use any included RF tools. For example, with an SDR device connected:\n‚îå‚îÄ[root@topms] - [~] - [Tue Sep 03, 15:15] ‚îî‚îÄ[$]\u003e sdrangel Running SDRAngel with an RTL-SDR GUI applications require:\nLinux: xhost installed and configured macOS: XQuartz properly configured Windows: Native support via Docker Desktop"},"title":"Running RF Swift"},"/docs/guide/sharing-files/":{"data":{"1-copy-calibration-files#1. Copy Calibration Files":"First, copy the calibration files from the provided USB to your host:\nContent of Harogic USB key # Copy from USB to host cp -R /media/username/37B6-82D6/CalFile ~/harogic_cal","2-bind-calibration-directory#2. Bind Calibration Directory":"When creating your container, bind the calibration directory to the proper location:\nrfswift run -i penthertz/rfswift_noble:sdr_light -n harogic_analysis \\ -b ~/harogic_cal:/rftools/analysers/SAStudio4_x86_64_05_23_17_06/bin/CalFile","3-run-sastudio#3. Run SAStudio":"Once inside the container, you can run SAStudio with the calibration files properly configured:\n# Inside the container sastudio Harogic device running with SaStudio","adding-bindings-to-existing-containers#Adding Bindings to Existing Containers":"If you forgot to bind a directory when creating a container, you can add it later using the bindings command:\nrfswift bindings add -c telecom_analysis -s ~/new_data -t /root/new_data","basic-directory-sharing#Basic Directory Sharing":"First, create a directory on your host system: # Create a directory on your host mkdir -p ~/shared_data Start a container with this directory bound to a location inside the container: rfswift run -i penthertz/rfswift_noble:telecom -n telecom_analysis -b ~/shared_data:/root/shared This binds your host‚Äôs ~/shared_data directory to /root/shared inside the container.","best-practices-for-file-sharing#Best Practices for File Sharing":"Use Consistent Directory Structures: Create a standardized directory layout for your assessments to make file management easier Organize by Project: Create separate shared directories for different projects or assessments Keep User Data Separate: Use dedicated directories for user data, software configurations, and temporary files Bind Read-Only When Possible: For reference data that shouldn‚Äôt be modified, consider mounting as read-only Use Descriptive Container Names: Name containers based on their purpose to easily identify bound directories later","bluetooth-device-binding#Bluetooth Device Binding":"For Bluetooth scanning and analysis:\nrfswift run -i penthertz/rfswift_noble:bluetooth -n bt_scanner \\ -s /dev/vhci:/dev/vhci \\ -a NET_ADMIN Bluetooth and Wi-Fi tools typically require the NET_ADMIN capability in addition to device bindings. Add this with the -a NET_ADMIN parameter.","common-rf-device-bindings#Common RF Device Bindings":"Device Type Host Path Container Path Required Capabilities RTL-SDR /dev/bus/usb /dev/bus/usb None HackRF /dev/bus/usb /dev/bus/usb None Proxmark3 /dev/ttyACM0 /dev/ttyACM0 None Bluetooth Adapters /dev/vhci /dev/vhci NET_ADMIN Wi-Fi Adapters /dev/ttyUSB0 /dev/ttyUSB0 NET_ADMIN Most RF Swift images automatically bind common device paths, but you may need to add specific devices or additional bindings for specialized hardware.","device-binding-for-rf-hardware#Device Binding for RF Hardware":"Many RF tools require access to specific hardware devices. RF Swift makes it easy to bind these devices to your containers.","directory-binding#Directory Binding":"The most common way to share files is by binding a directory from your host system to a location within the container using the -b parameter with the run command.","file-sharing-between-host-and-container#File Sharing Between Host and Container":"","harogic-spectrum-analyzer-setup#Harogic Spectrum Analyzer Setup":"Harogic spectrum analyzers require calibration files to function properly. Here‚Äôs how to configure a container for use with these devices:","missing-bindings#Missing Bindings":"If default bindings are missing, you can restore them while adding your custom bindings:\nrfswift run -i penthertz/rfswift_noble:sdr_full -n sdr_analysis \\ -b /tmp/.X11-unix:/tmp/.X11-unix,/dev/bus/usb:/dev/bus/usb,~/my_data:/root/my_data","multiple-directory-bindings#Multiple Directory Bindings":"You can bind multiple directories by separating them with commas:\nrfswift run -i penthertz/rfswift_noble:sdr_full -n sdr_project \\ -b ~/captures:/root/captures,~/scripts:/root/scripts,~/reports:/root/reports Always specify paths in the format host_path:container_path, and separate multiple bindings with commas.","next-steps#Next Steps":"Now that you understand how to share files and devices, you might want to create your own customized images:\nBuild Your Own ImageBecome a master chef and create your own custom RF Swift images.","permission-issues#Permission Issues":"If you experience permission errors when accessing shared directories:\n# On the host, ensure proper ownership sudo chown -R your_username:your_username ~/shared_data # Or make the directory world-writable (less secure) chmod -R 777 ~/shared_data","rfid-device-binding#RFID Device Binding":"For Proxmark3 and similar RFID tools, you may need to bind specific device paths:\n# Default Proxmark3 device rfswift run -i penthertz/rfswift_noble:rfid -n rfid_scanner -s /dev/ttyACM0:/dev/ttyACM0 # For multiple Proxmark3 devices rfswift run -i penthertz/rfswift_noble:rfid -n multi_proxmark \\ -s /dev/ttyACM0:/dev/ttyACM0,/dev/ttyACM1:/dev/ttyACM1","sharing-files-and-devices#Sharing Files and Devices":"Sharing Files and DevicesWhen conducting RF assessments with RF Swift, you‚Äôll need to exchange files between your host system and containers, as well as connect specialized hardware devices. This guide covers various file sharing methods and device binding techniques for common RF hardware.","specialized-hardware-configuration#Specialized Hardware Configuration":"","troubleshooting#Troubleshooting":"","using-harogic-with-sdr#Using Harogic with SDR++":"To use Harogic devices with SDR++, copy the calibration files to the correct location:\n# Inside the container cp -R /rftools/analysers/SAStudio4_x86_64_05_23_17_06/bin/CalFile /usr/bin Then launch SDR++:\nsdrpp Running SDR++ with Harogic","verifying-bindings#Verifying Bindings":"The container summary will display all active bindings:\nüßä Container Summary ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ ‚îÇ Container Name ‚îÇ telecom_analysis ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ X Display ‚îÇ :0 ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Shell ‚îÇ /bin/zsh ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Privileged Mode ‚îÇ true ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Network Mode ‚îÇ host ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Image Name ‚îÇ penthertz/rfswift_noble:telecom ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Size on Disk ‚îÇ 11150.42 MB ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Bindings ‚îÇ /tmp/.X11-unix:/tmp/.X11-unix,/dev/bus/usb:/dev/bus/usb, ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ /home/user/shared_data:/root/shared ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Extra Hosts ‚îÇ pluto.local:192.168.2.1 ‚îÇ ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ","working-with-shared-files#Working with Shared Files":"Once your directories are bound, you can access them from within the container:\n# Inside the container cd /root/shared touch analysis_results.txt echo \"Signal detected at 915MHz\" \u003e analysis_results.txt The file will be immediately available on your host system at ~/shared_data/analysis_results.txt.\nFile changes are bidirectional and immediate. Any changes made on either the host or container side will be instantly visible on the other side."},"title":"Sharing Files \u0026 Devices"},"/docs/quick-start/":{"data":{"":"","advanced-features#Advanced features":"Run Command Options:\nrfswift run -i sdr_full -n my_sdr_container The run command has numerous options for configuring your container environment:\nFlag Description -i, --image string Image name/tag to use (default: ‚Äòmyrfswift:latest‚Äô) -n, --name string Name for the container (makes it easier to reference later) -b, --bind string Extra bind mounts, separated by commas (e.g., /host/path:/container/path,/another/path:/in/container) -s, --devices string Extra device mappings in unprivileged mode, separated by commas (e.g., /dev/ttyUSB0:/dev/ttyUSB0) -a, --capabilities string Extra Linux capabilities, separated by commas (e.g., NET_ADMIN,SYS_ADMIN) -t, --network string Network mode (default: ‚Äòhost‚Äô) -u, --privileged int Set privilege level (1: privileged, 0: unprivileged) -e, --command string Command to execute (default: ‚Äò/bin/bash‚Äô) -d, --display string Set X Display (duplicates host‚Äôs env by default) (default ‚ÄúDISPLAY=:0‚Äù) -p, --pulseserver string PulseAudio server TCP address (default: ‚Äútcp:127.0.0.1:34567‚Äù) -w, --bindedports string Ports to bind (between container and host) -z, --exposedports string Ports to expose -x, --extrahosts string Set extra hosts (default: ‚Äòpluto.local:192.168.1.2‚Äô), separated by commas -g, --cgroups string Extra cgroup rules, separated by commas -m, --seccomp string Set Seccomp profile (default: ‚Äòdefault‚Äô) --no-x11 Disable X11 forwarding --record Record the container session --record-output string Custom output filename for recording (default: auto-generated) Share Files with the Container:\nTo share files between your host system and the container:\nrfswift run -i sdr_full -n my_sdr_container -b ~/sdr_projects:/home/user/projects You can bind multiple directories by separating them with commas:\nrfswift run -i sdr_full -n my_sdr_container -b ~/sdr_projects:/home/user/projects,~/datasets:/home/user/data Share Specific Devices:\nWhen running in unprivileged mode, you can share specific devices:\nrfswift run -i sdr_full -n my_sdr_container -s /dev/ttyUSB0:/dev/ttyUSB0 Multiple devices can be shared by separating them with commas:\nrfswift run -i sdr_full -n my_sdr_container -s /dev/ttyUSB0:/dev/ttyUSB0,/dev/ttyACM0:/dev/ttyACM0 If you plug the device after the container has started, or replug it later, you will have to stop it with command rswift stop -c . You can avoid this manipulation by mounting /dev/bus/usb:/dev/bus/usb as a volum instead with option -b when creating and running the container. This last manipulation may degrade the container‚Äôs isolation. Add Linux Capabilities:\nFor Wi-Fi and Bluetooth tools, you may need additional Linux capabilities:\nrfswift run -i wifi_tools -n my_wifi_container -a NET_ADMIN For multiple capabilities:\nrfswift run -i advanced_tools -n my_container -a NET_ADMIN,SYS_ADMIN Security Consideration: Be cautious when adding capabilities like NET_ADMIN. If the container becomes compromised, malicious programs could capture or manipulate network interfaces! Only add capabilities that are strictly necessary for your work. If your container is already running, you will be able to configure bindings, exposed ports, capabilities, cgroups later with bindings, cgroups, and capabilities (maybe more properties later ;)) Network Configuration:\nBy default, containers use the host network mode. To use a different network:\nrfswift run -i sdr_full -n my_sdr_container -t bridge Privilege Levels:\nControl container privilege level:\n# Run in unprivileged mode rfswift run -i sdr_full -n my_sdr_container -u 0 # Run in privileged mode (use with caution) rfswift run -i sdr_full -n my_sdr_container -u 1 Custom Commands:\nRun a specific command instead of the default shell:\nrfswift run -i gnuradio -n signal_processor -e \"gnuradio-companion\" Recording Sessions:\nYou can record your container sessions for documentation or debugging purposes:\n# Record with auto-generated filename rfswift run -i sdr_full -n my_sdr_container --record # Record with custom filename rfswift run -i sdr_full -n my_sdr_container --record --record-output my-session.cast Session recordings are saved as .cast files (asciinema format) that can be replayed later.\nUsing a named container with the -n flag makes it much easier to restart or access the container later.","alternative-from-sources#Alternative: from sources":"You can also download the latest (unstable) version from GitHub by cloning the repository, but you will need to build and use install.sh script as follows:\ngit clone https://github.com/PentHertz/RF-Swift.git cd RF-Swift # Step 1 - Building the project requirements ./build_project.sh # Step 2 - Run the installation script ./install.sh Then you should have the binary installed as well as all the requirements ;)","common-commands-reference#Common Commands Reference":"Command Description rfswift run -i IMAGE -n NAME Create and run a new container rfswift exec -c CONTAINER Enter an existing container rfswift images local List available local images rfswift last List all containers rfswift host audio enable Enable audio forwarding rfswift bindings add Add device or volume binding to existing container rfswift log replay -i FILE Replay a recorded session rfswift log list List all recorded sessions","getting-up-and-running-with-rf-swift#Getting Up and Running with RF Swift":"Here we will quickly get started with RF Swift using pre-built binaries and container images.\nOn Linux, unless you are using Docker Desktop, you may need to use sudo with the rfswift command for operations that require elevated privileges. To avoid using sudo for every Docker command, add your user to the docker group:\nsudo usermod -aG docker $USER newgrp docker To install RF Swift, you can either use pre-compiled binaries and existing container images (quickest method) or compile the Go project and/or Docker images from source. This guide focuses on the fastest way to get up and running.","install-rf-swift#Install RF Swift":"Skip this step if you already did it. This is just a reminder to show that the installation is pretty fast.","linux-and-macos#Linux and macOS":"The easiest way to install RF Swift with this command line:\ncurl -fsSL \"https://raw.githubusercontent.com/PentHertz/RF-Swift/refs/heads/main/get_rfswift.sh\" | sh But if you want to install it securely, we recommand using the installation script after downloading the latest version here:\n# Run the installation script ./install.sh The install.sh script will:\nInstall all required dependencies (Docker, BuildX, Go) Configure necessary services (xhost, PulseAudio) Set up proper permissions Create a system-wide alias for the rfswift command Install the latest RF Swift binary","linux-usb-device-access#Linux USB Device Access":"On Linux, you can access USB devices in two ways:\nDuring container creation - use the -s option to bind specific devices:\nrfswift run -i sdr_full -n my_container -s /dev/ttyUSB0:/dev/ttyUSB0 After container creation - use the powerful bindings feature to add devices to an existing container:\n# Add a new USB device to an existing container rfswift bindings add -c my_container -d -s /dev/ttyUSB0 -t /dev/ttyUSB0* # Same but shorter: Add a new USB device to an existing container with some destination rfswift bindings add -c my_container -t /dev/ttyUSB0 # Add a new volume to an existing container rfswift bindings add -c my_container -s /home/user/data -t /root/data # Remove a binding rfswift bindings rm -c my_container -s /dev/ttyUSB0 Note that to rebind a device, you need the -d switch.","list-running-containers#List Running Containers":"View all RF Swift containers:\nrfswift last","macos-usb-device-access#macOS USB Device Access":"For the moment Docker do not have proper way to forward USB accesses. USB devices cannot be used without using complex virtualization.","managing-existing-containers#Managing Existing Containers":"","managing-recordings#Managing Recordings":"# List all recordings in current directory rfswift log list # List recordings in specific directory rfswift log list --dir ~/recordings Session recordings are stored as .cast files in asciinema format, which can be uploaded to asciinema.org for sharing or embedded in documentation.","next-steps#Next Steps":"Dive right into the following section to learn more:\nFollow the GuideRead the complete guide and learn how to use RF Swift for your daily assessments.","pull-a-pre-built-image#Pull a Pre-built Image":"RF Swift provides several pre-built images to get you started quickly. For example, let‚Äôs pull a complete SDR image:\nrfswift images pull -i sdr_full You can also specify a custom tag for the image:\nrfswift images pull -i sdr_full -t my_custom_tag RF Swift Ubuntu Noble (version 24.04) images are in the way, and you can also test them using the penthertz/rfswift_noble: prefix. In case you want to use Noble images with a short tag name, modify you RF Swift profile config.ini file as follows:\n[general] imagename = myrfswift:latest repotag = penthertz/rfswift_noble ... Available Options:\n-i: Remote image label (required) -t: Local tag to assign to the pulled image (optional) -r: Repository to pull from (defaults to penthertz/rfswift) You can use the complete image tag penthertz/rfswift_noble:sdr_full if you prefer, or change the default repository in your RF Swift profile.","replaying-recordings#Replaying Recordings":"Play back recorded sessions:\n# Normal speed playback rfswift log replay -i rfswift-exec-mycontainer-20260112-134651.cast # 2x speed playback rfswift log replay -i session.cast -s 2.0","restart-an-existing-container#Restart an Existing Container":"To return to a previously created container:\nrfswift exec -c my_sdr_container You can also use the short command if you want to recall the last container:\nrfswift exec This restarts the container if it‚Äôs stopped and gives you a shell inside it.\nRecording Run and Exec sessions:\nWith run and exec, you can record exec sessions with --record argument:\n# Record a new container session rfswift run -i sdr_full -n my_container --record # Record with auto-generated filename rfswift exec -c my_sdr_container --record # Record with custom filename and working directory rfswift exec -c my_sdr_container -w /root/projects --record --record-output debug-session.cast","run-the-container#Run the Container":"Once you have an image, you can create and run a container:\nrfswift run -i sdr_full -n my_sdr_container This will start a container using the sdr_full image with the name my_sdr_container.\nWith some plateforms, some default devices may be non-existant. Your can use bindings or modify RF Swift‚Äôs configuration file to remove the device from the mapped device list.","save-container-state#Save Container State":"If you‚Äôve made changes to a container that you want to preserve:\nrfswift commit -c my_sdr_container -i my_custom_image This saves the current state of the container as a new image.","session-playback#Session Playback":"","stop-a-running-container#Stop a Running Container":"Running containers can be stopped using the stop as follows:\nrswift stop -c my_sdr_container","usb-device-management#USB Device Management":"USB device handling varies by platform:","use-rf-tools-in-the-container#Use RF Tools in the Container":"Once the container is running, you can use any of the pre-installed RF tools. For example, to run SDR++:\nConnect your SDR device to your computer Inside the container, run: sdrpp If you encounter audio issues, you can enable audio forwarding with: rfswift host audio enable This requires pulseaudio to be properly configured on your host system.","windows-or-manual-installation#Windows or Manual Installation":"If you prefer manual installation or are using Windows:\nDownload the latest binary from the official repository ‚Üó Rename the binary to rfswift (or rfswift.exe on Windows) Make the binary executable (on Linux/macOS): chmod +x rfswift When you run the binary for the first time, it will guide you through configuration:\nrfswift Config file not found. Would you like to create one with default values? (y/n) Select y to create a default configuration file or n to configure manually.","windows-usb-forwarding#Windows USB Forwarding":"On Windows, you‚Äôll need to explicitly forward USB devices to your container using the winusb commands in Administrator mode:\n# List available USB devices on Windows rfswift winusb list # Attach a specific device on Windows rfswift winusb attach -i"},"title":"üöÄ Quick Start"},"/docs/security/":{"data":{"-rf-swift-security-guidelines#üõ°Ô∏è RF Swift Security Guidelines":"üõ°Ô∏è RF Swift Security GuidelinesSecurity is a critical consideration when using RF Swift, as containerized environments often require special permissions to access hardware devices and network interfaces. This section provides comprehensive guidance on securing your RF Swift deployments while maintaining full functionality.","best-practices-at-a-glance#Best Practices at a Glance":"üîç Audit Permissions: Regularly review container privileges üîÑ Update Regularly: Keep RF Swift and images updated üß© Separate Workloads: Use dedicated containers for each assessment üö™ Remove When Done: Delete containers that are no longer needed üîí Monitor Usage: Watch for unusual container behavior üìπ Secure Recordings: Protect session recordings like sensitive assessment data üóëÔ∏è Clean Up: Delete recordings when they are no longer needed üîê Encrypt Storage: Use encrypted filesystems for recording storage","container-security-philosophy#Container Security Philosophy":"With RF Swift you can also adopt a security philosophy of:\nPrinciple of Least Privilege: Containers start with minimal privileges Dynamic Enhancement: Add capabilities only when needed Separation of Concerns: Use dedicated containers for different tasks Defense in Depth: Multiple security layers working together Data Protection: Secure handling of session recordings and sensitive data","key-security-areas#Key Security Areas":"Security GuidelinesEssential security practices for RF Swift","recording-data-handling-policy#Recording Data Handling Policy":"Organizations using RF Swift should establish clear policies:\nRetention: Define how long recordings are kept Storage: Specify secure storage locations Access: Control who can view recordings Sharing: Establish approval processes for sharing Disposal: Secure deletion when no longer needed Critical Security Warning: Session recordings may contain enough information to compromise assessed systems. Treat recordings with the same security level as penetration testing reports and ensure they are:\nStored on encrypted filesystems Protected with appropriate access controls Never committed to version control systems Sanitized before sharing with third parties","recording-in-compliance-frameworks#Recording in Compliance Frameworks":"For regulated environments:\nPCI DSS Considerations:\nRecordings containing cardholder data must be encrypted Access to recordings must be logged and audited Recordings must be included in data retention policies GDPR Considerations:\nRecordings may contain personal data Data subjects have rights to access and deletion Document recording purposes in privacy policies SOC 2 Considerations:\nRecordings can demonstrate security controls Access to recordings must be monitored Include recordings in information security policies","recording-security-best-practices#Recording Security Best Practices":"Storage and Access Control:\n# Store recordings in protected directories mkdir -p ~/assessments/recordings chmod 700 ~/assessments/recordings # Record to protected location rfswift run -i sdr_full -n assessment --record \\ --record-output ~/assessments/recordings/client-session.cast # Set appropriate permissions chmod 600 ~/assessments/recordings/client-session.cast Avoid Recording Sensitive Operations:\n# For sensitive credential entry, pause recording rfswift log stop # Manually enter credentials without recording # ... # Resume recording after sensitive operations rfswift log start -o continued-session.cast Sanitization Before Sharing:\n# Review recordings before sharing rfswift log replay -i session.cast # Edit recordings to remove sensitive data if needed # (Consider using asciinema tools or manual editing) # Never upload sensitive recordings to public platforms # like asciinema.org without thorough sanitization Encryption for Long-term Storage:\n# Encrypt recordings for archival gpg --encrypt --recipient your@email.com session.cast # Decrypt when needed gpg --decrypt session.cast.gpg \u003e session.cast","reporting-security-issues#Reporting Security Issues":"If you discover a security vulnerability in RF Swift, please report it responsibly by:\nCreating a GitHub Issue marked as ‚ÄúSecurity Concern‚Äù Join our Discord for security discussions Contact Project Maintainers directly for critical vulnerabilities ‚ö†Ô∏è Remember that security is a balance. RF Swift needs certain privileges to function correctly, especially when working with hardware devices. Follow these guidelines to maintain that balance safely while protecting sensitive data in recordings and assessments.","secure-recording-workflow-example#Secure Recording Workflow Example":"Here‚Äôs a complete secure workflow for using RF Swift with recording:\n# 1. Create encrypted storage for recordings mkdir -p ~/secure-assessments # Use LUKS, VeraCrypt, or native OS encryption # 2. Set restrictive permissions chmod 700 ~/secure-assessments # 3. Run assessment with recording rfswift run -i penthertz/rfswift_noble:sdr -n client-assessment \\ -u 0 \\ -t bridge \\ -a NET_ADMIN \\ --record \\ --record-output ~/secure-assessments/client-2024-01-12.cast # 4. After assessment, review and sanitize rfswift log replay -i ~/secure-assessments/client-2024-01-12.cast # 5. Create sanitized version for client delivery # (Remove any internal notes, sensitive paths, etc.) cp client-2024-01-12.cast client-2024-01-12-sanitized.cast # Edit sanitized version as needed # 6. Encrypt for archival gpg --encrypt --recipient security@company.com \\ ~/secure-assessments/client-2024-01-12.cast # 7. Securely delete original after archival shred -vfz -n 3 ~/secure-assessments/client-2024-01-12.cast","security-quick-reference#Security Quick Reference":"Setting Command Security Impact Unprivileged Mode rfswift run -u 0 ‚úÖ Recommended: Reduces container privileges Minimal Capabilities rfswift run -a NET_ADMIN ‚úÖ Recommended: Only add required capabilities Network Isolation rfswift run -t bridge ‚úÖ Recommended: Isolates container network Device Restrictions rfswift run -g \"c 189:* rwm\" ‚úÖ Recommended: Limit device access Session Recording rfswift run --record ‚ö†Ô∏è Data Sensitivity: May capture credentials and sensitive information Privileged Mode rfswift run -u 1 ‚ö†Ô∏è High Risk: Grants extensive privileges Default Network rfswift run -t host ‚ö†Ô∏è Medium Risk: Shares host network stack","session-recording-security#Session Recording Security":"RF Swift‚Äôs session recording feature provides valuable documentation capabilities, but recordings may contain sensitive information that requires careful handling.","what-gets-recorded#What Gets Recorded":"Session recordings capture everything displayed in your terminal, including:\n‚úÖ Commands and their outputs ‚úÖ Tool execution results ‚úÖ System information and configuration details ‚ö†Ô∏è Credentials entered in plaintext ‚ö†Ô∏è API keys and tokens ‚ö†Ô∏è Target system information ‚ö†Ô∏è Exploit code and techniques ‚ö†Ô∏è Network traffic analysis results","why-security-matters-for-rf-swift#Why Security Matters for RF Swift":"Radio frequency and hardware security work inherently requires elevated privileges. Balancing functionality with security is essential to:\nüîí Protect your host system from container exploits üõ°Ô∏è Prevent lateral movement if a container is compromised üîç Maintain isolation between different testing environments üß∞ Allow tools to function correctly with minimum necessary privileges üìπ Safeguard sensitive data in session recordings"},"title":"üõ°Ô∏è Security"},"/docs/security/guide_lines/":{"data":{"-additional-resources#üìö Additional Resources":"Docker Security Documentation Linux Capabilities Documentation Seccomp Security Profiles for Docker Control Groups Documentation NIST Guidelines for Media Sanitization OWASP Docker Security Cheat Sheet","-container-security-parameters#üîê Container Security Parameters":"RF Swift provides several mechanisms to control container privileges and access:","-docker-permissions#üê≥ Docker Permissions":"","-dynamic-permission-management#üîÑ Dynamic Permission Management":"One of RF Swift‚Äôs key advantages is the ability to add or remove permissions dynamically:\n# Temporarily add NET_ADMIN capability rfswift bindings add -c my_container -a NET_ADMIN # When finished with sensitive operations rfswift bindings remove -c my_container -a NET_ADMIN üõ°Ô∏è Best Practice: Add sensitive capabilities only when needed and remove them immediately afterward.","-keeping-updated#üîÑ Keeping Updated":"Security is an ongoing process. Stay informed about:\nüîî RF Swift updates üê≥ Docker security advisories üõ°Ô∏è Container security best practices üìπ Recording data protection regulations","-network-isolation#üåê Network Isolation":"Control the container‚Äôs network access for added security:\n# Complete network isolation rfswift run -t none -n isolated_container # Bridge network with limited connectivity rfswift run -t bridge -n bridge_container üõ°Ô∏è Network Modes:\nhost: Full network access (default, needed for many RF tools) bridge: Isolated network with optional port forwarding none: No network access (highest security) custom: Create custom networks for container-to-container communication","-real-world-secure-configurations#üåü Real-World Secure Configurations":"","-rf-swift-security-guidelines#üõ°Ô∏è RF Swift Security Guidelines":"üõ°Ô∏è RF Swift Security GuidelinesThis document provides important security guidelines for using RF Swift in various environments. Following these recommendations will help you maintain a secure system while enjoying the full capabilities of RF Swift.","-session-recording-security#üìπ Session Recording Security":"RF Swift‚Äôs session recording feature provides valuable documentation and compliance capabilities, but recordings contain sensitive information that requires careful handling.","common-capabilities-and-risks#Common Capabilities and Risks":"Capability Use Case Security Risk Recommendation NET_ADMIN Wi-Fi/Bluetooth tools Network traffic interception Only use with networking tools NET_RAW Raw socket access Packet spoofing Only use with specific networking tools SYS_PTRACE Debugging Process inspection, memory access Only use for debugging or reverse engineering SYS_ADMIN Mount operations Almost root equivalent Avoid unless absolutely necessary MKNOD Create device nodes Create arbitrary devices Rarely needed, avoid CHOWN Change file ownership Permission escalation Rarely needed for RF tools üõ°Ô∏è Recommendation: Only add the specific capabilities required for your tools. RF Swift automatically configures common capabilities for specific image types.","common-cgroup-rules#Common cgroup Rules":"Rule Devices Use Case c 189:* rwm USB serial devices (ttyUSB*) RTL-SDR, HackRF c 166:* rwm ACM devices (ttyACM*) Proxmark3, Arduino c 188:* rwm USB serial converters Various adapters c 116:* rwm ALSA devices Audio capture c 226:* rwm DRI (GPU) OpenCL acceleration üõ°Ô∏è Format Explanation:\nc = character device, b = block device Major#:Minor# = device identifier (use * for all minor devices) r = read, w = write, m = mknod (create device files)","control-groups-cgroups-#Control Groups (cgroups) üß©":"Cgroups limit container access to devices:\nrfswift run -g \"c 189:* rwm,c 166:* rwm\" # Allow specific device access","creating-custom-seccomp-profiles#Creating Custom Seccomp Profiles":"For highly sensitive environments, create a custom profile:\nStart with the default Docker profile Modify it to allow only required system calls Test thoroughly with your specific tools ‚ö†Ô∏è Warning: Overly restrictive seccomp profiles can cause tools to fail in unexpected ways.","docker-desktop-security-windows--macos--#Docker Desktop Security (Windows \u0026amp; macOS) ü™ü üçé":"Docker Desktop provides a more user-friendly approach to permissions:\nWindows: Docker Desktop runs through a VM and doesn‚Äôt require admin rights for normal operation after installation macOS: Docker Desktop handles permissions through the application üîí Recommended Settings:\nEnable the ‚ÄúUse Docker Compose V2‚Äù option Enable the ‚ÄúUse containerd for pulling and storing images‚Äù option Keep Docker Desktop updated to the latest version","full-client-assessment-example#Full Client Assessment example":"# Complete secure workflow with recording CLIENT=\"acme-corp\" DATE=$(date +%Y-%m-%d) RECORDING_DIR=\"/secure/clients/$CLIENT/recordings\" mkdir -p \"$RECORDING_DIR\" chmod 700 \"$RECORDING_DIR\" # Run assessment with recording rfswift run -i pentest -n \"${CLIENT}-assessment\" \\ -u 0 -t bridge -a NET_ADMIN \\ --record --record-output \"$RECORDING_DIR/${DATE}-assessment.cast\" # After assessment, secure the recording chmod 600 \"$RECORDING_DIR/${DATE}-assessment.cast\" gpg --encrypt --recipient security@company.com \\ \"$RECORDING_DIR/${DATE}-assessment.cast\" shred -vfz -n 3 \"$RECORDING_DIR/${DATE}-assessment.cast\"","hardware-reverse-engineering-with-isolation#Hardware Reverse Engineering with Isolation":"# Isolated environment for reverse engineering rfswift run -i reversing -n secure_reversing -u 0 -t none \\ -s /dev/ttyUSB0:/dev/ttyUSB0","linux-capabilities-#Linux Capabilities üß¢":"Capabilities provide a more granular approach to permissions than privileged mode:\nrfswift run -a NET_ADMIN,SYS_PTRACE # Add specific capabilities","privileged-mode-#Privileged Mode üö®":"rfswift run -u 1 # Privileged mode (1) rfswift run -u 0 # Unprivileged mode (0) ‚ö†Ô∏è Security Risk: Privileged containers can access all devices on the host and potentially escape container isolation.\nüõ°Ô∏è Recommendation: Use unprivileged mode (-u 0) whenever possible, which is the default in RF Swift.","running-docker-without-sudo-linux-#Running Docker Without Sudo (Linux) üêß":"By default, Docker requires root privileges on Linux systems, but this can be a security concern. Here‚Äôs how to use Docker without sudo:\nCreate the docker group (if it doesn‚Äôt exist):\nsudo groupadd docker Add your user to the docker group:\nsudo usermod -aG docker $USER Apply the new group membership:\nnewgrp docker Verify it works:\ndocker run hello-world ‚ö†Ô∏è Security Implications: Users in the docker group effectively have root privileges on the host. Only add trusted users to this group.","sdr-work-with-minimal-privileges#SDR Work with Minimal Privileges":"# RTL-SDR with just the required devices rfswift run -i sdr_light -n secure_sdr -u 0 -g \"c 189:* rwm\" -t bridge","seccomp-profiles-#Seccomp Profiles üîí":"Seccomp filters restrict the system calls a container can make:\nrfswift run -m /path/to/seccomp.json # Use custom seccomp profile üõ°Ô∏è Default Profile: RF Swift uses Docker‚Äôs default seccomp profile which blocks ~44 system calls out of 300+.","understanding-recording-data-sensitivity-#Understanding Recording Data Sensitivity üé•":"Session recordings capture everything displayed in your terminal session, including:\nLow-Risk Data:\nCommand sequences and tool usage Tool output and results System configurations High-Risk Data:\nüîë Credentials entered in plaintext (passwords, tokens, API keys) üéØ Target system information (IP addresses, hostnames, network architecture) üõ†Ô∏è Exploitation techniques and payloads üìä Captured traffic and sensitive network data üíæ File contents displayed in terminal üîê Private keys or certificates displayed ‚ö†Ô∏è Critical Warning: Treat session recordings with the same security level as penetration testing reports. They contain sufficient information to compromise assessed systems.","wi-fi-assessment-with-controlled-capabilities-and-recording#Wi-Fi Assessment with Controlled Capabilities and Recording":"# Start with minimal privileges, record for compliance rfswift run -i wifi -n wifi_assessment -a NET_ADMIN \\ --record --record-output /secure/assessments/wifi-test.cast"},"title":"Security guidelines"},"/docs/supports/":{"data":{"":"","feature-compatibility-matrix#Feature Compatibility Matrix":"Feature Linux Windows macOS Container Execution ‚úÖ ‚úÖ ‚úÖ GUI Applications ‚úÖ ‚úÖ ‚úÖ (with XQuartz) USB Device Forwarding ‚úÖ ‚úÖ (with usbipd) ‚ùå Audio Support ‚úÖ ‚úÖ (with PulseAudio) ‚ùì Limited Hardware Acceleration ‚úÖ ‚ùì Limited ‚ùì Limited Cross-Compilation ‚úÖ ‚úÖ (in WSL) ‚úÖ One-Line Installer ‚úÖ ‚ùå ‚úÖ","next-steps#Next Steps":"Dive right into the following section to get started:\nComparisons with dedicated distributionsComapre RF Swift with dedicated distributions Getting StartedSetup your environment Quick StartQuickly run RF Swift and start a container Compile RF Swift binaryCompile RF Swift and develop around the framework","operating-systems#Operating Systems":"Platform x86_64/amd64 arm64/v8 riscv64 Windows ‚úÖ Fully supported ‚ùì Limited testing ‚ùå Not supported Linux ‚úÖ Fully supported ‚úÖ Fully supported ‚úÖ Fully supported macOS ‚ùì Limited support ‚úÖ Supported (better inside a VM for USB devices) ‚ùå Not supported","questions-or-feedback#Questions or Feedback?":"‚ùì RF Swift is still in active development. Have a question or feedback? Feel free to open an issue!","supported-platforms#Supported Platforms":"RF Swift is designed to work across multiple platforms and architectures to suit your specific environment.","system-requirements#System Requirements":"The minimum requirements to run RF Swift are:\nCPU: Any dual-core CPU (quad-core recommended for better performance) RAM: 4GB minimum (8GB or more recommended) Storage: 10GB free space (20GB+ recommended for multiple container images) Docker: Automatically installed by the one-line installer Internet Connection: Required for initial setup and image downloads","tested-single-board-computers#Tested Single-Board Computers":"SBC Status Comments Raspberry Pi 5 ‚úÖ Works perfectly with most tools Milk-V Jupiter ‚úÖ Works perfectly with most tools, but slower than Raspberry Pi 5 Orange Pi RV2 ‚úÖ Works perfectly with most tools, but slower than Milk-V Jupiter Milk-V Mars ‚ùå Software support is currently unavailable. Docker installation is problematic UP Squared Series ‚úÖ Works perfectly with most tools"},"title":"‚öôÔ∏è Requirements \u0026 supported platforms"}}