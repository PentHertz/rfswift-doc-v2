{"/docs/":{"data":{"-hello-welcome-to-the-rf-swift-documentation#ğŸ‘‹ Hello! Welcome to the RF Swift documentation!":"ğŸ‘‹ Hello! Welcome to the RF Swift documentation!\nSupported OSes Supported architectures Presented at Socials ","comprehensive-container-orchestration#Comprehensive Container Orchestration":"RF Swift provides a complete orchestration solution that goes beyond traditional containers. Unlike standard Docker, RF Swift simplifies the entire workflow with a straightforward learning curve:\ngraph TD A[rfswift] --\u003e B[Host manager] B --\u003e C[Host] B --\u003e D[USB] B --\u003e F[Sound] B --\u003e G[Images Container manager] H[Dockerfiles] --\u003e G G --\u003e I[Pull] G --\u003e J[List] G --\u003e K[Save] G --\u003e L[Tag] G --\u003e M[Run] G --\u003e N[Exec] style A fill:#f9f,stroke:#333,stroke-width:4px style B fill:#bbf,stroke:#333,stroke-width:2px style H fill:#afa,stroke:#333,stroke-width:2px style G fill:#bbf,stroke:#333,stroke-width:2pxRF Swift handles everything from container creation and execution to pulling images, committing changes, and re-tagging. What sets it apart is the seamless integration of USB, video, and audio forwarding in a user-friendly interfaceâ€”tasks that typically require significant expertise in standard Docker environments.\nKey Components Go binary (rfswift) - Instruments containers and hosts to simplify the use of tools that may require:\nInternet connectivity Display Sounds USB accesses This rfswift is the main program you will interact with to:\nRun clean containers Execute inside running or paused containers Perform many magic actions that will make things work without a headache Docker images - Pre-built Docker container images are available in RF Swiftâ€™s repository. In case you want to bake your own environment, preserve some space, and have a special set-up, you will also find some Docker files you can edit to fit your expectations.","key-benefits-of-rf-swift#Key Benefits of RF Swift":" Flexibility: Use RF tools without disrupting your daily work environment Efficiency: Deploy only the tools you need, when you need them Security: Strong isolation between containers prevents cross-contamination Portability: Works across multiple architectures with consistent experience Resource Management: Optimized resource usage compared to full VMs ","next-steps#Next Steps":"Dive right into the following section to get started:\nGetting StartedLearn how to run RF Swift Compile RF Swift binaryCompile RF Swift and develop around the framework ","questions-or-feedback#Questions or Feedback?":" â“ RF Swift is still in active development. Have a question or feedback? Feel free to open an issue! ","rf-swift-vs-kali-linux-vs-dragon-os-comparison#RF Swift vs. Kali Linux vs. Dragon OS Comparison":" Feature RF Swift Kali Linux Dragon OS ğŸ–¥ï¸ Host OS Preservation âœ… Runs alongside your existing OS âŒ Typically requires dedicated partition or VM âŒ Typically requires dedicated partition or VM ğŸ§° Tool Isolation âœ… Tools run in containers without impacting system âš ï¸ Tools can affect system stability âš ï¸ Tools can affect system stability ğŸš€ Deployment Speed âœ… Fast container deployment âŒ Full OS installation required âŒ Full OS installation required ğŸ“¦ VM Requirement âœ… No VM needed âš ï¸ Needs VM for non-dedicated machines âš ï¸ Needs VM for non-dedicated machines ğŸ”§ Tool Availability âœ… Extensive tool collection for hardware security, RF, reversing, and more. âœ… Extensive tool collection for generic pentests âœ… Specialized for RF ğŸ”„ Tool Updates âœ… Easily updated containers âš ï¸ Requires system updates âš ï¸ Requires system updates ğŸ’¾ Storage Efficiency âœ… Customizable to fit small storage âŒ Requires significant disk space âŒ Requires significant disk space ğŸ›¡ï¸ Security Isolation âœ… Strong container isolation (custom confinement) âš ï¸ Limited isolation between applications âš ï¸ Limited isolation between applications ğŸ”Œ Network Containment âœ… Can isolate network activity âš ï¸ Network isolation requires additional setup âš ï¸ Network isolation requires additional setup ğŸ—ï¸ Architecture Support âœ… x86_64, ARM64, RISCV64 âœ… x86_64, ARM64 âš ï¸ Primarily x86_64 ğŸ§© Customization âœ… Highly customizable (specific tools only) âœ… Customizable but affects whole system âš ï¸ Limited customization ğŸ“± USB Device Access âœ… Streamlined USB forwarding âœ… Direct access âœ… Direct access ğŸ”Š Audio Support âœ… Container-based audio support âœ… Native audio support âœ… Native audio support ğŸŒ Internet Connectivity âœ… Configurable per container âœ… System-wide configuration âœ… System-wide configuration ","use-case-scenarios#Use Case Scenarios":" Scenario RF Swift Kali Linux Dragon OS Quick assessment on personal device â­â­â­ â­ â­ Deployment on a burner laptop â­â­â­ â­ â­ Dedicated pentesting machine â­â­ â­â­â­ â­â­â­ Low storage environments â­â­â­ â­ â­ Multiple architecture development â­â­â­ â­â­ â­ Isolated testing environment â­â­â­ â­â­ â­â­ ","what-is-rf-swift#What is RF Swift?":"RF Swift is a toolbox for creating an environment laboratory for your RF assessments, that can easily fit your prerequirements.\nThis toolbox is probably the best solution to deploy a generic, as well as a special environment securely, skipping the headache and waste of time when installing and using RF tools on same host.\nâš ï¸ Even if the project could work on macOS with some manual workaround, we do not advertise it for the moment, but this system will be fully supported in the near future. "},"title":"Documentation"},"/docs/development/":{"data":{"community-resources#Community Resources":"Join the RF Swift community to get help with development:\nDiscord: Join our Discord server GitHub Issues: Report bugs or request features Documentation: Refer to the API Reference (coming soon) ğŸš§ Additional development documentation is being actively created. We welcome contributions to the documentation, especially for specialized development scenarios and custom image creation. ","cross-platform-development#Cross-Platform Development":"RF Swift supports multiple platforms and architectures. When developing:\nTest on multiple operating systems when possible Use BuildX for cross-platform container builds Consider architecture-specific optimizations for ARM64 and RISC-V ","development-environment-setup#Development Environment Setup":"Before diving into RF Swift development, ensure your environment meets these prerequisites:\nPrerequisites Go 1.20+: Required for compiling the RF Swift binary Docker: Required for building and testing container images BuildX: Required for cross-platform image building Git: Required for source code management ","getting-started-with-development#Getting Started with Development":"RF Swift is designed to be extensible and customizable. You can tailor it to your specific RF assessment needs by:\nCompiling the binary from source with custom features or for specific architectures Building custom container images with specialized tools Contributing to the core project by adding new features or fixing issues ","key-development-areas#Key Development Areas":" Compile RF Swift BinaryBuild the RF Swift binary from source for different platforms and architectures Building Custom ImagesCreate specialized Docker images with your preferred RF and security tools Extending RF SwiftAdd new features and capabilities to the RF Swift framework Contributing to RF SwiftGuidelines for submitting code, reporting issues, and collaborating with the community ","rf-swift-development-guide#RF Swift Development Guide":"RF Swift Development GuideThis section covers topics related to developing with RF Swift, building custom components, and contributing to the project. Whether you want to compile the RF Swift binary from source, create custom container images, or extend the projectâ€™s capabilities, youâ€™ll find the necessary guidance here."},"title":"ğŸ§‘â€ğŸ³ Development"},"/docs/development/building-images/":{"data":{"":"Available images are all present in the images submodule that can be checked with git as follows inside RF Swift root directory:\ngit submodule update --init --recursive When entering the images directory, you can see different files and directory:\nconfig: where configurations files are stored for specific tools; Dockerfiles: Docker files to build images; rules: some dev rules files specific to devices; run: bash script we want to run; scripts: installation scripts. To build you own images, the important dicterories are scripts and Dockerfiles.","list-of-harness-functions#List of harness functions":" Function Arguments Description colorecho arg1: String Display text in blue criticalecho arg1: String Display error in red and exit 1 criticalecho-noexit arg1: String Display error in red only goodecho arg1: String Display text in green installfromnet arg1: String In case an internet action is not working, this function will do 5 attempt to get resources install_dependencies arg1: String for dependencies Function doing installfromnet â€˜apt-fast install -y â€™ grclone_and_build arg1: repo URL; arg2: destination directory, arg3: function installation name; arg4: build dir for cmake; arg5: git branch; next args*: cmake arguments Function responsible to install GNU Radio modules from GitHub gitinstall arg1: repo URL; arg2: function name that calls it; arg3: branch Function that will fetch a git project cmake_clone_and_build arg1: repo URL, arg2: cmake build directory; arg3: branch; arg4: reset commit, if necessary; arg5: function name that calls it; other args*: cmake args* Function that handles a cmake project from Git check_and_install_lib arg1: library name to check; arg2: pkg config name Checks if library exist, and install it if not detected ","making-a-custom-image#Making a custom image":"So let say we want to cook a light images, for an RTL-SDR v4 device only, and just need GQRX tool, we can use the corebuild images reference at the begining of our Docker file:\nFROM penthertz/rfswift:corebuild To make the image be recognized by RF Swift, we need to use also the following labels:\nLABEL \"org.container.project\"=\"rfswift\" LABEL \"org.container.author\"=\"Super author\" # optional After that, you can put all function you want to install, but remember to update packages manager list first:\n... RUN apt-fast update # required before! RUN ./entrypoint.sh rtlsdrv4_devices_install \u0026\u0026 \\ ./entrypoint.sh gqrx_soft_install ... And voilÃ !\nDo not hesitate to finish the Docker file cleaning stuff:\n# Cleaning and quitting WORKDIR /root/ RUN rm -rf /root/thirdparty \u0026\u0026 \\ rm -rf /root/rules/ \u0026\u0026 \\ rm -rf /root/config/ \u0026\u0026 \\ apt-fast clean RUN DEBIAN_FRONTEND=noninteractive rm -rf /var/lib/apt/lists/* ","making-your-own-installation-function#Making your own installation function":"Creating a source file Installation functions are called by entrypoint.sh script inside RF-Swift/images/scripts directory.\nThe different installation function are included in some script files:\n$ ls automotive_software.sh common.sh entrypoint.sh lab_software.sh rf_tools.sh sast_software.sh sdr_softwares.sh terminal_harness.sh cal_devices.sh corebuild.sh gr_oot_modules.sh reverse_software.sh sa_devices.sh sdr_peripherals.sh telecom_software.sh If you want to create a new script file, and include it, you need also to include it in entrypoint.sh as follows:\n#!/bin/bash ... source yournewsourcefile.sh Making functions To make a function, you will then just need to call it as you whish, but something that could be practical and easy to copy for users such as:\nfunction newsuper_soft_install() { // your code here } So you can then put any script you want, but do be efficient, we also provide you with some harness functions to make things easier"},"title":"Building images"},"/docs/development/compiling-rfswift/":{"data":{"":"The project can install from source by following the simple steps:","installing-rf-swift-from-source#Installing RF Swift from source":" Get binary from GitHub Get the latest commit from the the official repository:\ngit clone https://github.com/PentHertz/RF-Swift.git Use the installation script Two scripts are available to install all development tools if not installed and build the project:\ninstall.sh: Installation script for Linux, handling also the installation of Docker (also on Steam Deck), Buildx, and go. build-windows.bat If you are running the install.sh script, it will ask you if you want to install it for a Steam Deck. If yes, this will also unlock Steam OS from read-only.\n./install.sh [+] Checking Docker installation Are you installing on a Steam Deck? (yes/no) Choose an option: After this process, install.sh will take care for Golang, Docker, Build X, and compose installation.\nOn Linux, you will have also the choice to make an alias for this binary:\nDo you want to create an alias for the binary? (yes/no): â„¹ï¸ The alias will allow you to start the binary with rfswift command. And then ask you if you want to build a Docker image (1), or pull an existing one (2), or exit the process (3):\nDocker is already installed. Moving on. Docker Buildx is already installed. Moving on. Docker Compose v2 is already installed. Moving on. [+] Installing Go golang is already installed in /usr/local/go/bin. Moving on. [+] Building RF Switch Go Project RF Switch Go Project built successfully. Do you want to build a Docker container, pull an existing image, or exit? 1) Build Docker container 2) Pull Docker image 3) Exit Choose an option (1, 2, or 3): You can always choose to build images, or pull images later.\nBeak your own imagesMake your own images, save space and enjoy your environment Managing imagesList local and remote images, and pull them from the official registry Running the container After building, or pulling an existing image, you can run the container and enjoy the included tools !\nsudo ./rfswift run -i penthertz/rfswift:sdr_full -n supercontainername ","next#Next":"Now your are ready to use RF Swift with provided images, build your own images, and contribute on the Go binary and the content of images.\nGetting StartedLearn how to run RF Swift with provided images ","restarting-a-container#Restarting a container":"You can create as many fresh container you want, but sometimes you want to get back to previous job.\nTo restart a container, you can do it with the following command using -c nameofthecontainer:\nsudo ./rfswift exec -c supercontainername "},"title":"Compiling RF Swift"},"/docs/getting-started/":{"data":{"architecture-overview#Architecture Overview":"RF Swift organizes its functionality in a hierarchical structure:\ngraph TD A[rfswift] --\u003e B[Host manager] B --\u003e C[Host] B --\u003e D[USB] B --\u003e F[Sound] B --\u003e G[Images Container manager] H[Dockerfiles] --\u003e G G --\u003e I[Pull] G --\u003e J[List] G --\u003e K[Save] G --\u003e L[Tag] G --\u003e M[Run] G --\u003e N[Exec] style A fill:#f9f,stroke:#333,stroke-width:4px style B fill:#bbf,stroke:#333,stroke-width:2px style H fill:#afa,stroke:#333,stroke-width:2px style G fill:#bbf,stroke:#333,stroke-width:2pxThis structure allows RF Swift to provide:\nComprehensive container management Host resource integration Device forwarding (USB, audio, display) Streamlined workflow for RF testing and development ","feature-compatibility-matrix#Feature Compatibility Matrix":" Feature Linux Windows macOS Container Execution âœ… âœ… âœ… GUI Applications âœ… âœ… âœ… (with XQuartz) USB Device Forwarding âœ… âœ… (with usbipd) âŒ Audio Support âœ… âœ… (with PulseAudio) â“ Limited Hardware Acceleration âœ… â“ Limited â“ Limited Cross-Compilation âœ… âœ… (in WSL) âœ… ","getting-started-with-rf-swift-#Getting Started with RF Swift ğŸš€":"Getting Started with RF Swift ğŸš€This guide will help you get started with RF Swift by covering system requirements, installation steps, and next actions.","next-steps#Next Steps":"Dive right into the following sections to continue:\nQuick StartRunning RF Swift with pre-built images and binary Developing and ContributingCompile binary and build images from sources, contribute to the project ","supported-platforms#Supported Platforms":"RF Swift is designed to work across multiple platforms and architectures to suit your specific environment.\nOperating Systems Platform x86_64/amd64 arm64/v8 riscv64 Windows âœ… Fully supported â“ Limited testing âŒ Not supported Linux âœ… Fully supported âœ… Fully supported âœ… Fully supported macOS â“ Limited support âœ… Supported (better inside a VM for USB devices) âŒ Not supported Tested Single-Board Computers SBC Status Comments Raspberry Pi 5 âœ… Works perfectly with most tools Milk-V Jupiter âœ… Works perfectly with most tools, but slower than Raspberry Pi 5 Milk-V Mars âŒ Software support is currently unavailable. Docker installation is problematic UP Squared Series âœ… Works perfectly with most tools ","system-requirements#System Requirements":"The minimum requirements to run RF Swift are:\nLinux (preferred)WindowsmacOS Linux Requirements â„¹ï¸ On Linux, Docker, BuildX, and Go can be directly installed with the install.sh script included in the repository. Essential Components Docker: Required to run RF Swift containers curl -fsSL \"https://get.docker.com/\" | sh xhost: Required for GUI application support (install via your distributionâ€™s package manager) PulseAudio: Required for audio support (install via your distributionâ€™s package manager) Optional Components Go Compiler: Required if you want to build RF Swift from source BuildX: Required for cross-architecture compilation Quick Installation RF Swift provides a comprehensive installation script that automatically installs all required tools and dependencies on Linux systems.\n# Clone the repository git clone https://github.com/PentHertz/RF-Swift.git cd RF-Swift # Run the installation script to automatically install all dependencies ./install.sh The install.sh script will:\nInstall Docker if not already present Set up BuildX for cross-architecture support Install Go compiler if needed Configure xhost for GUI application access Set up PulseAudio for sound Configure user permissions for Docker Download and install the latest RF Swift binary This is the recommended method for Linux users as it ensures all components are correctly configured to work together.\nWindows Requirements Required Software Docker Desktop to run containers usbipd to bind USB devices to the host For Audio Support For programs requiring PulseAudio:\nFollow the setup guide on Linux Uprising Use the updated binaries available at pgaskin.net/pulseaudio-win32 âš ï¸ Make sure Docker Desktop runs in WSL2 mode for optimal performance and compatibility. Installation Steps Install Docker Desktop and ensure WSL2 integration is enabled Install usbipd for USB device support Set up PulseAudio if audio functionality is needed Download the latest RF Swift binary from the releases page macOS Requirements âš ï¸ macOS support will be fully implemented soon. Currently, some features may have limited functionality. Current Status Container functionality works without USB forwarding For full functionality including USB device support, running in a Linux VM is recommended Required Software Docker Desktop for macOS XQuartz for X11 forwarding (optional) Known Limitations USB device forwarding is not currently supported natively Some specialized RF tools may have compatibility issues ","troubleshooting#Troubleshooting":"If you encounter issues during installation or usage:\nCheck the GitHub Issues page for known problems Verify your Docker installation is working correctly with docker run hello-world Ensure you have the required permissions (e.g., user is in the docker group on Linux) Join our Discord community for direct assistance "},"title":"Getting Started"},"/docs/guide/":{"data":{"":"This section covers topics related on how to run RF Swift and use the different softwares installed default images.\nRunning RF Swift Configurations Container images Included tools Host actions Sharing files "},"title":"ğŸ“– Guide"},"/docs/guide/configurations/":{"data":{"best-practices#Best Practices":" Base Configuration: Set your common preferences in the config.ini file Special Cases: Use command-line flags for one-time or specialized settings Security First: Keep the privileged = false setting when possible and only add specific capabilities as needed Dynamic Adjustments: Use the bindings feature for on-the-fly modifications Device Access: Be selective about device mappings; only share what is needed ","command-line-configuration#Command-Line Configuration":"You can override any configuration setting when running a container using command-line flags with the run command:\nrfswift run [flags] Available Flags Flags: -b, --bind string Extra bindings (separate with commas) -w, --bindedports string Ports to bind between host and container -a, --capabilities string Extra capabilities (separate with commas) -g, --cgroups string Extra cgroup rules (separate with commas) -e, --command string Command to execute (default: '/bin/bash') -s, --devices string Extra device mappings (separate with commas) -d, --display string Set X Display (default: \"DISPLAY=:0\") -z, --exposedports string Ports to expose -x, --extrahosts string Set extra hosts (default: 'pluto.local:192.168.1.2') -h, --help Help for run command -i, --image string Image to use (default: 'myrfswift:latest') -n, --name string Container name -t, --network string Network mode (default: 'host') -u, --privileged int Set privilege level (1: privileged, 0: unprivileged) -p, --pulseserver string PulseAudio server address (default: \"tcp:127.0.0.1:34567\") -m, --seccomp string Set Seccomp profile (default: 'default') Global Flags: -q, --disconnect Don't query updates (disconnected mode) Examples # Run with custom image and name rfswift run -i penthertz/rfswift:sdr_full -n my_sdr_container # Share a host directory with the container rfswift run -i penthertz/rfswift:sdr_full -b /home/user/captures:/data/captures # Add network capabilities for Wi-Fi tools rfswift run -i penthertz/rfswift:wifi -a NET_ADMIN # Use bridge network with port mapping rfswift run -i penthertz/rfswift:sdr_full -t bridge -w 8080:80/tcp # Specify a custom shell rfswift run -i penthertz/rfswift:sdr_full -e /bin/bash ","common-configuration-scenarios#Common Configuration Scenarios":"SDR Development Environment rfswift run -i penthertz/rfswift:sdr_full -n sdr_dev \\ -b ~/sdr_projects:/projects \\ -s /dev/ttyUSB0:/dev/ttyUSB0 Wi-Fi Security Testing rfswift run -i penthertz/rfswift:wifi -n wifi_testing \\ -a NET_ADMIN,NET_RAW \\ -b ~/wifi_captures:/captures Offline Device Analysis # Create a container with no network rfswift run -i penthertz/rfswift:reversing -n firmware_analysis \\ -t none \\ -b ~/firmware:/firmware ","dynamic-container-modification-with-bindings#Dynamic Container Modification with Bindings":"RF Swift offers a unique feature that Docker doesnâ€™t provide natively: the ability to modify bindings for existing containers. This eliminates the need to recreate containers when you need to add or remove bindings.\nBindings Command Overview rfswift bindings This command has two subcommands:\nadd: Add a binding to an existing container rm: Remove a binding from an existing container Adding Bindings to Existing Containers To add a new binding to a running or stopped container:\nrfswift bindings add -c \u003ccontainer_name\u003e -t \u003ctarget_path\u003e [-s \u003csource_path\u003e] Parameters:\n-c, --container: Container name or ID (required) -t, --target: Path inside the container (required) -s, --source: Path on the host (optional, defaults to same as target) Examples:\n# Add a simple directory binding rfswift bindings add -c my_sdr_container -s /home/user/data -t /data # Add a device binding rfswift bindings add -c my_bt_container -s /dev/bluetooth -t /dev/bluetooth # When source and target are identical rfswift bindings add -c my_container -t /dev/ttyUSB0 Removing Bindings from Containers To remove an existing binding:\nrfswift bindings rm -c \u003ccontainer_name\u003e -t \u003ctarget_path\u003e [-s \u003csource_path\u003e] Example:\n# Remove a binding rfswift bindings rm -c my_container -t /data Docker API Version Compatibility If you encounter a Docker API version mismatch error:\nError response from daemon: client version 1.47 is too new. Maximum supported API version is 1.45 You can set the API version to match your Docker engine:\nsudo DOCKER_API_VERSION=1.45 rfswift bindings add -c my_container -s /tmp -t /root/myshare For persistent configuration, add this to your shell profile:\n# Add to ~/.bashrc, ~/.zshrc, etc. export DOCKER_API_VERSION=1.45 ","profile-configuration#Profile Configuration":"Configuration File Location RF Swift looks for a profile configuration file in a platform-specific location:\nLinuxWindowsmacOS /home/username/.config/rfswift/config.ini C:\\Users\\username\\AppData\\Roaming\\rfswift\\config.ini /Users/username/.config/rfswift/config.ini If this file doesnâ€™t exist when you first run RF Swift, youâ€™ll be prompted to create one with default settings.\nConfiguration File Structure The config.ini file is organized into sections for different aspects of RF Swiftâ€™s behavior:\n[general] imagename = myrfswift:latest repotag = penthertz/rfswift [container] shell = /bin/zsh bindings = network = host exposedports = portbindings = x11forward = /tmp/.X11-unix:/tmp/.X11-unix xdisplay = \"DISPLAY=:0\" extrahost = pluto.local:192.168.2.1 extraenv = devices = /dev/bus/usb:/dev/bus/usb,/dev/snd:/dev/snd,/dev/dri:/dev/dri,/dev/input:/dev/input,/dev/vhci:/dev/vhci,/dev/console:/dev/console,/dev/vcsa:/dev/vcsa,/dev/tty:/dev/tty,/dev/tty0:/dev/tty0,/dev/tty1:/dev/tty1,/dev/tty2:/dev/tty2,/dev/uinput:/dev/uinput privileged = false caps = seccomp = cgroups = c 189:* rwm,c 166:* rwm,c 188:* rwm [audio] pulse_server = tcp:localhost:34567 Configuration Sections Explained General Section Parameter Description Example imagename Default image used when running containers without -i myrfswift:latest repotag Default repository for RF Swift images penthertz/rfswift Container Section Parameter Description Example shell Default shell inside containers /bin/zsh bindings Host directories to share with containers /home/user/data:/data network Network mode for containers host, bridge, none exposedports Ports exposed from the container 8080, 443 portbindings Host-to-container port mappings 8080:80/tcp x11forward X11 binding for GUI applications /tmp/.X11-unix:/tmp/.X11-unix xdisplay X11 display environment variable \"DISPLAY=:0\" extrahost Custom host-to-IP mappings pluto.local:192.168.2.1 extraenv Additional environment variables VAR1=value1,VAR2=value2 devices Device mappings for hardware access /dev/bus/usb:/dev/bus/usb privileged Run containers in privileged mode false caps Linux capabilities to add NET_ADMIN,SYS_PTRACE seccomp Seccomp profile for syscall filtering /path/to/profile.json cgroups Control group rules for device access c 189:* rwm,c 166:* rwm Audio Section Parameter Description Example pulse_server PulseAudio server address tcp:localhost:34567 ","quiet-mode--disconnected-mode#Quiet Mode / Disconnected Mode":"RF Swift includes a global flag that allows you to run in â€œdisconnected mode,â€ which prevents the tool from checking for updates or requiring internet connectivity:\nrfswift -q [command] # or rfswift --disconnect [command] When to Use Quiet Mode This mode is particularly useful in several scenarios:\nAir-gapped Environments: When working in secure environments without internet access Bandwidth-limited Situations: When working with limited connectivity (field operations, remote locations) Automated Scripts: When running RF Swift as part of automated workflows where update checks are not desired Rapid Execution: When you need immediate tool execution without the delay of update checking Examples # Run a container without checking for updates rfswift -q run -i sdr_full -n quick_analysis # List local images in disconnected mode rfswift --disconnect images local # Execute a command in a container without update checks rfswift -q exec -c my_container The quiet/disconnected mode can be combined with any RF Swift command and its respective options.\nâ„¹ï¸ Using quiet mode doesnâ€™t affect RF Swiftâ€™s functionalityâ€”it only disables the automatic update checks. Consider periodically checking for updates manually with rfswift update to ensure you have the latest features and security improvements. ","rf-swift-configuration#RF Swift Configuration":"RF Swift ConfigurationRF Swift provides flexible configuration options to customize your environment. You can configure settings through a profile configuration file for persistent preferences or via command-line arguments for one-time adjustments."},"title":"Configurations"},"/docs/guide/host-actions/":{"data":{"audio-configuration#Audio Configuration":"Managing PulseAudio for Container Sound Many RF tools like GQRX, SDR++, and SDRAngel produce audio output that requires proper configuration to be heard on your host system. RF Swift provides commands to manage the PulseAudio server for this purpose.\nDiagnosing Audio Issues When audio is not properly configured, youâ€™ll see this warning when running a container:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ âš ï¸ Warning â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Warning: Unable to connect to Pulse server at 127.0.0.1:34567 â”‚ â”‚ To install Pulse server on Linux, follow these steps: â”‚ â”‚ 1. Update your package manager: sudo apt update (for Debian-based) or sudo yum update (for Red â”‚ â”‚ Hat-based). â”‚ â”‚ 2. Install Pulse server: sudo apt install pulse-server (for Debian-based) or sudo yum install â”‚ â”‚ pulse-server (for Red Hat-based). â”‚ â”‚ After installation, enable the module with the following command as unprivileged user: â”‚ â”‚ ./rfswift host audio enable â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ This indicates that PulseAudio is not configured to accept TCP connections on the default address (127.0.0.1:34567).\nAudio Command Options The host audio command provides options to manage PulseAudio:\nrfswift host audio This displays available subcommands:\nManage pulseaudio server Usage: rfswift host audio [command] Available Commands: enable Enable connection unload Unload TCP module from Pulseaudio server Flags: -h, --help help for audio Enabling Audio Forwarding To enable audio in containers using the default configuration:\nrfswift host audio enable This command:\nLoads the PulseAudio TCP module Configures it to listen on 127.0.0.1:34567 Does not require sudo/administrator privileges You should see confirmation like:\n[+] Successfully loaded module-native-protocol-tcp with index 29 Custom Audio Configuration You can customize the listening address and port:\nrfswift host audio enable -s 10.0.0.1:34567 This allows audio forwarding across a network (useful for remote connections or VMs).\nâš ï¸ Security Note: Opening PulseAudio to network interfaces introduces potential security risks. Only use custom addresses on secure networks and consider using firewalls to restrict access. Disabling Audio Forwarding When you no longer need audio forwarding:\nrfswift host audio unload This removes the TCP module from PulseAudio, closing the network port.\nTroubleshooting Audio Issues If you continue to experience audio problems after enabling the server:\nVerify PulseAudio is running:\npulseaudio --check Restart PulseAudio if needed:\npulseaudio -k pulseaudio --start Check your containerâ€™s PULSE_SERVER environment variable:\nrfswift exec -c my_container echo $PULSE_SERVER It should show tcp:127.0.0.1:34567 (or your custom address)","common-device-examples#Common Device Examples":"RTL-SDR Setup After connecting an RTL-SDR device:\nOn Windows:\n# Identify device (typically has vendor ID 0bda) rfswift winusb list # Attach device (replace 1-2 with your device's BusID) rfswift winusb attach -i 1-2 On Linux:\n# Check if device is recognized lsusb | grep RTL # Run container with default USB bindings rfswift run -i sdr_full -n rtlsdr_container Using SDR Tools with Attached Devices Once your SDR device is properly attached, you can use tools like SDRAngel:\n# Inside your container sdrangel Running SDR Angel on Windows with RTL-SDR attached ","host-actions#Host Actions":"Host ActionsAfter learning how to run, configure, and manage RF Swift containers and images, this section covers important host-level operations that enhance the functionality of your RF tools and containers.","next-steps#Next Steps":"Continue to the file sharing section to learn how to exchange data between your host and containers:\nFile SharingLearn how to share files and directories between host and containers. ","usb-device-management#USB Device Management":"RF Swift provides platform-specific methods for managing USB devices, which is critical for SDR hardware.\nWindows USB Management On Windows, RF Swift includes the winusb command to simplify USB device sharing between the host and containers.\nâš ï¸ Prerequisites:\nusbipd must be installed Docker Desktop must be running Administrator privileges are required for attachment operations Listing Available USB Devices To see all USB devices connected to your system:\nrfswift winusb list This displays information about each device:\nUSB Devices: BusID: 1-2, DeviceID: 0bda:2838, VendorID: Bulk-In, ProductID: Interface, Description: Not shared BusID: 1-3, DeviceID: 8087:0032, VendorID: Intel(R), ProductID: Wireless, Description: Bluetooth(R) Not shared BusID: 1-4, DeviceID: 1532:0270, VendorID: USB, ProductID: Input, Description: Device, Razer Blade 14 Shared BusID: 2-4, DeviceID: 13d3:56d5, VendorID: Integrated, ProductID: Camera, Description: Integrated IR Camera Not shared Device Identification Strategy To easily identify a new device:\nRun rfswift winusb list before connecting your device Connect your device (e.g., RTL-SDR, HackRF, etc.) Run rfswift winusb list again to identify the new entry The newly appeared device is the one you want to share.\nAttaching USB Devices To share a device with containers, use the attach command with administrator privileges:\n# Run PowerShell as Administrator rfswift winusb attach -i 1-2 Where 1-2 is the BusID of your device from the list command.\nYou can verify the attachment was successful by running list again - the device should show as â€œAttachedâ€ rather than â€œNot sharedâ€.\nAutomatic SDR Device Detection For common SDR devices, RF Swift can automatically detect and attach them:\n# Run PowerShell as Administrator rfswift winusb attach-all-sdrs This identifies common SDR devices by their vendor and product IDs and attaches them all at once.\nDetaching USB Devices When youâ€™re finished using a device, you can detach it:\n# Run PowerShell as Administrator rfswift winusb detach -i 1-2 Linux USB Management On Linux, USB devices are typically accessible to containers through device bindings. You can:\nAdd devices during container creation:\nrfswift run -i sdr_full -n my_sdr -s /dev/ttyUSB0:/dev/ttyUSB0 Add devices to an existing container:\nrfswift bindings add -c my_sdr -s /dev/ttyUSB0:/dev/ttyUSB0 For SDR devices that use USB, ensure the relevant device files are bound:\nRTL-SDR: /dev/bus/usb (generally bound by default) Serial devices: /dev/ttyUSB0, /dev/ttyACM0, etc. HackRF: Typically accessible through /dev/bus/usb "},"title":"Host Actions"},"/docs/guide/list-of-images/":{"data":{"disk-space-considerations#Disk Space Considerations":"RF Swift images vary in size based on included tools:\nImage Type Typical Size Range Examples Base images 2-5 GB corebuild Specialized tools 5-10 GB bluetooth, wifi, reversing Comprehensive suites 10-20 GB sdr_full, telecom_5G Important Note on Actual Disk Usage: The sizes displayed by rfswift images local show the virtual size of each image. However, due to Dockerâ€™s layer-based architecture and the hierarchical structure of RF Swift images, the actual disk space used is often significantly less than the sum of all image sizes.\nFor example, if you have both sdr_light (9GB) and sdr_full (16GB) images:\nThe displayed total might suggest 25GB of usage The actual disk usage might be closer to 17GB since both images share common base layers This layer sharing happens automatically and is one of the key benefits of RF Swiftâ€™s hierarchical image design. When you pull multiple related images (like those in the same branch of the hierarchy diagram), youâ€™re only downloading and storing the unique layers for each image.\nTo manage disk space efficiently:\nUse specialized images rather than all-inclusive ones when possible Leverage the image hierarchy - related images share layers and consume less space Remove unused images with rfswift delete -c image:tag Clean up unused containers with rfswift remove -c container_name Consider creating custom images with only the tools you need ","image-hierarchy#Image Hierarchy":"RF Swift images are structured in a layered hierarchy, with specialized images building on more general base images:\ngraph TD; A[corebuild]--\u003eB[sdrsa_devices]; A--\u003eC[rfid]; A--\u003eD[automotive]; A--\u003eE[reversing]; A--\u003eF[sdrsa_devices_antsdr]; A--\u003eG[sdrsa_devices_rtlsdrv4]; B[sdrsa_devices]--\u003eH[sdr_light]; B[sdrsa_devices]--\u003eI[bluetooth]; B[sdrsa_devices]--\u003eJ[wifi]; B[sdrsa_devices]--\u003eL[telecom_utils]; B[sdrsa_devices]--\u003eR[hardware]; B[sdrsa_devices]--\u003eS[network]; L--\u003eM[telecom_2Gto3G]; L--\u003eN[telecom_4G_5GNSA]; L--\u003eO[telecom_5G]; H--\u003eK[sdr_full]This hierarchy provides several benefits:\nLayer reuse: Reduces overall disk space when using multiple images Consistency: Common tools are identical across related images Specialization: Higher-level images include more specialized tools Base for customization: You can build your own images starting from any level ","image-management-commands#Image Management Commands":"RF Swift offers the images command group to interact with both remote and local images:\nrfswift images --help Key subcommands include:\nremote: List available images from the repository local: List downloaded images on your system ","managing-local-images#Managing Local Images":"Listing Local Images To see images youâ€™ve already downloaded or created:\nrfswift images local This shows details about local images, including their status:\nğŸ“¦ RF Swift Images â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Repository â”‚ Tag â”‚ Image ID â”‚ Created â”‚ Size â”‚ Status â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ myrfswift â”‚ latest â”‚ sha256:0bdb2 â”‚ 2024-09-01T00:56:27+02:00 â”‚ 16635.22 MB â”‚ Custom â”‚ â”‚ penthertz/rfswiftdev â”‚ sdr_full_amd64 â”‚ sha256:0bdb2 â”‚ 2024-09-01T00:56:27+02:00 â”‚ 16635.22 MB â”‚ Up to date â”‚ â”‚ penthertz/rfswiftdev â”‚ sdr_light_amd64 â”‚ sha256:476c0 â”‚ 2024-09-01T00:34:55+02:00 â”‚ 9617.12 MB â”‚ Up to date â”‚ â”‚ penthertz/rfswift â”‚ sdr_full â”‚ sha256:50ce1 â”‚ 2024-08-02T14:45:46+02:00 â”‚ 10383.56 MB â”‚ Custom â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Image Status Indicators:\nUp to date: Image matches the latest version in the repository Update available: A newer version exists in the repository Custom: Image has been modified locally (through tagging or container commits) Pulling Images To download an image from the repository:\nrfswift images pull -i sdr_light Options:\n-i, --image: Image tag to download (required) -t, --tag: Local tag to apply to the pulled image (optional) -r, --repository: Alternate repository source (optional) Example with custom tag:\nrfswift images pull -i sdr_full -t my_sdr:v1 Updating Images To update an image that shows â€œUpdate availableâ€:\nrfswift images pull -i sdr_full RF Swift will automatically download the latest version.\nSaving and Loading Images For offline use or transfer between systems:\n# Export an image to a file rfswift images save -i sdr_light -o sdr_light.tar.gz # Import an image from a file rfswift images load -i sdr_light.tar.gz ","next-steps#Next Steps":"Explore these sections to learn more about available tools and configuration options:\nList of ToolsDetailed inventory of tools included in each image. ConfigurationsManage profiles and settings for RF Swift. ","recommended-images#Recommended Images":" Tag Supported OS x86_64/amd64 arm64/v8 riscv64 Description corebuild - Linux - Windows - macOS âœ… âœ… âœ… Base image including prerequisites for compiling tools and libraries for applications needing GUI and some other necessary tools sdrsa_devices - Linux - Windows - macOS âœ… âœ… âœ… Contains all drivers of devices included in sdrsa_devices.docker sdrsa_devices_antsdr - Linux - Windows âœ… âœ… âœ… Contains all drivers of devices included in sdrsa_devices.docker but replacing official UHD drivers by ANTSDR ones sdrsa_devices_rtlsdrv4 - Linux - Windows - macOS âœ… âœ… âœ… Contains all drivers of devices included in sdrsa_devices.docker but replacing default RTL-SDR drivers to support v4 version for the RTL-SDR blog sdr_light - Linux - Windows - macOS âœ… âœ… âœ… Light image built for SDR uses with limited number of tools used in sdr_light.docker file sdr_light_intelgpu - Linux - Windows âœ… âŒ âŒ same as sdr_light but with Intel GPU driver and gr-fosphor sdr_light_nvidiagpu - Linux - Windows âœ… âŒ âŒ same as sdr_light but with NVidia GPU driver and gr-fosphor sdr_full - Linux - Windows - macOS âœ… âœ… âœ… Full image including all SDR tools used in sdr_full.docker file wifi_basic - Linux - Windows - macOS âœ… âœ… âœ… Wi-Fi image for security tests using tools included in wifi_basic.docker wifi_full - Linux - Windows - macOS âœ… âœ… âœ… Wi-Fi image for security tests using tools included in wifi_full.docker rfid - Linux - Windows - macOS âœ… âœ… âœ… RFID image for security tests using tools included in rfid.docker reversing - Linux - Windows - macOS âœ… âœ… âŒ (not yet) Reversing image for security tests using tools included in reversing.docker automotive - Linux - Windows - macOS âœ… âœ… âŒ (not yet) Automotive image for security tests using tools included in automotive.docker bluetooth - Linux - Windows - macOS âœ… âœ… âœ… Bluetooth classic and LE image for security tests using tools in bluetooth.docker telecom_utils - Linux - Windows - macOS âœ… âœ… âœ… Telecom image for security tests using tools included in telecom_utils.docker telecom_2Gto3G - Linux - Windows - macOS âœ… âœ… âœ… Telecom image for security tests using tools included in telecom_2Gto3G.docker telecom_4G_5GNSA - Linux - Windows - macOS âœ… âœ… âœ… Telecom image for security tests using tools included in telecom_4G_5GNSA.docker telecom_5G - Linux - Windows - macOS âœ… âœ… âœ… Telecom image for security tests using tools included in telecom_4G_5GNSA.docker network - Linux - Windows - macOS âœ… âœ… âŒ (not yet) Image for reversing security tests using tools included in reversing.docker hardware - Linux - Windows - macOS âœ… âœ… âœ… Image for hardware security tests using tools included in hardware.docker ","remote-image-repository#Remote Image Repository":"Listing Available Images To view all available images for your architecture from the official repository:\nrfswift images remote This command displays a table of available images with important details:\nğŸ’¿ Official Images â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Tag â”‚ Pushed Date â”‚ Image â”‚ Architecture â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ sdr_full_nvidiagpu_amd64 â”‚ 2025-03-24T17:37:59Z â”‚ penthertz/rfswift:sdr_full_nvidiagpu_amd64 â”‚ amd64 â”‚ â”‚ hardware â”‚ 2025-03-24T17:33:21Z â”‚ penthertz/rfswift:hardware â”‚ amd64 â”‚ â”‚ sdr_full_intelgpu_amd64 â”‚ 2025-03-24T17:09:38Z â”‚ penthertz/rfswift:sdr_full_intelgpu_amd64 â”‚ amd64 â”‚ â”‚ sdr_full â”‚ 2025-03-24T16:43:07Z â”‚ penthertz/rfswift:sdr_full â”‚ amd64 â”‚ â”‚ telecom_5G â”‚ 2025-03-24T16:36:22Z â”‚ penthertz/rfswift:telecom_5G â”‚ amd64 â”‚ ... Understanding Image Tags The image naming system follows a consistent pattern:\nGeneric tags (e.g., sdr_full, bluetooth) work across supported architectures with multi-architecture builds Architecture-specific tags (e.g., sdr_light_amd64, bluetooth_arm64) target single architectures Specialized hardware tags (e.g., sdr_full_nvidiagpu_amd64) include optimizations for specific hardware â„¹ï¸ When in doubt, use the generic tags (without architecture suffix) as RF Swift will automatically select the correct version for your system. Use architecture-specific tags only when you need a particular variant. Core Image Categories Category Description Example Images SDR Software-defined radio tools sdr_light, sdr_full, sdr_full_nvidiagpu_amd64 Telecom Mobile network analysis telecom_utils, telecom_2Gto3G, telecom_4G_5GNSA, telecom_5G Short-range Bluetooth, Wi-Fi and RFID bluetooth, wifi, rfid Hardware Hardware security tools hardware, reversing Automotive Vehicle communications automotive Base images Foundation for other images corebuild, sdrsa_devices ","rf-swift-container-images#RF Swift Container Images":"RF Swift Container ImagesRF Swift provides a comprehensive set of container images to support various radio frequency and hardware security workflows. This guide explains how to manage these images and understand the available options."},"title":"Container Images"},"/docs/guide/list-of-tools/":{"data":{"image-hierarchy#Image Hierarchy":"Each RF Swift image builds upon a foundation of tools, with specialized images adding domain-specific capabilities. Understanding this hierarchy helps you choose the most appropriate image for your needs:\ngraph TD; A[corebuild]--\u003eB[sdrsa_devices]; A--\u003eC[rfid]; A--\u003eD[automotive]; A--\u003eE[reversing]; A--\u003eF[sdrsa_devices_antsdr]; A--\u003eG[sdrsa_devices_rtlsdrv4]; B[sdrsa_devices]--\u003eH[sdr_light]; B[sdrsa_devices]--\u003eI[bluetooth]; B[sdrsa_devices]--\u003eJ[wifi]; B[sdrsa_devices]--\u003eL[telecom_utils]; B[sdrsa_devices]--\u003eR[hardware]; B[sdrsa_devices]--\u003eS[network]; L--\u003eM[telecom_2Gto3G]; L--\u003eN[telecom_4G_5GNSA]; L--\u003eO[telecom_5G]; H--\u003eK[sdr_full]","next-steps#Next Steps":"Continue to the Configurations page to learn how to customize your RF Swift environment:\nConfiguration OptionsCustomize your RF Swift environment for optimal performance. ","rf-swift-tool-collection#RF Swift Tool Collection":"RF Swift Tool CollectionRF Swift provides a comprehensive suite of specialized tools for radio frequency and hardware security work. This page catalogs the tools available in each pre-built image.\nğŸ“ˆ RF Swift is in active development. The tool collection is regularly expanded and optimized for all supported architectures. ","tool-categories#Tool Categories":"Core SDR Devices Support The sdrsa_devices image serves as the foundation for many RF Swift images, providing essential drivers and utilities for software-defined radio hardware.\nTool(s) Available commands amd64 aarch64 riscv64 Installation function UHD tools and libs (need to enable/disable options) uhd_adc_self_cal | uhd_fft | uhd_rx_cfile | uhd_cal_rx_iq_balance | uhd_find_devices | uhd_rx_nogui | uhd_cal_tx_dc_offset | uhd_image_loader | uhd_siggen | uhd_cal_tx_iq_balance | uhd_images_downloader | uhd_siggen_gui | uhd_config_info | uhd_modes.py | uhd_usrp_probe âœ… âœ… âœ… uhd_devices_install RTL-tools and libs (need to enable/disable options) rtl_biast | rtl_fm | rtl_sdr | rtl_test | rtl_adsb | rtl_eeprom | rtl_power | rtl_tcp âœ… âœ… âœ… rtlsdr_devices_install libiio and libad9361 iio_adi_xflow_check | iio_attr | iio_genxml | iio_info | iio_readdev |iio_reg | iio_stresstest | iio_writedev âœ… âœ… âœ… ad_devices_install Nuand tools and lib bladeRF-cli | bladeRF-fsk âœ… âœ… âœ… nuand_devices_install HackRF tools and lib hackrf_clock | hackrf_debug | hackrf_operacake | hackrf_sweep | hackrf_cpldjtag | hackrf_info | hackrf_spiflash | hackrf_transfer âœ… âœ… âœ… hackrf_devices_install Airspry tools and lib airspy_gpio | airspy_rx | airspyhf_info | airspy_gpiodir | airspy_si5351c | airspyhf_lib_version | airspy_info | airspy_spiflash | airspyhf_rx | airspy_lib_version | airspyhf_calibrate | airspy_r820t | airspyhf_gpio âœ… âœ… âœ… airspy_devices_install LimeSDR tools and lib LimeQuickTest | LimeSuiteGUI | LimeUtil âœ… âœ… âœ… limesdr_devices_install Funcube tools and lib âœ… âœ… âœ… funcube_devices_install XTRX tools and lib xtrx_fft âœ… âœ… âœ… xtrx_devices_install OsmoFL2K tools and lib fl2k_file | fl2k_tcp | fl2k_fm | fl2k_test âœ… âœ… âœ… osmofl2k_devices_install SignalHound Spike Spike âœ… âŒ âŒ signalhound_spike_sa_device SignalHound VSG60 vsg60 âœ… âŒ âŒ signalhound_vsg60_sa_device Harogic Devices sastudio âœ… âœ… âŒ harogic_sa_device RFNM âœ… âœ… âœ… rfnm_devices_install LibreSDR B2x0 libresdr_swapfpga âœ… âœ… âœ… libresdr_b2x0_devices_install pocketVNA pocketVNA âœ… (not by default) âŒ âŒ pocketvna_sa_device â„¹ï¸ Specialized Device Support:\nFor RTL-SDR v4 devices: Use the rtlsdrv4_devices_install function For ANTSDR devices: Use the antsdr__devices_install function Common Device Troubleshooting RTL-SDR Kernel Module Conflicts If your RTL-SDR device is unavailable when using tools like nfc-spy, the DVB-T kernel module may have claimed it. Blacklist the module with:\necho \"blacklist dvb_usb_rtl28xxu\" | sudo tee /etc/modprobe.d/blacklist-dvb_usb_rtl28xxu.conf Youâ€™ll need to restart your host system after adding this blacklist entry.\nPlutoSDR Connection Issues If the PlutoSDR doesnâ€™t appear with iio_info -s and you see errors like:\nwith backends: local xml ip usb Unable to create Local IIO context : No such file or directory (2) ERROR: Unable to create Avahi DNS-SD client :Daemon not running Scanning for IIO contexts failed: Text file busy (26) This can be resolved in two ways:\nOn Linux hosts: Ensure avahi-daemon is running on your host system Inside the container: Run the Avahi daemon with: avahi-daemon --no-drop-root --no-rlimits SDR Light Tools The sdr_light image includes essential software-defined radio tools for signal capture, analysis, and basic decoding.\nTool(s) Available commands amd64 aarch64 riscv64 Installation function GNU Radio gnuradio-companion | gnuradio-config-info | grcc âœ… âœ… âœ… gnuradio_soft_install Common GNU Radio blocks âœ… âœ… âœ… common_sources_and_sinks Soapy blocks and modules âœ… âœ… âœ… install_soapy_modules SDR++ sdrpp âœ… âœ… âœ… sdrpp_soft_fromsource_install retrogram /rftools/sdr/retrogram-soapysdr/retrogram-soapysdr âœ… âœ… âœ… retrogram_soapysdr_soft_install kc908 SA GNU Radio blocks âœ… âœ… âœ… kc908_sa_device LeoBodnar GPSDO v1 CLI /rftools/calibration/lbgpsdo/lbgpsdo.py âœ… âœ… âœ… leobodnarv1_cal_device LeoBodnar GPSDO v2 CLI (lbe-142x) lbe-142x âœ… âœ… âœ… leobodnarv2_cal_device GQRX gqrx âœ… âœ… âœ… gqrx_soft_install URH urh | urh_cli âœ… âœ… âœ… urh_soft_install inspectrum inspectrum âœ… âœ… âœ… inspectrum_soft_install NanoVNASaver NanoVNASaver âœ… âŒ (fix needed installing PyQT6) â“ NanoVNASaver_cal_device_call NanoVNA-QT /rftools/calibration/NanoVNA-QT/run âœ… âœ… âœ… NanoVNA_QT_cal_device KCSDI /rftools/calibration/Deepace/KCSDI-v0.4.5-45-linux-x86_64.AppImage âœ… âŒ âœ… KCSDI_cal_device rtl_433 rtl_433 âœ… âœ… âœ… rtl_433_soft_install Jupyter lab + notebook jupiter âœ… âœ… âœ… jupyter_soft_install Atermis Artemis âœ… âœ… âŒ (needs Pyside6) artemis_soft_install gqrx-scanner gqrx-scanner âœ… âœ… âœ… gqrxscanner_sdr_soft_install gnsslogger gnsslogger âœ… âœ… âœ… gnsslogger_cal_device soapy-rfnm âœ… âœ… âœ… soapyrfnm_grmod_install LibreVNA LibreVNA-GUI âœ… âœ… (not installed by default) âœ… (not installed by default) librevna_cal_device xnec2c xnec2c âœ… âœ… âœ… xnec2c_cal_device SDR Full Environment The sdr_full image builds on sdr_light to provide a comprehensive SDR development and analysis environment, including GNU Radio and specialized plugins.\nGNU Radio Out-Of-Tree Modules These modules extend GNU Radioâ€™s capabilities for specific protocols and signal types:\nTool(s) amd64 aarch64 riscv64 OOT â€“ gr-gsm âœ… âœ… âœ… OOT â€“ gr_lora âœ… âœ… âœ… OOT â€“ gr_lorasdr âœ… âœ… âœ… OOT â€“ gr_iridium âœ… âœ… âœ… OOT â€“ gr_inspector âœ… âœ… âœ… OOT â€“ gr_uaslink âœ… âœ… âœ… OOT â€“ gr_X10 âœ… âœ… âœ… OOT â€“ gr_gfdm âœ… âœ… âœ… OOT â€“ gr_aaoronia_rtsa âœ… âœ… âœ… OOT â€“ gr_ccsds âŒ âŒ âŒ OOT â€“ gr_ais âœ… âœ… âœ… OOT â€“ gr_dvbs2 âœ… âœ… âœ… OOT â€“ gr_tempest âœ… âœ… âœ… OOT â€“ gr_dab âœ… âœ… âœ… OOT â€“ gr_dect2 âœ… âœ… âœ… OOT â€“ gr_foo âœ… âœ… âœ… OOT â€“ gr_ieee802-11 âœ… âœ… âœ… OOT â€“ gr_ieee802154 âœ… âœ… âœ… OOT â€“ gr_rds âœ… âœ… âœ… OOT â€“ gr_droneid âœ… âœ… âœ… OOT â€“ gr_satellites âœ… âœ… âœ… OOT â€“ gr_adsb âœ… âœ… âœ… OOT â€“ gr_keyfob âœ… âœ… âœ… OOT â€“ gr_radar âœ… âœ… âœ… OOT â€“ gr_nordic âœ… âœ… âœ… OOT â€“ gr_paint âœ… âœ… âœ… OOT â€“ gr_pdu_utils âœ… âœ… âœ… OOT â€“ gr_sandia_utils âœ… âœ… âœ… OOT â€“ gr_timing_utils âœ… âœ… âœ… OOT â€“ gr_fhss âœ… âœ… âœ… OOT â€“ gr-aistx âœ… âœ… âœ… OOT â€“ gr-zwave_poore âœ… âœ… âœ… OOT â€“ gr-mixalot âœ… âœ… âœ… OOT â€“ gr_DCF77_Receiver âœ… âœ… âœ… OOT â€“ gr-j2497 âœ… âœ… âœ… OOT â€“ gr-airmodes âœ… âœ… âœ… OOT â€“ gr-bb60_Receiver âœ… âŒ âŒ OOT â€“ gr_fosphor âœ… â“ â“ OOT â€“ gr-m17 âœ… âœ… âœ… OOT â€“ gr-gr-net âœ… âœ… âŒ (missing libpthread for now) OOT â€“ gr-aoa âœ… âœ… âœ… OOT â€“ grc-orrectiq âœ… âœ… âœ… OOT â€“ gr-dsd âœ… âœ… âœ… OOT â€“ gr-nrsc5 âœ… âœ… âœ… OOT â€“ gr-ntsc-rc âœ… âœ… âœ… OOT â€“ gr-nfc âœ… âœ… âœ… OOT â€“ gr-fosphor (only with GPU images) âœ… âœ… â“ OOT â€“ gr-mer âœ… âœ… âœ… OOT â€“ gr-flarm âœ… âœ… âœ… Additional SDR Software Tool(s) Available commands amd64 aarch64 riscv64 Installation function Nvidia OpenCL (to enable) âœ… (not activated) âŒ âŒ In the docker file Intel OpenCL (to enable) âœ… (not activated) âŒ âŒ In the docker file CyberEther cyberether âœ… âœ… âœ… cyberther_soft_install SDR Angel sdrangel âœ… âœ… âœ… sdrangel_soft_fromsource_install QSSTV qsstv âœ… âœ… âœ… qsstv_soft_install Sigdigger SigDigger âœ… âœ… (but slow) âœ… (but slow) sigdigger_soft_install ice_bluetooth ice9-bluetooth âœ… âŒ âŒ ice9_bluetooth_soft_install Meshtastic SDR /rftools/sdr/meshtastic_sdr/ âœ… âœ… âœ… meshtastic_sdr_soft_install gps_sdr_sim /rftools/sdr/gps-sdr-sim/ âœ… âœ… âœ… gps_sdr_sim_soft_install nfc laboratory nfc-lab âœ… âœ… âœ… nfclaboratory_soft_install Scikit-learn âœ… âœ… âœ… ml_and_dl_soft_install pandas âœ… âœ… âœ… ml_and_dl_soft_install seaborn âœ… âœ… âœ… ml_and_dl_soft_install Tensorflow âœ… âœ… âœ… ml_and_dl_soft_install Gpredict âœ… âœ… âœ… ml_and_dl_soft_install v2verifier /rftools/sdr/v2verifier/ âœ… âœ… âœ… v2verifier_sdr_soft_install wavingz /rftools/sdr/waving-z/build/ âœ… âœ… âœ… wavingz_sdr_soft_install SatDump /rftools/sdr/SatDump/* âœ… âœ… âœ… satdump_sdr_soft_install PySpecSDR /rftools/sdr/PySpecSDR/* âœ… âœ… âœ… satdump_sdr_soft_install RFID Tools The rfid image focuses on radio-frequency identification analysis and exploitation:\nTool(s) Available commands amd64 aarch64 riscv64 Installation function proxmark3 /rftools/rfid/proxmark3/ âœ… âœ… âœ… proxmark3_soft_install libnfc and tools nfc-barcode | nfc-list | nfc-read-forum-tag3 | nfc-emulate-forum-tag4 | nfc-mfclassic | nfc-relay-picc | nfc-jewel | nfc-mfultralight | nfc-scan-device âœ… âœ… âœ… libnfc_soft_install mfoc mfoc âœ… âœ… âœ… mfoc_soft_install mfcuk mfcuk âœ… âœ… âœ… mfcuk_soft_install mfread /rftools/rfid/mfdread/mfdread.py âœ… âœ… âœ… mfread_soft_install âš ï¸ RFID Device Requirements: When using RFID tools, you need to ensure that your RFID reader device (typically appearing as /dev/ttyACM0) is properly bound to the container:\n# When creating a new container rfswift run -i rfid -n rfid_tools -s /dev/ttyACM0:/dev/ttyACM0 # Or with an existing container rfswift bindings add -c rfid_tools -d -t /dev/ttyACM0 Bluetooth Analysis The bluetooth image contains specialized tools for Bluetooth protocol analysis and security testing:\nTool(s) Available commands amd64 aarch64 riscv64 Installation function bettercap bettercap âœ… âœ… âœ… bettercap_soft_install hcitools hciattach | hciconfig | hcidump | hcitool âœ… âœ… âœ… blueztools_soft_install bluez tools âœ… âœ… âœ… blueztools_soft_install mirage mirage âœ… âœ… âœ… mirage_soft_install Sniffle with OpenDroneID encoder/decoder /rftools/bluetooth/Sniffle/ âœ… âœ… âœ… sniffle_soft_install Kismet kismet âœ… âœ… âœ… kismet_soft_install bluing /rftools/bluetooth/bluing/bluing/bin/ âœ… âœ… âœ… bluing_soft_install bdaddr /rftools/bluetooth/bdaddr/bdaddr âœ… âœ… âœ… bdaddr_soft_install WHAD whadup|wplay|wsniff|wfilter|wextract|wdump|wshark|wanalyze|winject|wserver|wble-central|wble-periph|wble-proxy|wble-spawn|wble-connect|wuni-scan|wuni-mouse|wuni-keyboard âœ… âœ… âœ… whad_soft_install âš ï¸ Required Capability: Bluetooth tools require the NET_ADMIN capability to function properly. Always include this capability when running the container:\nrfswift run -i bluetooth -n bt_tools -a NET_ADMIN Without this capability, many Bluetooth tools will fail with permission errors when attempting to configure network interfaces.\nWi-Fi Security The wifi image provides tools for Wi-Fi network analysis, packet capture, and security assessment:\nTool(s) Available commands amd64 aarch64 riscv64 Installation function iproute2 âœ… âœ… âœ… common_nettools macchanger macchanger âœ… âœ… âœ… common_nettools tshart tshark âœ… âœ… âœ… common_nettools aircrack-ng airbase-ng | aircrack-ng | airdecap-ng | airdecloak-ng | aireplay-ng | airmon-ng | airodump-ng | airodump-ng-oui-update | airolib-ng | easside-ng | etc. âœ… âœ… âœ… aircrack_soft_install reaver reaver âœ… âœ… âœ… reaver_soft_install bully bully âœ… âœ… âœ… bully_soft_install pixiewps pixiewps âœ… âœ… âœ… pixiewps_soft_install eaphammer /rftools/wifi/airgeddon/eaphammer âœ… âœ… âœ… eaphammer_soft_install airgeddon /rftools/wifi/airgeddon/ âœ… âœ… âœ… airgeddon_soft_install wifite2 /rftools/wifi/wifite2/ âœ… âœ… âœ… wifite2_soft_install sparrow-wifi /rftools/sparrow-wifi/sparrow-wifi.py âœ… âœ… âœ… sparrowwifi_sdr_soft_install krackattacks-scripts /rftools/wifi/krackattacks-scripts/* âœ… âœ… âœ… krackattacks_script_soft_install âš ï¸ Required Capability: Wi-Fi tools require the NET_ADMIN capability to manipulate wireless interfaces. Always include this capability when running the container:\nrfswift run -i wifi -n wifi_tools -a NET_ADMIN If you see errors about insufficient permissions when using Wi-Fi tools, this capability is likely missing.\nTelecommunications The telecommunications images are divided into several categories based on mobile network generations:\nTelecom Utilities Foundation tools for cellular network analysis:\nTool(s) Available commands amd64 aarch64 riscv64 Installation function pycrate /telecom/pycrate/ âœ… âœ… âœ… pycrate_soft_install CryptoMobile /telecom/CryptoMobile/ âœ… âœ… âœ… cryptomobile_soft_install PySIM /telecom/SIM/pysim âœ… âœ… âœ… pysim_soft_install sysmo-usim-tool /telecom/SIM/sysmo-usim-tool âœ… âœ… âœ… sysmoUSIM_soft_install SCAT /telecom/scat âœ… âœ… âœ… SCAT_soft_install SigPloit /telecom/2G/SigPloit âœ… âœ… âœ… SigPloit_soft_install pysctp âœ… âœ… âœ… pysctp_soft_install jSS7 /telecom/2G/jss7 âœ… â“ â“ jss7_soft_install 2G/3G Analysis Tools Tools for GSM, UMTS, and related technologies:\nTool(s) Available commands amd64 aarch64 riscv64 Installation function yatebts yate | yate-config | yate-qt5 âœ… âœ… âœ… yatebts_blade2_soft_install OpenBTS /telecom/2G/OpenBTS/ âœ… âŒ (need tests with other compiler) âŒ openbts_uhd_soft_install OpenBTS UMTS /telecom/3G/OpenBTS-UMTS/ âœ… âŒ (need to fix ASN part) âŒ openbts_umts_soft_install OsmoBTS suite (including OsmoPCU + OsmoSGSN and others) osmo* tools with configs in /telecom/2G/osmocom/ âœ… âœ… âœ… osmobts_suite_soft_install 4G/5G Analysis Tools Tools for LTE, 5G-NSA, and 5G technologies:\nTool(s) Available commands amd64 aarch64 riscv64 Installation function srsRAN 4G, 5G NSA /telecom/4G/srsRAN_4G/ âœ… âœ… âœ… srsran4G_5GNSA_soft_install srsRAN 5G SA /telecom/5G/srsRAN_Project/ âœ… âœ… âœ… srsran5GSA_soft_install Open5GS /telecom/5G/open5gs/ âœ… âœ… âœ… Open5GS_soft_install UERANSIM /telecom/5G/UERANSIM âœ… âœ… âœ… UERANSIM_soft_install Automotive Security The automotive image contains tools for vehicle network analysis and communication:\nTool(s) Available commands amd64 aarch64 riscv64 Installation function Can-utils candump | canplayer | cansend | cangen | cansequence | cansniffer | canlogserver | bcmserver | socketcand | cannelloni | cangw | canbusload | can-calc-bit-timing | canfdtest | etc. (see: https://github.com/linux-can/can-utils) âœ… âœ… âŒ canutils_soft_install Cantact tools cantact âœ… âœ… âœ… cantact_soft_install caringcaribou caringcaribou âœ… âœ… âœ… caringcaribou_soft_install savvycan SavvyCAN âœ… âœ… âœ… savvycan_soft_install gallia gallia âœ… âœ… âœ… gallia_soft_install V2G Injector /automotive/V2GInjector/ âœ… âœ… âœ… v2ginjector_soft_install Hardware Reverse Engineering The reversing image provides tools for firmware analysis and hardware reverse engineering:\nTool(s) Available commands amd64 aarch64 riscv64 Installation function kataistruct kaitai-struct-compiler âœ… âœ… â“ kataistruct_soft_install unicorn âœ… âœ… â“ unicorn_soft_install keystone keytool âœ… âœ… â“ keystone_soft_install radare2 radare2 | radiff2 âœ… âœ… â“ radare2_soft_install ghidra ghidraRun âœ… âœ… â“ ghidra_soft_install binwalk binwalk âœ… âœ… â“ binwalk_soft_install binwalk v3 binwalkv3 âœ… âœ… âœ… binwalk_soft_install cutter âœ… âœ… âŒ cutter_soft_install LLVM tools âœ… âœ… â“ LLVM_install AFL++ afl-* âœ… âœ… â“ AFL_install HongFuzz honggfuzz âœ… âœ… â“ honggfuzz_install SemGrep semgrep âœ… âœ… â“ semgrep_install C++ check cppcheck* âœ… âœ… â“ cppcheck_install Clang static analyzer âœ… âœ… â“ clang_static_analyzer_install Qiling â“ â“ â“ qiling_soft_install ImHex ImHex âœ… âœ… â“ imhex_soft_install Network Analysis The network image contains general network analysis and security tools:\nTool(s) Available commands amd64 aarch64 riscv64 Installation function Nmap nmap âœ… âœ… âœ… nmap_soft_install Wireshark wireshark âœ… âœ… âœ… wireshark_soft_install Metasploit msf âœ… (not tested) (not tested) metasploit_soft_install Tshark tshark âœ… âœ… âœ… tshark_soft_install impacket impacket Python3 modules âœ… âœ… âœ… impacket_soft_install AutoRecon autorecon âœ… âœ… (not tested) autorecon_soft_install Responder responder âœ… âœ… âœ… responder_soft_install Kismet kismet âœ… âœ… âœ… kismet_soft_install Bettercap bettercap âœ… âœ… âœ… bettercap_soft_install Hardware Security The hardware image focuses on general hardware security testing and analysis:\nTool(s) Available commands amd64 aarch64 riscv64 Installation function DSView DSView âœ… âœ… âœ… dsview_install avrdude avrdude âœ… âœ… âœ… avrdude_install flashrom flashrom âœ… âœ… âœ… flashrom_install pulseview pulseview âœ… âœ… âœ… pulseview_install openocd openocd âœ… âœ… âœ… openocd_install dsl2sigrok dsl2sigrok âœ… âœ… âœ… dsl2sigrok_install HydraNFC decoder (pulseview and DSView decoder) âœ… âœ… âœ… hydranfc_trace_plugin_install arduino arduino âœ… (not yet) (not yet) arduino_ide_install Saleae Logic 2 Logic-2 âœ… âŒ âŒ logic2_saleae_install seergdb GUI seergdb âœ… âœ… âœ… seergdb_install openFPGALoader openFPGALoader âœ… âœ… âœ… openFPGALoader_install ","tool-usage-tips#Tool Usage Tips":"Tool Directory Organization RF Swift organizes tools in specialized directories for easier discovery:\n/rftools - Contains radio frequency analysis tools /hardware - Hardware security and testing tools /automotive - Vehicle communication and analysis tools /reverse - Reverse engineering and firmware analysis tools These directories complement the standard system paths (/usr/bin, /usr/local/bin) and contain specialized tools, scripts, and resources.\nFinding Available Tools To discover which tools are available in your current container:\n# List all executable commands in standard paths find /usr/bin /usr/local/bin -type f -executable | sort # List RF tools in the dedicated directory ls -la /rftools # List tools in other specialized directories ls -la /hardware ls -la /automotive ls -la /reverse // and more # Search for a specific tool across all locations find /usr/bin /usr/local/bin /rftools /hardware /automotive /reverse -name \"*sdr*\" -type f -executable Tool Documentation Most tools include built-in help available through the -h or --help flags:\ntool_name --help For more detailed documentation, many tools include man pages:\nman tool_name Creating Tool Aliases For frequently used tools with complex options, consider creating aliases in your container:\necho 'alias rtlpower-optimized=\"rtl_power -f 88M:108M:25k -g 50 -i 10 -e 1h power.csv\"' \u003e\u003e ~/.zshrc source ~/.zshrc "},"title":"Included Tools"},"/docs/guide/running-rf-swift/":{"data":{"advanced-features#Advanced Features":"Host Isolation RF Swift implements host isolation through several security mechanisms configured in your config.ini file:\n[container] privileged = false caps = seccomp = cgroups = c 189:* rwm,c 166:* rwm,c 188:* rwm Default Security Configuration By default, RF Swift runs containers in unprivileged mode with specific cgroup restrictions:\nUnprivileged Mode: Containers run without full root privileges on the host (privileged = false) Cgroup Restrictions: Controlled device access through character device major numbers: c 189:* rwm: Access to USB serial devices (ttyUSB*) c 166:* rwm: Access to ACM devices (ttyACM*) c 188:* rwm: Access to USB serial converters This provides a reasonable balance between functionality and security for RF applications.\nCustomizing Security Settings You can customize security settings both in the config file and via command-line parameters:\nAdding Capabilities:\n# Via command line rfswift run -i sdr_full -n my_container -a NET_ADMIN,SYS_PTRACE # Via config.ini caps = NET_ADMIN,SYS_PTRACE Custom Seccomp Profile:\n# Via command line rfswift run -i sdr_full -n my_container -m /path/to/seccomp.json # Via config.ini seccomp = /path/to/seccomp.json Additional Cgroup Rules:\n# Via command line rfswift run -i sdr_full -n my_container -g \"c 226:* rwm\" # Via config.ini cgroups = c 189:* rwm,c 166:* rwm,c 188:* rwm,c 226:* rwm â„¹ï¸ Cgroup rules use the format type major:minor permission where:\ntype is c (character) or b (block) major:minor defines the device number (use * for wildcard) permission is r (read), w (write), m (mknod) For example, c 189:* rwm grants full access to all devices with major number 189.\nCommand-Line Security Configuration RF Swift allows you to override or extend security settings directly from the command line when running containers. This is particularly useful for one-off tasks or testing configurations before adding them to your config file.\nComplete List of Security-Related Flags:\nrfswift run [options] Security Options: -u, --privileged int Set privilege level (1: privileged, 0: unprivileged) -a, --capabilities string Extra capabilities (separate with commas) -g, --cgroups string Extra cgroup rules (separate with commas) -m, --seccomp string Set Seccomp profile ('default' one used by default) -s, --devices string Extra devices mapping (separate with commas) Network Options: -t, --network string Network mode (default: 'host') -z, --exposedports string Exposed ports -w, --bindedports string Ports to bind between host and container -x, --extrahosts string Set extra hosts (default: 'pluto.local:192.168.1.2') Resource Options: -b, --bind string Extra volume bindings (separate with commas) -d, --display string Set X Display (default \"DISPLAY=:0\") -p, --pulseserver string PULSE SERVER TCP address (default \"tcp:127.0.0.1:34567\") Examples of Command-Line Security Configurations:\nRun with specific privileges and capabilities:\nrfswift run -i penthertz/rfswift:wifi -n wifi_tools -u 0 -a NET_ADMIN,NET_RAW This runs a container in unprivileged mode but adds the NET_ADMIN and NET_RAW capabilities.\nAdd custom cgroup rules and device mappings:\nrfswift run -i penthertz/rfswift:sdr -n rtlsdr -g \"c 226:* rwm\" -s \"/dev/rtlsdr0:/dev/rtlsdr0\" This adds permission for device major number 226 and maps a specific RTL-SDR device.\nSet a custom seccomp profile:\nrfswift run -i penthertz/rfswift:security -n forensics -m ~/custom_seccomp.json This applies a custom seccomp profile to the container.\nCombined security settings:\nrfswift run -i penthertz/rfswift:bluetooth -n bt_scanner \\ -t bridge \\ -a NET_ADMIN \\ -g \"c 226:* rwm,c 116:* rwm\" \\ -s \"/dev/bluetooth:/dev/bluetooth\" \\ -u 0 This creates a container with:\nBridge networking mode NET_ADMIN capability Custom cgroup rules for devices with major numbers 226 and 116 Specific Bluetooth device mapping Unprivileged mode âš ï¸ Command-line settings always take precedence over config file settings. When using both, command-line options will extend or override the corresponding settings in your config.ini file. ","command-overview#Command Overview":"Letâ€™s explore the available commands with rfswift --help:\nrfswift --help [...] 888~-_ 888~~ ,d88~~\\ ,e, 88~\\ d8 888 \\ 888___ 8888 Y88b e / \" _888__ _d88__ 888 | 888 'Y88b Y88b d8b / 888 888 888 888 / 888 'Y88b, Y888/Y88b/ 888 888 888 888_-~ 888 8888 Y8/ Y8/ 888 888 888 888 ~-_ 888 \\__88P' Y Y 888 888 \"88_/ RF toolbox for HAMs and professionals rfswift is THE toolbox for any HAM \u0026 radiocommunications and hardware professionals Usage: rfswift [flags] rfswift [command] Available Commands: bindings Manage devices and volumes bindings commit Commit a container completion Generate the autocompletion script for the specified shell delete Delete an rfswift images exec Exec a command help Help about any command host Host configuration images RF Swift images management remote/local install Install function script last Last container run remove Remove a container rename Rename a container retag Rename an image run Create and run a program stop Stop a container update Update RF Swift Flags: -q, --disconnect Don't query updates (disconnected mode) -h, --help help for rfswift Use \"rfswift [command] --help\" for more information about a command. â„¹ï¸ Privilege requirements by platform:\nLinux: sudo is required for most container operations when not using Docker Desktop Windows/macOS: With Docker Desktop or OrbStack, sudo is not necessary Windows: Commands related to USB binding require Administrator privileges ","container-architecture-benefits#Container Architecture Benefits":"graph TD; A[Core build]--\u003eB[Image 1]; A--\u003eC[Docker image 2]; B--\u003eD[Container #1 from image 1]; B--\u003eE[Container #2 from image 1]; C--\u003eF[Container from image 2]This architecture provides significant advantages:\nPortability: Move environments between systems easily Isolation: Create separate environments for different tasks Disposability: Create, experiment with, and destroy environments without impact Specialization: Tailored environments for specific assessment needs Efficiency: No need to reinstall entire systems Performance: Less resource-intensive than VMs Time-saving: Quick deployment for last-minute assessment preparations â„¹ï¸ RF Swift significantly flattens the Docker learning curve while providing powerful features like dynamic device binding and host resource integration that would otherwise require considerable Docker expertise. ","core-workflows#Core Workflows":"1. Keeping RF Swift Updated RF Swift automatically checks for updates when launched:\n[!] You are running version: 0.4.8 (Obsolete) [+] Do you want to update to the latest version? (yes/no): You can also trigger updates manually:\nrfswift update [!] Your current version (0.4.8) is obsolete. Please update to version (v0.6.0). [+] Do you want to update to the latest version? (yes/no): yes Latest release download URL: https://github.com/PentHertz/RF-Swift/releases/download/v0.6.0/rfswift_linux_amd64 [+] Do you want to replace the existing binary with this new release? (yes/no): yes 13.67 MiB / 13.67 MiB [---------------------------------------------------------------------------------------------------------------------------------------------------------------------------] 100.00%% File downloaded and replaced successfully. 2. Image Management Customizing Image Tags You can rename image tags for convenience or to match your default configuration:\nrfswift retag -i penthertz/rfswiftdev:sdr_full_amd64 -t myrfswift:latest [+] You are running version: 0.4.9 (Up to date) [+] Image renamed! This allows you to use the default tag in your configuration file:\nLinuxWindowsmacOS cat /home/username/.config/rfswift/config.ini [general] imagename = myrfswift:latest ... type C:\\Users\\username\\AppData\\Roaming\\rfswift\\config.ini [general] imagename = myrfswift:latest ... cat /Users/username/.config/rfswift/config.ini [general] imagename = myrfswift:latest ... With the default tag set, you can simplify the run command:\nrfswift run -n my_container # Equivalent to: rfswift run -i myrfswift:latest -n my_container â„¹ï¸ Changing an imageâ€™s tag makes it a â€œcustomâ€ image in RF Swift, which means it wonâ€™t receive automatic updates from the official registry. 3. Container Management Creating and Running Containers Create a new container from an image:\nrfswift run -i sdr_full -n my_sdr_container Container Listing and Selection If you forget container names, use the last command:\nrfswift last â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â„¹ï¸ Up-to-date â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ You are running the latest version: 0.6.0-dev â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ğŸ¤– Last Run Containers â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Created â”‚ Image Tag (ID) â”‚ Container Name â”‚ Container ID â”‚ Command â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ 2025-04-11T16:47:02+02:00 â”‚ penthertz/rfswift:hardware â”‚ hardware â”‚ b6e43a87e1f6 â”‚ /bin/zsh â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ 2025-04-11T16:23:43+02:00 â”‚ penthertz/rfswift:bluetooth â”‚ missionbluetooth â”‚ 3d92cb59560f â”‚ /bin/zsh â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ 2025-04-11T16:18:22+02:00 â”‚ penthertz/rfswift:rfid â”‚ missionrfid2 â”‚ 50cbccef53f5 â”‚ /bin/zsh â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ ... Restarting Existing Containers To restart the most recently used container:\nrfswift exec To restart a specific container by name:\nrfswift exec -c my_sdr_container Container Lifecycle Management Save container changes as a new image:\nrfswift commit -c my_container -i my_new_image Rename a container:\nrfswift rename -n old_name -d new_name Remove a container:\nrfswift remove -c container_name Delete an image:\nrfswift delete -c penthertz/rfswift:tag_name 4. Device and Resource Management Audio Support RF Swift will warn if audio support is not properly configured:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ âš ï¸ Warning â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Warning: Unable to connect to Pulse server at 127.0.0.1:34567 â”‚ ... â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Enable audio support (run without sudo):\nrfswift host audio enable [+] Successfully loaded module-native-protocol-tcp with index 29 Dynamic Device and Volume Binding One of RF Swiftâ€™s most powerful features is the ability to add or remove device bindings to running containers:\n# Add a USB device to an existing container rfswift bindings add -c my_container -d -s /dev/ttyUSB0:/dev/ttyUSB0 # For some destination, use shortcuts with -t only rfswift bindings add -c my_container -d -t /dev/ttyUSB0 # Add a shared folder rfswift bindings add -c my_container -b ~/projects:/root/projects # Remove a binding rfswift bindings rm -c my_container -t /dev/ttyUSB0 [-d] # List current bindings rfswift bindings list -c my_container Donâ€™t forget the -d switch if you want to deal with devices and not volumes.\n5. Network Configuration RF Swift supports various network isolation modes:\nMode Description host No network isolation (default) bridge Default Docker network driver with isolation none Complete network isolation overlay Connect multiple Docker daemons ipvlan Full IPv4/IPv6 addressing control macvlan Assign MAC addresses to containers Example of using bridge mode with port mapping:\nrfswift run -i bluetooth -n my_container -t bridge -z 8000 -w 8000:127.0.0.1:80/tcp This command:\nUses the -t bridge option to enable bridge networking Maps container port 8000 to host port 80 on localhost with -w 8000:127.0.0.1:80/tcp Exposes port 8000 to other containers with -z 8000 âš ï¸ For Wi-Fi and Bluetooth tools, you may need to add the NET_ADMIN capability: rfswift run -i wifi_tools -n my_container -a NET_ADMIN Be cautious when adding capabilities as they increase security risks if the container is compromised. ","important-settings#Important settings":"Important settingsRF Swift provides a streamlined command-line interface to manage containers for RF and hardware security applications. This guide covers essential commands and workflows.\nâš ï¸ On Linux, unless you are using Docker Desktop, you will need to use sudo with the rfswift command for operations that require elevated privileges. ","using-rf-tools#Using RF Tools":"Once your container is running, you can use any included RF tools. For example, with an SDR device connected:\nâ”Œâ”€[root@topms] - [~] - [Tue Sep 03, 15:15] â””â”€[$]\u003e sdrangel Running SDRAngel with an RTL-SDR âš ï¸ GUI applications require:\nLinux: xhost installed and configured macOS: XQuartz properly configured Windows: Native support via Docker Desktop "},"title":"Running RF Swift"},"/docs/guide/sharing-files/":{"data":{"best-practices-for-file-sharing#Best Practices for File Sharing":" Use Consistent Directory Structures: Create a standardized directory layout for your assessments to make file management easier Organize by Project: Create separate shared directories for different projects or assessments Keep User Data Separate: Use dedicated directories for user data, software configurations, and temporary files Bind Read-Only When Possible: For reference data that shouldnâ€™t be modified, consider mounting as read-only Use Descriptive Container Names: Name containers based on their purpose to easily identify bound directories later ","device-binding-for-rf-hardware#Device Binding for RF Hardware":"Many RF tools require access to specific hardware devices. RF Swift makes it easy to bind these devices to your containers.\nCommon RF Device Bindings Device Type Host Path Container Path Required Capabilities RTL-SDR /dev/bus/usb /dev/bus/usb None HackRF /dev/bus/usb /dev/bus/usb None Proxmark3 /dev/ttyACM0 /dev/ttyACM0 None Bluetooth Adapters /dev/vhci /dev/vhci NET_ADMIN Wi-Fi Adapters /dev/ttyUSB0 /dev/ttyUSB0 NET_ADMIN Most RF Swift images automatically bind common device paths, but you may need to add specific devices or additional bindings for specialized hardware.\nRFID Device Binding For Proxmark3 and similar RFID tools, you may need to bind specific device paths:\n# Default Proxmark3 device rfswift run -i penthertz/rfswift:rfid -n rfid_scanner -s /dev/ttyACM0:/dev/ttyACM0 # For multiple Proxmark3 devices rfswift run -i penthertz/rfswift:rfid -n multi_proxmark \\ -s /dev/ttyACM0:/dev/ttyACM0,/dev/ttyACM1:/dev/ttyACM1 Bluetooth Device Binding For Bluetooth scanning and analysis:\nrfswift run -i penthertz/rfswift:bluetooth -n bt_scanner \\ -s /dev/vhci:/dev/vhci \\ -a NET_ADMIN âš ï¸ Bluetooth and Wi-Fi tools typically require the NET_ADMIN capability in addition to device bindings. Add this with the -a NET_ADMIN parameter. ","file-sharing-between-host-and-container#File Sharing Between Host and Container":"Directory Binding The most common way to share files is by binding a directory from your host system to a location within the container using the -b parameter with the run command.\nBasic Directory Sharing First, create a directory on your host system: # Create a directory on your host mkdir -p ~/shared_data Start a container with this directory bound to a location inside the container: rfswift run -i penthertz/rfswift:telecom -n telecom_analysis -b ~/shared_data:/root/shared This binds your hostâ€™s ~/shared_data directory to /root/shared inside the container.\nMultiple Directory Bindings You can bind multiple directories by separating them with commas:\nrfswift run -i penthertz/rfswift:sdr_full -n sdr_project \\ -b ~/captures:/root/captures,~/scripts:/root/scripts,~/reports:/root/reports âš ï¸ Always specify paths in the format host_path:container_path, and separate multiple bindings with commas. Verifying Bindings The container summary will display all active bindings:\nğŸ§Š Container Summary â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚ Container Name â”‚ telecom_analysis â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ X Display â”‚ :0 â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Shell â”‚ /bin/zsh â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Privileged Mode â”‚ true â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Network Mode â”‚ host â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Image Name â”‚ penthertz/rfswift:telecom â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Size on Disk â”‚ 11150.42 MB â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Bindings â”‚ /tmp/.X11-unix:/tmp/.X11-unix,/dev/bus/usb:/dev/bus/usb, â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ /home/user/shared_data:/root/shared â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Extra Hosts â”‚ pluto.local:192.168.2.1 â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ Adding Bindings to Existing Containers If you forgot to bind a directory when creating a container, you can add it later using the bindings command:\nrfswift bindings add -c telecom_analysis -s ~/new_data -t /root/new_data Working with Shared Files Once your directories are bound, you can access them from within the container:\n# Inside the container cd /root/shared touch analysis_results.txt echo \"Signal detected at 915MHz\" \u003e analysis_results.txt The file will be immediately available on your host system at ~/shared_data/analysis_results.txt.\nâ„¹ï¸ File changes are bidirectional and immediate. Any changes made on either the host or container side will be instantly visible on the other side. ","next-steps#Next Steps":"Now that you understand how to share files and devices, you might want to create your own customized images:\nBuild Your Own ImageBecome a master chef and create your own custom RF Swift images. ","sharing-files-and-devices#Sharing Files and Devices":"Sharing Files and DevicesWhen conducting RF assessments with RF Swift, youâ€™ll need to exchange files between your host system and containers, as well as connect specialized hardware devices. This guide covers various file sharing methods and device binding techniques for common RF hardware.","specialized-hardware-configuration#Specialized Hardware Configuration":"Harogic Spectrum Analyzer Setup Harogic spectrum analyzers require calibration files to function properly. Hereâ€™s how to configure a container for use with these devices:\n1. Copy Calibration Files First, copy the calibration files from the provided USB to your host:\nContent of Harogic USB key # Copy from USB to host cp -R /media/username/37B6-82D6/CalFile ~/harogic_cal 2. Bind Calibration Directory When creating your container, bind the calibration directory to the proper location:\nrfswift run -i penthertz/rfswift:sdr_light -n harogic_analysis \\ -b ~/harogic_cal:/rftools/analysers/SAStudio4_x86_64_05_23_17_06/bin/CalFile 3. Run SAStudio Once inside the container, you can run SAStudio with the calibration files properly configured:\n# Inside the container sastudio Harogic device running with SaStudio Using Harogic with SDR++ To use Harogic devices with SDR++, copy the calibration files to the correct location:\n# Inside the container cp -R /rftools/analysers/SAStudio4_x86_64_05_23_17_06/bin/CalFile /usr/bin Then launch SDR++:\nsdrpp Running SDR++ with Harogic ","troubleshooting#Troubleshooting":"Permission Issues If you experience permission errors when accessing shared directories:\n# On the host, ensure proper ownership sudo chown -R your_username:your_username ~/shared_data # Or make the directory world-writable (less secure) chmod -R 777 ~/shared_data Missing Bindings If default bindings are missing, you can restore them while adding your custom bindings:\nrfswift run -i penthertz/rfswift:sdr_full -n sdr_analysis \\ -b /tmp/.X11-unix:/tmp/.X11-unix,/dev/bus/usb:/dev/bus/usb,~/my_data:/root/my_data "},"title":"Sharing Files \u0026 Devices"},"/docs/quick-start/":{"data":{"#":"Getting Up and Running with RF SwiftThis guide will help you quickly get started with RF Swift using pre-built binaries and container images.\nâš ï¸ On Linux, unless you are using Docker Desktop, you may need to use sudo with the rfswift command for operations that require elevated privileges. To install RF Swift, you can either use pre-compiled binaries and existing container images (quickest method) or compile the Go project and/or Docker images from source. This guide focuses on the fastest way to get up and running.\nInstall RF Swift Linux and macOS The easiest way to install RF Swift on Linux or macOS is to use the installation script:\n# Clone the repository git clone https://github.com/PentHertz/RF-Swift.git cd RF-Swift # Run the installation script ./install.sh The install.sh script will:\nInstall all required dependencies (Docker, BuildX, Go) Configure necessary services (xhost, PulseAudio) Set up proper permissions Create a system-wide alias for the rfswift command Install the latest RF Swift binary Windows or Manual Installation If you prefer manual installation or are using Windows:\nDownload the latest binary from the official repository â†— Rename the binary to rfswift (or rfswift.exe on Windows) Make the binary executable (on Linux/macOS): chmod +x rfswift When you run the binary for the first time, it will guide you through configuration:\nrfswift Config file not found. Would you like to create one with default values? (y/n) Select y to create a default configuration file or n to configure manually.\nPull a Pre-built Image RF Swift provides several pre-built images to get you started quickly. For example, letâ€™s pull a complete SDR image:\nrfswift images pull -i sdr_full You can also specify a custom tag for the image:\nrfswift images pull -i sdr_full -t my_custom_tag Available Options:\n-i: Remote image label (required) -t: Local tag to assign to the pulled image (optional) -r: Repository to pull from (defaults to penthertz/rfswift) â„¹ï¸ You can use the complete image tag penthertz/rfswift:sdr_full if you prefer, or change the default repository in your RF Swift profile. Run the Container Once you have an image, you can create and run a container:\nrfswift run -i sdr_full -n my_sdr_container This will start a container using the sdr_full image with the name my_sdr_container.\nRun Command Options:\nrfswift run -i sdr_full -n my_sdr_container The run command has numerous options for configuring your container environment:\nFlag Description -i, --image string Image name/tag to use (default: â€˜myrfswift:latestâ€™) -n, --name string Name for the container (makes it easier to reference later) -b, --bind string Extra bind mounts, separated by commas (e.g., /host/path:/container/path,/another/path:/in/container) -s, --devices string Extra device mappings in unprivileged mode, separated by commas (e.g., /dev/ttyUSB0:/dev/ttyUSB0) -a, --capabilities string Extra Linux capabilities, separated by commas (e.g., NET_ADMIN,SYS_ADMIN) -t, --network string Network mode (default: â€˜hostâ€™) -u, --privileged int Set privilege level (1: privileged, 0: unprivileged) -e, --command string Command to execute (default: â€˜/bin/bashâ€™) -d, --display string Set X Display (duplicates hostâ€™s env by default) (default â€œDISPLAY=:0â€) -p, --pulseserver string PulseAudio server TCP address (default: â€œtcp:127.0.0.1:34567â€) -w, --bindedports string Ports to bind (between container and host) -z, --exposedports string Ports to expose -x, --extrahosts string Set extra hosts (default: â€˜pluto.local:192.168.1.2â€™), separated by commas -g, --cgroups string Extra cgroup rules, separated by commas -m, --seccomp string Set Seccomp profile (default: â€˜defaultâ€™) Share Files with the Container:\nTo share files between your host system and the container:\nrfswift run -i sdr_full -n my_sdr_container -b ~/sdr_projects:/home/user/projects You can bind multiple directories by separating them with commas:\nrfswift run -i sdr_full -n my_sdr_container -b ~/sdr_projects:/home/user/projects,~/datasets:/home/user/data Share Specific Devices:\nWhen running in unprivileged mode, you can share specific devices:\nrfswift run -i sdr_full -n my_sdr_container -s /dev/ttyUSB0:/dev/ttyUSB0 Multiple devices can be shared by separating them with commas:\nrfswift run -i sdr_full -n my_sdr_container -s /dev/ttyUSB0:/dev/ttyUSB0,/dev/ttyACM0:/dev/ttyACM0 Add Linux Capabilities:\nFor Wi-Fi and Bluetooth tools, you may need additional Linux capabilities:\nrfswift run -i wifi_tools -n my_wifi_container -a NET_ADMIN For multiple capabilities:\nrfswift run -i advanced_tools -n my_container -a NET_ADMIN,SYS_ADMIN âš ï¸ Security Consideration: Be cautious when adding capabilities like NET_ADMIN. If the container becomes compromised, malicious programs could capture or manipulate network interfaces! Only add capabilities that are strictly necessary for your work. Network Configuration:\nBy default, containers use the host network mode. To use a different network:\nrfswift run -i sdr_full -n my_sdr_container -t bridge Privilege Levels:\nControl container privilege level:\n# Run in unprivileged mode rfswift run -i sdr_full -n my_sdr_container -u 0 # Run in privileged mode (use with caution) rfswift run -i sdr_full -n my_sdr_container -u 1 Custom Commands:\nRun a specific command instead of the default shell:\nrfswift run -i gnuradio -n signal_processor -e \"gnuradio-companion\" â„¹ï¸ Using a named container with the -n flag makes it much easier to restart or access the container later. Use RF Tools in the Container Once the container is running, you can use any of the pre-installed RF tools. For example, to run SDR++:\nConnect your SDR device to your computer Inside the container, run: sdrpp âš ï¸ If you encounter audio issues, you can enable audio forwarding with: rfswift host audio enable This requires pulseaudio to be properly configured on your host system. USB Device Management USB device handling varies by platform:\nWindows USB Forwarding On Windows, youâ€™ll need to explicitly forward USB devices to your container using the winusb commands in Administrator mode:\n# List available USB devices on Windows rfswift winusb list # Attach a specific device on Windows rfswift winusb attach -i \u003cUSB ID\u003e Linux USB Device Access On Linux, you can access USB devices in two ways:\nDuring container creation - use the -s option to bind specific devices:\nrfswift run -i sdr_full -n my_container -s /dev/ttyUSB0:/dev/ttyUSB0 After container creation - use the powerful bindings feature to add devices to an existing container:\n# Add a new USB device to an existing container rfswift bindings add -c my_container -d -s /dev/ttyUSB0 -t /dev/ttyUSB0* # Same but shorter: Add a new USB device to an existing container with some destination rfswift bindings add -c my_container -t /dev/ttyUSB0 # Add a new volume to an existing container rfswift bindings add -c my_container -s /home/user/data -t /root/data # Remove a binding rfswift bindings rm -c my_container -s /dev/ttyUSB0 Note that to rebind a device, you need the -d switch.","common-commands-reference#Common Commands Reference":" Command Description rfswift run -i IMAGE -n NAME Create and run a new container rfswift exec -c CONTAINER Enter an existing container rfswift images local List available local images rfswift last List all containers rfswift host audio enable Enable audio forwarding rfswift host video enable Enable video forwarding ","creating-an-alias-linuxmacos#Creating an Alias (Linux/macOS)":"For convenience, you can create an alias to run RF Swift from anywhere. If you didnâ€™t use the install.sh script (which creates this automatically), you can add an alias manually:\necho \"alias rfswift='$(pwd)/rfswift'\" \u003e\u003e \"$HOME/.$(basename $SHELL)rc\" source \"$HOME/.$(basename $SHELL)rc\" Replace $(pwd)/rfswift with the full path to your RF Swift binary.","getting-up-and-running-with-rf-swift#Getting Up and Running with RF Swift":"","managing-existing-containers#Managing Existing Containers":"Restart an Existing Container To return to a previously created container:\nrfswift exec -c my_sdr_container You can also use the short command if you want to recall the last container:\nrfswift exec This restarts the container if itâ€™s stopped and gives you a shell inside it.\nList Running Containers View all RF Swift containers:\nrfswift last Save Container State If youâ€™ve made changes to a container that you want to preserve:\nrfswift commit -c my_sdr_container -i my_custom_image This saves the current state of the container as a new image.","next-steps#Next Steps":"Dive right into the following section to learn more:\nFollow the GuideRead the complete guide and learn how to use RF Swift for your daily assessments. "},"title":"ğŸš€ Quick Start"}}